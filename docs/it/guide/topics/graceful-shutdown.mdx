# Arresto Grazioso

L'arresto grazioso (Graceful Shutdown) si riferisce al processo in cui, durante lo spegnimento di un server, non vengono immediatamente terminate tutte le connessioni. Invece, il server interrompe prima l'accettazione di nuove richieste, concedendo alle richieste esistenti il tempo necessario per completare l'elaborazione prima di chiudere il servizio. Questo approccio evita l'interruzione brusca delle richieste, migliorando così l'esperienza utente e l'affidabilità del sistema.

Salvo fornisce supporto per l'arresto grazioso tramite il metodo `handle` del `Server`, che recupera l'handle del server, seguito dalla chiamata al metodo `stop_graceful` per implementare lo spegnimento. Dopo aver invocato questo metodo, il server:

- Interrompe l'accettazione di nuove richieste di connessione
- Attende il completamento dell'elaborazione delle richieste esistenti
- Chiude forzatamente eventuali connessioni rimanenti dopo un timeout specificato (se fornito)

Ecco un semplice esempio:

```rust
use salvo_core::prelude::*;

#[tokio::main]
async fn main() {
    let acceptor = TcpListener::new("127.0.0.1:5800").bind().await;
    let server = Server::new(acceptor);
    let handle = server.handle();

    // Arresta il server in modo grazioso
    tokio::spawn(async move {
        tokio::time::sleep(std::time::Duration::from_secs(60)).await;
        handle.stop_graceful(None);
    });
    server.serve(Router::new()).await;
}
```

Nell'esempio sopra:

- `server.handle()` recupera l'handle del server, che può essere utilizzato per controllare il ciclo di vita del server
- `handle.stop_graceful(None)` avvia il processo di arresto grazioso, dove `None` indica che non è impostato alcun timeout, il che significa che il server attenderà indefinitamente il completamento di tutte le richieste
- Per impostare un timeout, è possibile passare `Some(Duration)`, dopo il quale eventuali connessioni rimanenti verranno chiuse forzatamente

Questo approccio è particolarmente adatto per applicazioni distribuite in ambienti containerizzati o su piattaforme cloud, nonché per scenari che richiedono aggiornamenti a caldo per garantire che le richieste non vengano interrotte inaspettatamente.
{/* Auto generated, origin file hash:046b3113209f454ef7a16224e721cfcb */}