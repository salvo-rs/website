---
title: Rust Serialization Framework
---

# Serde: Rust Serialization and Deserialization Framework

[Serde](https://docs.rs/serde/latest/serde/) is a core library in the Rust ecosystem, providing an efficient and versatile framework for serialization and deserialization. Its name is derived from the combination of "**Ser**ialization" and "**De**serialization."

## Key Features

- **Versatility**: Supports multiple data formats such as JSON, YAML, TOML, MessagePack, and more.
- **Zero-Cost Abstraction**: Code generated at compile time is as efficient as handwritten code.
- **Flexibility**: Allows customization of serialization and deserialization behavior.
- **Strong Typing**: Leverages Rust's type system to ensure data integrity.
- **Wide Adoption**: Serves as the standard library for data exchange in the Rust ecosystem.

## How It Works

The core of Serde lies in its Intermediate Representation (IR) design, which divides the serialization and deserialization processes into two steps:

1. **Serialization**: Converts Rust data structures into a generic intermediate representation, then into the target format.
2. **Deserialization**: Converts input formats into the generic intermediate representation, then into Rust data structures.

This design enables the addition of new data formats without modifying applications that use Serde.

## Basic Usage

### Setting Up Dependencies

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0" # Or other format libraries like serde_yaml, toml, etc.
```

### Using Derive Macros

The most common usage involves using derive macros to automatically implement serialization and deserialization traits for structs:

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    // Convert Point to a JSON string
    let serialized = serde_json::to_string(&point).unwrap();
    println!("Serialized result: {}", serialized); // Output: {"x":1,"y":2}

    // Convert the JSON string back to Point
    let deserialized: Point = serde_json::from_str(&serialized).unwrap();
    println!("Deserialized result: {:?}", deserialized); // Output: Point { x: 1, y: 2 }
}
```

### Attribute Customization

Serde provides a rich set of attributes to customize serialization behavior:

```rust
#[derive(Serialize, Deserialize, Debug)]
struct User {
    #[serde(rename = "user_id")]
    id: u64,
    
    #[serde(default)]
    name: String,
    
    #[serde(skip_serializing_if = "Option::is_none")]
    email: Option<String>,
    
    #[serde(skip)]
    temporary_data: usize,
}
```

### Supported Data Formats

Serde integrates with various data formats, each with its own crate:

- **serde_json**: JSON format
- **serde_yaml**: YAML format
- **toml**: TOML format
- **bincode**: Binary format
- **postcard**: Space-optimized binary format
- **rmp/rmp-serde**: MessagePack format
- **ciborium**: CBOR format
- ...and other formats

## Advanced Usage

### Manual Trait Implementation

For special requirements, you can manually implement the `Serialize` and `Deserialize` traits:

```rust
use serde::{Serialize, Serializer, Deserialize, Deserializer};

struct MyType {
    // Fields...
}

impl Serialize for MyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Custom serialization logic
    }
}

impl<'de> Deserialize<'de> for MyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Custom deserialization logic
    }
}
```

### Type Mapping

You can create mappings between different data representations:

```rust
#[derive(Serialize, Deserialize)]
#[serde(remote = "chrono::DateTime<chrono::Utc>")]
struct DateTimeRef {
    #[serde(with = "chrono::serde::ts_seconds")]
    pub inner: chrono::DateTime<chrono::Utc>,
}
```

## Learning and Resources

Serde is a feature-rich library, and this article only covers the basics. To fully leverage Serde, it is recommended to:

1. Visit the [Serde official documentation](https://serde.rs/) for detailed APIs and examples.
2. Check the [GitHub repository](https://github.com/serde-rs/serde) for source code and the latest updates.

## Conclusion

As a foundational library in the Rust ecosystem, Serde provides powerful and flexible tools for data exchange. By mastering Serde, you can effortlessly handle various data exchange requirements, making your applications more robust and interoperable.
{/* Auto generated, origin file hash:02cf744a3fbae09d654887c13e131157 */}