# Tratamento de Erros

## Métodos Comuns de Tratamento de Erros em Aplicações Rust

O tratamento de erros em Rust difere de linguagens como Java, não possuindo algo como `try...catch`. A abordagem usual é definir um tipo de erro global no nível da aplicação:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("io: `{0}`")]
    Io(#[from] io::Error),
    #[error("utf8: `{0}`")]
    FromUtf8(#[from] FromUtf8Error),
    #[error("diesel: `{0}`")]
    Diesel(#[from] diesel::result::Error),
    ...
}

pub type AppResult<T> = Result<T, AppError>;
```

Aqui, utilizamos a biblioteca `thiserror`, que facilita a definição de seus próprios tipos de erro personalizados, simplificando o código. Para facilitar a escrita, também definimos um `AppResult`.

### thiserror vs anyhow

No ecossistema de tratamento de erros do Rust, duas bibliotecas comumente utilizadas são `thiserror` e `anyhow`:

- **thiserror**: Adequada para desenvolvedores de bibliotecas, usada para definir tipos de erro claros. Através de macros derivadas, ela auxilia na implementação da trait `std::error::Error` para seus tipos de erro personalizados, permitindo também definir como os erros são representados. Ao construir uma biblioteca ou quando é necessário fornecer tipos de erro claros aos usuários, `thiserror` é a escolha mais apropriada.

- **anyhow**: Adequada para desenvolvedores de aplicações, fornece um tipo de erro genérico `anyhow::Error`, capaz de encapsular qualquer erro que implemente a trait `std::error::Error`. Ela foca mais na propagação de erros do que na sua definição, sendo especialmente útil para código no nível da aplicação. Você pode rapidamente converter vários erros em `anyhow::Error`, reduzindo a necessidade de escrever código repetitivo.

Em alguns cenários, você pode utilizar ambas as bibliotecas: usar `thiserror` para definir tipos de erro na biblioteca e `anyhow` para tratar e propagar esses erros na aplicação.

## Tratamento de Erros em Handlers

No Salvo, `Handler`s frequentemente encontram diversos tipos de erros, como: erros de conexão com banco de dados, erros de acesso a arquivos, erros de conexão de rede, etc. Para esses tipos de erro, podemos adotar a abordagem de tratamento mencionada acima:

```rust
#[handler]
async fn home() -> AppResult<()> {

}
```

Aqui, `home` retorna diretamente um `AppResult<()>`. Mas como esse erro deve ser exibido? Precisamos implementar a trait `Writer` para o tipo de erro personalizado `AppResult`. Nessa implementação, podemos decidir como exibir o erro:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        res.render(Text::Plain("I'm a error, hahaha!"));
    }
}
```

Em Salvo, um `Handler` pode retornar um `Result`, desde que tanto o tipo `Ok` quanto o tipo `Err` dentro do `Result` implementem a trait `Writer`.

### Tratamento de Erros com anyhow

Considerando que o uso do anyhow é bastante difundido, o Salvo oferece suporte embutido para `anyhow::Error`. Ao habilitar o recurso `anyhow`, `anyhow::Error` implementará a trait `Writer` e será mapeado para `InternalServerError`:

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Para usar o recurso anyhow, é necessário habilitar o feature `anyhow` do Salvo no Cargo.toml:

```toml
[dependencies]
salvo = { version = "*", features = ["anyhow"] }
anyhow = "1.0"
```

Dessa forma, suas funções de handler podem retornar diretamente `anyhow::Result<T>`:

```rust
#[handler]
async fn home() -> anyhow::Result<impl Writer> {
    let data = fetch_data().context("Failed to fetch data")?;
    Ok(Text::Plain(data))
}
```

Erros frequentemente contêm informações sensíveis que, em geral, não desejamos que sejam visíveis para usuários comuns, pois isso seria inseguro e não respeitaria a privacidade. No entanto, se você for um desenvolvedor ou administrador do site, sua perspectiva pode ser diferente: você pode querer que o erro se revele completamente, mostrando as informações de erro mais precisas.

Como podemos observar, no método `write`, temos acesso a referências de `Request` e `Depot`, o que facilita a implementação da operação mencionada acima:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let user = depot.obtain::<User>();
        if user.is_admin {
            res.render(Text::Plain(e.to_string()));
        } else {
            res.render(Text::Plain("I'm a error, hahaha!"));
        }
    }
}
```

## Exibição de Páginas de Erro

A página de erro padrão do Salvo atende às necessidades na grande maioria dos casos, podendo exibir páginas em Html, Json ou Xml dependendo do tipo de dados da requisição. No entanto, em algumas situações, ainda podemos desejar personalizar a exibição da página de erro.

Isso pode ser implementado através de um `Catcher` personalizado. Para uma explicação detalhada, consulte a seção sobre [`Catcher`](../concepts/catcher.html).
{/* 本行由工具自动生成,原文哈希值:ccc3ad5dca846f6b6415dbe84e0c5166 */}