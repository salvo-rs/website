---
title: Salvo LLMs
---

```markdown
# Фреймворк Salvo для веб-разработки

> Salvo — это асинхронный, высокопроизводительный и многофункциональный веб-фреймворк, написанный на языке Rust. Он отличается простотой, модульностью, удобством использования и расширения, а также предоставляет мощные возможности: маршрутизацию, промежуточное ПО (Hoop), извлечение данных, WebSocket, TLS (с горячей перезагрузкой сертификатов OpenSSL/Rustls), HTTP/3, автоматическое управление сертификатами ACME, различные стратегии обратного проксирования, контроль времени выполнения запросов, обработку ошибок (Catcher), поддержку OpenAPI и многое другое.

### Единство концепций и простота:
Одна из ключевых особенностей Salvo — унификация обработчиков (Handler) и промежуточного ПО (Middleware). Оба реализуют трейт Handler и отвечают за обработку запросов (Request) и возможное изменение ответов (Response). Такой подход сокращает количество изучаемых концепций, делая фреймворк более понятным и удобным. Промежуточное ПО применяется через специальные методы маршрутизации, например, hoop.

### Приоритет удобства разработчика (DX):

Гибкие сигнатуры обработчиков: макрос #[handler] значительно упрощает написание обработчиков. Разработчикам не нужно указывать полный список параметров или соблюдать их строгий порядок. Достаточно объявить в сигнатуре функции только те параметры, которые действительно нужны (например, &mut Request, &mut Depot, &mut Response), при этом их можно пропускать или менять местами. Это делает код чище и позволяет сосредоточиться на бизнес-логике.

Примеры функций hello_world наглядно демонстрируют этот подход: в одной используется полная сигнатура (хотя параметры помечены подчёркиванием как неиспользуемые), а в другой остаётся только необходимый &mut Response.

Обмен данными в рамках запроса: Depot предоставляет временное хранилище данных на время обработки запроса. Промежуточное ПО и обработчики могут обмениваться информацией через Depot (например, промежуточное ПО аутентификации сохраняет данные пользователя, а последующие обработчики их читают).

Минимализм зависимостей и интеграция с экосистемой: Как видно из Cargo.toml, базовое приложение Salvo требует минимум зависимостей, в основном полагаясь на проверенные библиотеки, такие как tokio (асинхронная среда выполнения) и tracing (логирование/трейсинг), вместо изобретения велосипедов.

## Список файлов

*   **Основные концепции**:
    *   **`Server`**: Экземпляр веб-сервера, отвечающий за приём соединений и обработку запросов.
    *   **`Router`**: Определяет правила маршрутизации, сопоставляя URL и HTTP-методы с соответствующими обработчиками (Handler). Поддерживает параметры пути (`{name}` или `{id:num}`), подстановочные знаки (`{*rest}`, `{**rest}`) и сложные условия через `.host()` или `.filter_fn()`. `.push()` добавляет дочерние маршруты, `.then()` — условные маршруты.
    *   **`Handler`**: Основной элемент обработки запросов, обычно асинхронная функция. Макрос `#[handler]` преобразует функцию в Handler, позволяя опускать или переставлять параметры (`Request`, `Depot`, `Response`, `FlowCtrl`). Обработчики также могут выступать в роли промежуточного ПО или обработчиков ошибок. Могут возвращать типы, реализующие `Writer` или `Scribe`, либо `Result<T, E>` (где T и E реализуют `Writer`).
    *   **`Middleware / Hoop`**: В Salvo промежуточное ПО добавляется методом `hoop`. Это логические модули, выполняемые до основного Handler или перед отправкой ответа клиенту.
    *   **`Request`**: Входящий HTTP-запрос, содержащий заголовки, метод, путь, параметры запроса, тело и т.д. Предоставляет методы `.parse_*()` и `.extract()` для преобразования данных в строго типизированные структуры. `.file()` и `.files()` обрабатывают загрузку файлов. `.remote_addr()` возвращает адрес клиента.
    *   **`Response`**: Исходящий HTTP-ответ для установки кода состояния (`.status_code()`), заголовков (`.headers_mut()`, `.add_header()`), тела ответа и т.д. Метод `.render()` упрощает формирование тела ответа (текст, HTML, JSON, редиректы). `.channel()` поддерживает потоковую передачу.
    *   **`Depot`**: Типизированное хранилище данных, связанное с запросом, для обмена информацией между Handler и промежуточным ПО. Использует `.insert("ключ", значение)`/`.get::<T>("ключ")` или `.inject(значение)`/`.obtain::<T>()`.
    *   **`TcpListener` / `UnixListener`**: Создают сетевые слушатели. `.bind().await` возвращает `Acceptor`. Поддерживают TLS через `.rustls()`, `.openssl()`, `.native_tls()`, автоматическое управление сертификатами через `.acme()` и QUIC/HTTP3 через `.quinn()`. `.join()` объединяет несколько слушателей.
    *   **`Service`**: Комбинация маршрутизатора (Router) и обработчиков ошибок/Catchers. Создаётся как `Service::new(router)`.
    *   **`Catcher`**: Перехватывает и обрабатывает ошибки (например, 404, 500). Добавляется через `Service::catcher()`. Поддерживает `hoop` для настройки логики обработки.
    *   **`FlowCtrl`**: Доступен в промежуточном ПО и Catcher Handler для управления потоком обработки запросов (например, `ctrl.skip_rest()`).
    *   **`Writer` / `Scribe`**: Трейты для записи данных в `Response`.
    *   **`Extractible`**: Макрос для автоматического извлечения данных из запроса в структуру.
    *   **`#[endpoint]`**: Улучшенная версия `#[handler]` для автоматической генерации документации OpenAPI.
    *   **`OpenApi`**: Генерирует спецификацию OpenAPI. `.merge_router()` собирает информацию о маршрутах. `.into_router()` создаёт маршрут для предоставления JSON-спецификации.
    *   **`SwaggerUi`, `Scalar`, `RapiDoc`, `ReDoc`**: Интерактивный интерфейс для документации OpenAPI.
    *   **`#[craft]`**: Макрос для преобразования методов структуры в Handler или Endpoint, упрощая логику обработки с состоянием.
    *   **`#[tokio::main]`**: Salvo использует асинхронную среду выполнения Tokio.
    *   **`tracing` / `tracing-subscriber`**: Популярные библиотеки для логирования.

*   [Основы (hello)](hello/): Простейшее приложение Salvo, демонстрирующее Handler, Router и запуск сервера.
    *   **Использование**: `#[handler] async fn hello()...`, `Router::new().get(hello)`, `Server::new(acceptor).serve(router)`.
*   [Быстрый старт (Quick Start)](guide/quick-start.mdx): Руководство по установке Rust, созданию первого проекта Salvo, использованию макроса `#[handler]`, пример HTTP/3 и инструмента Salvo CLI.
*   [Основные концепции (Concepts)](guide/concepts/):
    *   [Handler](guide/concepts/handler.md): Определение Handler, использование как промежуточного ПО (hoop) и цели (goal), подробное описание макроса `#[handler]`, обработка ошибок (`Result<T: Writer, E: Writer>`).
    *   [Request](guide/concepts/request.md): Получение параметров запроса (`.query()`), данных формы (`.form()`), JSON (`.parse_json()`), параметров пути (`.param()`), заголовков (`.header()`). Описание макроса `Extractible` и встроенных экстракторов (`JsonBody`, `FormBody`, `QueryParam` и др.) для автоматического извлечения данных.
    *   [Response](guide/concepts/response.md): Использование `.render()` для записи текста, JSON, HTML; установка кода состояния (`.status_code()`); выполнение редиректов (`Redirect::found()`).
    *   [Router](guide/concepts/router.mdx): Определение маршрутов (плоские vs древовидные), сопоставление путей (статические, параметры `{id}`, числа `{id:num}`, регулярные выражения `{id:regex}`, подстановочные знаки `{*rest}`, `{**rest}`), фильтры (`.filter()`, `.filter_fn()`), промежуточное ПО (`.hoop()`), условные маршруты (`.then()`).
    *   [Depot](guide/concepts/depot.mdx): Использование `insert`/`get` и `inject`/`obtain` для обмена данными в рамках обработки запроса.
    *   [Catcher](guide/concepts/catcher.mdx): Обработка ошибок (например, 404) через `Service::catcher()` и пользовательские Handler.
    *   [Writer & Scribe](guide/concepts/writer.mdx): Трейты для записи пользовательских типов в `Response`.
*   [Основные возможности (Features)](guide/features/):
    *   [ACME (Let's Encrypt)](guide/features/acme.mdx): Автоматическое получение и обновление TLS-сертификатов.
        *   **Функция**: `acme`
        *   [HTTP-01 вызов](acme-http01/): Проверка через порт 80. **Использование**: `TcpListener::new(...):443.acme().cache_path(...).add_domain(...).http01_challenge(&mut router).join(TcpListener::new(...):80).bind()`.
        *   [HTTP-01 вызов + QUIC/HTTP3](acme-http01-quinn/): Одновременное включение ACME и HTTP3. **Использование**: Добавление `.quinn("0.0.0.0:443")` после `http01_challenge`.
        *   [TLS-ALPN-01 вызов](acme-tls-alpn01/): Проверка через порт 443 без необходимости слушать порт 80. **Использование**: `TcpListener::new(...):443.acme().cache_path(...).add_domain(...).bind()` (по умолчанию используется TLS-ALPN-01).
    *   [Внедрение состояния (Affix State)](guide/features/affix-state.mdx): Использование промежуточного ПО `affix_state::inject()` и `affix_state::insert()` для добавления общих данных в `Depot`.
        *   **Функция**: `affix-state`
        *   **Использование**: `router.hoop(affix_state::inject(config).insert("ключ", значение)`, в Handler — `depot.obtain::<Config>()` или `depot.get::<T>("ключ")`.
    *   [Базовая аутентификация (Basic Auth)](guide/features/basic-auth.mdx): Реализация HTTP Basic Auth.
        *   **Функция**: `basic-auth`
        *   **Использование**: Реализация трейта `BasicAuthValidator`, создание промежуточного ПО `BasicAuth::new(validator)` и добавление через `hoop()`.
    *   [Кэширование ответов (Cache)](guide/features/cache.mdx): Кэширование ответов Handler.
        *   **Функция**: `cache`
        *   **Использование**: Настройка `CacheStore` (например, `MokaStore` с TTL) и `CacheIssuer` (например, `RequestIssuer`), создание промежуточного ПО `Cache::new(store, issuer)` и добавление через `hoop()`.
    *   [Заголовки кэширования (Caching Headers)](guide/features/caching-headers.mdx): Автоматическое добавление заголовков `ETag` и `Cache-Control`.
        *   **Функция**: `caching-headers`
        *   **Использование**: `Router::with_hoop(CachingHeaders::new())`, рекомендуется размещать перед `Compression`.
    *   [Перехват паники (Catch Panic)](guide/features/catch-panic.mdx): Предотвращение аварийного завершения сервера из-за паники в Handler.
        *   **Функция**: `catch-panic`
        *   **Использование**: `Router::new().hoop(CatchPanic::new())`, рекомендуется в качестве первого промежуточного ПО.
    *   [Сжатие ответов (Compression)](guide/features/compression.mdx): Сжатие тела ответа (gzip, brotli, zstd).
        *   **Функция**: `compression`
        *   **Использование**: `Compression::new().enable_gzip(...).enable_brotli(...).hoop(middleware)`.
    *   [Ограничение параллелизма (Concurrency Limiter)](guide/features/concurrency-limiter.mdx): Ограничение количества одновременно обрабатываемых запросов.
        *   **Функция**: `concurrency-limiter`
        *   **Использование**: `Router::new().hoop(max_concurrency(n))`.
    *   [CORS (междоменные запросы)](guide/features/cors.mdx): Настройка политики CORS.
        *   **Функция**: `cors`
        *   **Использование**: Настройка `Cors::new().allow_origin(...).allow_methods(...).into_handler()` и добавление в `Service` (обычно через `hoop`).
    *   [Функциональность Craft](guide/features/craft.mdx): Использование макроса `#[craft]` для преобразования методов структуры в Handler или Endpoint.
        *   **Функция**: `craft`, `oapi` (рекомендуется)
        *   **Использование**: `#[craft]` для `impl`, `#[craft(handler)]` или `#[craft(endpoint)]` для методов. В маршрутах вызывается как `opts.method_name()` или `Struct::method_name()`.
    *   [Защита от CSRF](guide/features/csrf.mdx): Предотвращение межсайтовой подделки запросов.
        *   **Функция**: `csrf`
        *   [Хранение в Cookie](csrf-cookie-store/): Сохранение токена в Cookie. **Использование**: Настройка `Finder` (например, `FormFinder`) и `Store` (например, `bcrypt_cookie_csrf(finder)`), добавление промежуточного ПО через `hoop()`, получение токена через `depot.csrf_token()`.
        *   [Хранение в сессии](csrf-session-store/): Сохранение токена в сессии. **Функция**: `session`. **Использование**: Аналогично CookieStore, но требуется предварительное добавление `SessionHandler`, используется `bcrypt_session_csrf(finder)` и т.п.
    *   [Flash-сообщения](guide/features/flash.mdx): Временные сообщения перед редиректом.
        *   **Функция**: `flash`
        *   [Хранение в Cookie](flash-cookie-store/): **Использование**: `Router::new().hoop(CookieStore::new().into_handler())`. В Handler — `depot.outgoing_flash_mut().info(...)` для установки, `depot.incoming_flash()` для чтения.
        *   [Хранение в сессии](flash-session-store/): **Функция**: `session`. **Использование**: Сначала добавляется `SessionHandler`, затем `hoop(SessionStore::new().into_handler())`.
    *   [Принудительный HTTPS](guide/features/force-https.mdx): Перенаправление HTTP на HTTPS.
        *   **Функция**: `force-https`, `rustls` (или другой TLS)
        *   **Использование**: `Service::new(router).hoop(ForceHttps::new().https_port(443))`. Обычно требуется одновременный запуск HTTP и HTTPS.
    *   [Поддержка HTTP/3 (Quinn)](guide/features/hello-h3.mdx): Включение HTTP/3 и QUIC.
        *   **Функция**: `quinn`
        *   **Использование**: Настройка TLS (`RustlsConfig`), использование `QuinnListener::new(quinn_config, addr).join(tcp_listener).bind()`.
    *   [Аутентификация JWT](guide/features/jwt-auth.mdx): Проверка JSON Web Token.
        *   **Функция**: `jwt-auth`
        *   **
{/* 本行由工具自动生成,原文哈希值:1b65997e58714cf1ee60f5e6f978e706 */}