# Datenbanken verwenden

### [Diesel](https://diesel.rs/)

```rust
use diesel::prelude::*;
use diesel::r2d2::{ConnectionManager, Pool, PoolError, PooledConnection};
use once_cell::sync::OnceCell;
use salvo::prelude::*;

const DB_URL: &str = "postgres://benchmarkdbuser:benchmarkdbpass@tfb-database/hello_world";
type PgPool = Pool<ConnectionManager<PgConnection>>;

static DB_POOL: OnceCell<PgPool> = OnceCell::new();

fn connect() -> Result<PooledConnection<ConnectionManager<PgConnection>>, PoolError> {
    DB_POOL.get().unwrap().get()
}
fn build_pool(database_url: &str, size: u32) -> Result<PgPool, PoolError> {
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    diesel::r2d2::Pool::builder()
        .max_size(size)
        .min_idle(Some(size))
        .test_on_check_out(false)
        .idle_timeout(None)
        .max_lifetime(None)
        .build(manager)
}

fn main() {
    DB_POOL
        .set(build_pool(&DB_URL, 10).expect(&format!("Error connecting to {}", &DB_URL)))
        .ok();
}

#[handler]
async fn show_article(req: &mut Request, res: &mut Response) -> Result<(), Error> {
    let id: i64 = req.param::<i64>("id").unwrap_or_default();
    let conn = connect()?;
    let article = articles::table.find(id).first::<Article>(&conn)?;
    res.render(Json(row));
    Ok(())
}
```

### [Sqlx](https://github.com/launchbadge/sqlx)

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
<Tab label="main.rs">
```rust file="<root>/codes/db-postgres-sqlx/src/main.rs"
```
</Tab>
<Tab label="Cargo.toml">
```toml file="<root>/codes/db-postgres-sqlx/Cargo.toml"
```
</Tab>
</Tabs>

### [rbatis](https://github.com/rbatis/rbatis)

<Tabs>
<Tab label="main.rs">
```rust file="<root>/codes/db-mysql-rbatis/src/main.rs"
```
</Tab>
<Tab label="Cargo.toml">
```toml file="<root>/codes/db-mysql-rbatis/Cargo.toml"
```
</Tab>
</Tabs>

## [SeaORM](https://www.sea-ql.org/SeaORM/)

SeaORM ist ein asynchrones, dynamisches ORM-System, das umfangreiche Unterstützung für relationale Datenbanken bietet, einschließlich Entitätsbeziehungen, einem Migrationssystem und einem umfassenden typsicheren Abfrage-Builder. Es eignet sich besonders für mittlere bis große Projekte, die ein vollwertiges ORM benötigen.

## [Tokio ORM (Toasty)](https://github.com/tokio-rs/toasty)

Toasty ist ein vom Tokio-Team entwickeltes ORM, das sich derzeit in aktiver Entwicklung befindet. Es konzentriert sich darauf, eine eng integrierte ORM-Lösung für das Tokio-Ökosystem bereitzustellen. Es könnte für Projekte geeignet sein, die auf Tokio setzen und offen für neue Technologien sind.

## [SurrealDB Rust SDK](https://surrealdb.com/docs/sdk/rust)

Das SurrealDB Rust SDK ermöglicht die Verbindung zu dieser multimodalen Datenbank und eignet sich daher für Anwendungen, die Graphdaten, Dokumentendaten und relationale Daten verarbeiten müssen. Es ist eine ausgezeichnete Wahl für Projekte, die flexible Datenmodelle erfordern.
{/* Auto generated, origin file hash:b866ce69ac7cb1788214d2e481e99fd0 */}