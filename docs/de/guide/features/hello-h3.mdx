# HTTP/3-Unterstützung

Salvo bietet Unterstützung für HTTP/3, die über das Feature `quinn` aktiviert werden kann. HTTP/3 basiert auf dem QUIC-Protokoll und bietet im Vergleich zu herkömmlichem HTTP/1.1 und HTTP/2 geringere Latenz und bessere Leistung, insbesondere in instabilen Netzwerkumgebungen.

## Aktivierung der HTTP/3-Unterstützung

Um HTTP/3-Unterstützung in Salvo zu aktivieren, müssen Sie das Feature `quinn` in Ihrer `Cargo.toml`-Datei aktivieren:

```toml
salvo = { workspace = true, features = ["quinn"] }
```

## Anwendungsfälle für HTTP/3

HTTP/3 ist besonders geeignet für folgende Szenarien:

- Anwendungen auf Mobilgeräten und in instabilen Netzwerkumgebungen
- Echtzeitanwendungen mit geringen Latenzanforderungen
- Szenarien mit parallelen Downloads zahlreicher kleiner Dateien
- Anwendungen, die Verbindungsmigration benötigen (z.B. nahtloses Wechseln von WLAN zu Mobilfunknetzen ohne Verbindungsunterbrechung)

## Beispielcode

Hier ist ein einfaches HTTP/3-Serverbeispiel, das sowohl HTTP/3 (QUIC) als auch HTTPS (TCP) unterstützt:

```rust
use salvo::conn::rustls::{Keycert, RustlsConfig};
use salvo::prelude::*;

// Handler-Funktion, die mit "Hello World" antwortet
#[handler]
async fn hello() -> &'static str {
    "Hello World"
}

#[tokio::main]
async fn main() {
    // Initialisierung des Logging-Systems
    tracing_subscriber::fmt().init();

    // TLS-Zertifikat und privaten Schlüssel aus eingebetteten PEM-Dateien laden
    let cert = include_bytes!("../certs/cert.pem").to_vec();
    let key = include_bytes!("../certs/key.pem").to_vec();

    // Router erstellen und Endpunkt hinzufügen
    let router = Router::new().get(hello);

    // TLS-Einstellungen mit Rustls konfigurieren
    let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

    // TLS-verschlüsselten TCP-Listener auf Port 8698 erstellen
    let listener = TcpListener::new(("0.0.0.0", 8698)).rustls(config.clone());

    // QUIC-Listener erstellen und mit TCP-Listener kombinieren
    let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 8698))
        .join(listener)
        .bind()
        .await;

    // Server starten, der sowohl HTTP/3 (QUIC) als auch HTTPS (TCP) unterstützt
    Server::new(acceptor).serve(router).await;
}
```

## Wichtige Code-Analyse

### TLS-Konfiguration

```rust
// TLS-Einstellungen mit Rustls konfigurieren
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));
```

Da HTTP/3 auf dem QUIC-Protokoll basiert, das TLS 1.3 für die Verschlüsselung benötigt, müssen TLS-Zertifikate und -Schlüssel konfiguriert werden. In Salvo verwenden wir `RustlsConfig` für die TLS-Konfiguration.

### Kombinieren von Listenern

```rust
// TLS-verschlüsselten TCP-Listener erstellen
let listener = TcpListener::new(("0.0.0.0", 8698)).rustls(config.clone());

// QUIC-Listener erstellen und mit TCP-Listener kombinieren
let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 8698))
    .join(listener)
    .bind()
    .await;
```

Dieser Code ist der Kern der HTTP/3-Verarbeitung in Salvo. Zuerst wird ein TLS-fähiger TCP-Listener (für HTTP/1.1 und HTTP/2) erstellt, dann ein QUIC-Listener (für HTTP/3). Die `join`-Methode kombiniert diese beiden Listener, sodass der Server Anfragen von verschiedenen Protokollen gleichzeitig verarbeiten kann.

## Ausführung des Beispiels

Um dieses Beispiel auszuführen, benötigen Sie gültige TLS-Zertifikate und private Schlüssel. In einer Entwicklungsumgebung können selbstsignierte Zertifikate verwendet werden. Den vollständigen Beispielcode finden Sie im [Salvo GitHub-Repository](https://github.com/salvo-rs/salvo/tree/main/examples/hello-h3).

Beachten Sie, dass viele Clients HTTP/3 noch nicht vollständig unterstützen, weshalb dieser Server sowohl HTTP/3 als auch HTTPS unterstützen muss.

## Wichtige Hinweise

1. HTTP/3 erfordert TLS 1.3-Unterstützung, daher müssen gültige Zertifikate und Schlüssel konfiguriert werden.
2. Clients müssen das HTTP/3-Protokoll unterstützen, um diese Funktion nutzen zu können; andernfalls greifen sie auf HTTP/1.1 oder HTTP/2 zurück.
3. In Produktionsumgebungen sollten Zertifikate einer vertrauenswürdigen Zertifizierungsstelle (CA) verwendet werden, anstatt selbstsignierter Zertifikate.
{/* Auto generated, origin file hash:f135699b9ae12daf6d88fc1e8c22a61e */}