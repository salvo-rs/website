# Освоение этого искусства

## Почему был создан этот фреймворк

Начинающим разработчиком я столкнулся с трудностями в освоении существующих фреймворков, таких как actix-web и Rocket. Когда я попытался переписать свой предыдущий веб-сервис на Go с использованием Rust, каждый фреймворк казался сложнее аналогов в Go. Учитывая и без того высокий порог входа в Rust, зачем усложнять веб-фреймворки ещё больше?

Когда Tokio представил фреймворк Axum, я обрадовался, думая, что наконец смогу прекратить поддержку собственного веб-фреймворка. Однако вскоре я понял, что хотя Axum выглядит простым, он требует сложных манипуляций с типами и обобщёнными определениями. Создание даже базового промежуточного слоя требовало глубоких знаний Rust и написания большого количества замысловатого шаблонного кода.

Поэтому я решил продолжить поддержку своего уникального веб-фреймворка — интуитивно понятного, многофункционального и дружелюбного к новичкам.

## Подходит ли вам Salvo?

Salvo прост, но при этом всеобъемлющ и мощен, возможно, являясь сильнейшим в экосистеме Rust. Несмотря на свои возможности, он остаётся лёгким в изучении и использовании, избавляя вас от мук "самокастрации".

- **Идеален для начинающих с Rust**: CRUD-операции повсеместны, и с Salvo такие задачи ощущаются так же просто, как и с фреймворками на других языках (например, Express, Koa, Gin, Flask). В некоторых аспектах Salvo даже более абстрактен и лаконичен.

- **Подходит для продакшена**: Если вы планируете использовать Rust в продакшене для создания надёжных высокоскоростных серверов, Salvo — отличный выбор. Хотя он ещё не достиг версии 1.0, его основные функции прошли годы итераций, обеспечивая стабильность и своевременное решение проблем.

- **Идеален для вас**, особенно если ваши волосы редеют и выпадают ежедневно.

## Достижение простоты

Hyper берёт на себя множество низкоуровневых реализаций, что делает его надёжной основой для общих нужд. Salvo следует этому подходу, предлагая мощную и гибкую систему маршрутизации вместе с необходимыми функциями, такими как Acme, OpenAPI и аутентификация JWT.

Salvo объединяет Обработчики и Промежуточные слои: Промежуточный слой *является* Обработчиком. Оба прикрепляются к Маршрутизатору через `hoop`. По сути, они обрабатывают `Запрос` и могут записывать данные в `Ответ`. Обработчик получает три параметра: `Запрос`, `Депо` (для временных данных во время обработки запроса) и `Ответ`.

Для удобства вы можете опускать ненужные параметры или игнорировать их порядок.

```rust
use salvo::prelude::*;

#[handler]
async fn hello_world(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {
    res.render("Hello world");
}
#[handler]
async fn hello_world(res: &mut Response) {
    res.render("Hello world");
}
```

API маршрутизации исключительно прост, но мощный. Для типичных случаев использования вам нужно сосредоточиться только на типе `Маршрутизатор`.

Кроме того, если структура реализует соответствующие трейты, Salvo может автоматически генерировать документацию OpenAPI, извлекать параметры, корректно обрабатывать ошибки и возвращать понятные сообщения. Это делает написание обработчиков таким же интуитивным, как написание обычных функций. Мы подробно рассмотрим эти функции позже. Вот пример:

```rust
#[endpoint(tags("message_logs"))]
pub async fn create_message_log_handler(
    input: JsonBody<CreateOrUpdateMessageLog>,
    depot: &mut Depot,
) -> APPResult<Json<MessageLog>> {
    let db = utils::get_db(depot)?;
    let log = create_message_log(&input, db).await?;
    Ok(Json(log))
}
```

В этом примере `JsonBody<CreateOrUpdateMessageLog>` автоматически преобразует JSON из тела запроса в тип `CreateOrUpdateMessageLog` (поддерживая несколько источников данных и вложенные типы). Макрос `#[endpoint]` генерирует документацию OpenAPI для этой конечной точки, упрощая извлечение параметров и обработку ошибок.

## Система маршрутизации

Я считаю, что система маршрутизации Salvo выделяется. Маршрутизаторы могут быть плоскими или древовидными, различаясь между *деревьями бизнес-логики* и *деревьями каталогов доступа*. Дерево бизнес-логики организует маршрутизаторы на основе бизнес-потребностей, которые могут не совпадать с деревом каталогов доступа.

Обычно маршруты пишутся так:

```rust
Router::new().path("articles").get(list_articles).post(create_article);
Router::new()
    .path("articles/{id}")
    .get(show_article)
    .patch(edit_article)
    .delete(delete_article);
```

Часто просмотр статей и их список не требуют входа пользователя, но создание, редактирование или удаление статей — требуют. Вложенная система маршрутизации Salvo элегантно справляется с этим. Мы можем сгруппировать публичные маршруты вместе:

```rust
Router::new()
    .path("articles")
    .get(list_articles)
    .push(Router::new().path("{id}").get(show_article));
```

Затем сгруппировать защищённые маршруты с промежуточным слоем для аутентификации:

```rust
Router::new()
    .path("articles")
    .hoop(auth_check)
    .post(create_article)
    .push(Router::new().path("{id}").patch(edit_article).delete(delete_article));
```

Даже если оба маршрутизатора имеют одинаковый `path("articles")`, их можно добавить к одному родительскому маршрутизатору, получив:

```rust
Router::new()
    .push(
        Router::new()
            .path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::new()
            .path("articles")
            .hoop(auth_check)
            .post(create_article)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

`{id}` соответствует сегменту пути. Обычно `id` статьи является числовым, поэтому мы можем ограничить соответствие с помощью регулярного выражения: `r"{id:/\d+/}"`.
{/* Auto generated, origin file hash:53ec9b9aab674c6d0bf9c162d2a13fc4 */}