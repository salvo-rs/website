# Cache

Middleware che fornisce funzionalità di memorizzazione nella cache.

Il middleware Cache può memorizzare nella cache lo `StatusCode`, gli `Headers` e il `Body` di una `Response`. Per i contenuti già memorizzati, il middleware Cache invierà direttamente il contenuto in cache dalla memoria al client durante le richieste successive.

Nota: Questo plugin non memorizza nella cache gli oggetti `Response` il cui `Body` è `ResBody::Stream`. Se applicato a una `Response` di questo tipo, Cache non elaborerà queste richieste e non si verificherà alcun errore.

## Caratteristiche Principali

- `CacheIssuer` fornisce un'astrazione per la generazione delle chiavi di cache. `RequestIssuer` è una delle sue implementazioni, che consente di definire quali parti dell'URL della richiesta e del `Method` della richiesta devono essere utilizzate per generare la chiave di cache. È possibile definire anche una propria logica di generazione delle chiavi di cache. La chiave di cache non deve necessariamente essere una stringa; qualsiasi tipo che soddisfi i vincoli `Hash + Eq + Send + Sync + 'static` può essere utilizzato come chiave.

- `CacheStore` fornisce operazioni per l'archiviazione e il recupero dei dati. `MokaStore` è un'implementazione di cache in memoria integrata basata su `moka`. È possibile definire anche una propria implementazione.

- `Cache` è una struct che implementa `Handler`. Contiene anche un campo interno `skipper`, che può essere utilizzato per specificare le richieste che devono saltare la cache. Per impostazione predefinita, utilizza `MethodSkipper` per saltare tutte le richieste tranne quelle con `Method::GET`.

  Codice di esempio dell'implementazione interna:

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Migrazione Rapida da Altri Framework

Se hai utilizzato meccanismi di cache in altri framework, le seguenti corrispondenze concettuali ti aiuteranno ad adattarti più rapidamente all'implementazione della cache di Salvo:

### Guida alla Migrazione da Framework Rust

- **Migrazione da Actix-web**: Plugin come `actix-web-cache` in Actix-web di solito devono essere introdotti separatamente, mentre la cache in Salvo fa parte della libreria core.

  ```rust
  // Esempio di cache in Actix-web
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Implementazione corrispondente in Salvo
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Guida alla Migrazione da Framework in Altri Linguaggi

- **Migrazione da Go/Gin**: Gin utilizza un pattern middleware, che Salvo adotta in modo simile:

  ```go
  // Esempio di cache in Gin
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Implementazione corrispondente in Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Migrazione da Spring Boot**: La cache dichiarativa di Spring Boot deve essere convertita nella configurazione esplicita del middleware di Salvo:

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Implementazione corrispondente in Salvo - applicazione della cache a livello di route
  let custom_issuer = YourCustomIssuer::new(); // Implementa l'interfaccia CacheIssuer
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Migrazione da Express.js**: Il middleware di cache di Express è concettualmente simile a quello di Salvo, ma la sintassi è diversa:

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Implementazione corrispondente in Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

Durante la migrazione da altri framework, presta attenzione a diversi concetti chiave della cache di Salvo:

1. **Generazione della Chiave di Cache** - Controllata tramite l'interfaccia `CacheIssuer`.
2. **Archiviazione della Cache** - Implementata tramite l'interfaccia `CacheStore`.
3. **Logica di Esclusione dalla Cache** - Personalizzabile tramite il meccanismo `skipper`.

Per impostazione predefinita, Salvo memorizza nella cache solo le richieste GET, in linea con il comportamento predefinito della maggior parte dei framework.

_**Codice di Esempio**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* Auto generated, origin file hash:6ae106316ebd0ee4b0ba1fabf6fe7a3f */}