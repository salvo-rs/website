---
title: Framework de sérialisation Rust
---

# Serde : Framework de sérialisation et désérialisation Rust

[Serde](https://docs.rs/serde/latest/serde/) est une bibliothèque fondamentale de l'écosystème Rust, offrant un framework de sérialisation et désérialisation à la fois performant et universel. Son nom provient de la contraction de "**Ser**ialization" et "**De**serialization".

## Caractéristiques principales

- **Universalité** : Prend en charge de nombreux formats de données tels que JSON, YAML, TOML, MessagePack, etc.
- **Abstraction sans coût** : Le code généré à la compilation est aussi efficace qu'un code écrit manuellement.
- **Flexibilité** : Permet de personnaliser les comportements de sérialisation et désérialisation.
- **Typage fort** : Utilise le système de types de Rust pour garantir l'intégrité des données.
- **Large adoption** : Devenue la bibliothèque standard de l'écosystème Rust pour les échanges de données.

## Fonctionnement

Le cœur de Serde repose sur son concept de représentation intermédiaire (Intermediate Representation), qui divise les processus de sérialisation et désérialisation en deux étapes :

1. **Sérialisation** : Convertit une structure de données Rust en une représentation intermédiaire universelle, puis dans le format cible.
2. **Désérialisation** : Convertit un format d'entrée en représentation intermédiaire universelle, puis en structure de données Rust.

Cette conception permet d'ajouter de nouveaux formats de données sans modifier les applications utilisant Serde.

## Utilisation de base

### Configuration des dépendances

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0" # ou une autre bibliothèque de format comme serde_yaml, toml, etc.
```

### Utilisation des macros dérivées

L'usage le plus courant consiste à utiliser les macros dérivées pour implémenter automatiquement les traits `Serialize` et `Deserialize` sur une structure :

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    // Convertit Point en chaîne JSON
    let serialized = serde_json::to_string(&point).unwrap();
    println!("Résultat sérialisé : {}", serialized); // Sortie : {"x":1,"y":2}

    // Reconstitue Point à partir de la chaîne JSON
    let deserialized: Point = serde_json::from_str(&serialized).unwrap();
    println!("Résultat désérialisé : {:?}", deserialized); // Sortie : Point { x: 1, y: 2 }
}
```

### Personnalisation via attributs

Serde propose de nombreux attributs pour personnaliser le comportement de sérialisation :

```rust
#[derive(Serialize, Deserialize, Debug)]
struct User {
    #[serde(rename = "user_id")]
    id: u64,
    
    #[serde(default)]
    name: String,
    
    #[serde(skip_serializing_if = "Option::is_none")]
    email: Option<String>,
    
    #[serde(skip)]
    temporary_data: usize,
}
```

### Formats de données pris en charge

Serde s'intègre avec de nombreux formats de données, chacun ayant son propre crate :

- **serde_json** : Format JSON
- **serde_yaml** : Format YAML
- **toml** : Format TOML
- **bincode** : Format binaire
- **postcard** : Format binaire optimisé pour l'espace
- **rmp/rmp-serde** : Format MessagePack
- **ciborium** : Format CBOR
- ... et bien d'autres.

## Utilisation avancée

### Implémentation manuelle des traits

Pour des besoins spécifiques, il est possible d'implémenter manuellement les traits `Serialize` et `Deserialize` :

```rust
use serde::{Serialize, Serializer, Deserialize, Deserializer};

struct MyType {
    // champs...
}

impl Serialize for MyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Logique de sérialisation personnalisée
    }
}

impl<'de> Deserialize<'de> for MyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Logique de désérialisation personnalisée
    }
}
```

### Mapping de types

Il est possible de créer des correspondances entre différentes représentations de données :

```rust
#[derive(Serialize, Deserialize)]
#[serde(remote = "chrono::DateTime<chrono::Utc>")]
struct DateTimeRef {
    #[serde(with = "chrono::serde::ts_seconds")]
    pub inner: chrono::DateTime<chrono::Utc>,
}
```

## Apprentissage et ressources

Serde est une bibliothèque riche en fonctionnalités ; ce document n'en couvre que les bases. Pour exploiter pleinement Serde, il est recommandé de :

1. Consulter la [documentation officielle de Serde](https://serde.rs/) pour découvrir les API détaillées et des exemples.
2. Explorer le [dépôt GitHub](https://github.com/serde-rs/serde) pour accéder au code source et aux dernières mises à jour.

## Conclusion

En tant que bibliothèque fondamentale de l'écosystème Rust, Serde fournit des outils puissants et flexibles pour les échanges de données. En maîtrisant Serde, vous pouvez facilement répondre à divers besoins d'échange de données dans différents formats, rendant vos applications plus robustes et interopérables.
{/* 本行由工具自动生成,原文哈希值:02cf744a3fbae09d654887c13e131157 */}