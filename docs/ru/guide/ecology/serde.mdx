---
title: Фреймворк сериализации Rust
---

# Serde: Фреймворк сериализации и десериализации Rust

[Serde](https://docs.rs/serde/latest/serde/) — это основная библиотека в экосистеме Rust, предоставляющая эффективный и универсальный фреймворк для сериализации и десериализации. Её название образовано от слов «**Ser**ialization» (сериализация) и «**De**serialization» (десериализация).

## Ключевые особенности

- **Универсальность**: Поддерживает множество форматов данных, таких как JSON, YAML, TOML, MessagePack и другие.
- **Абстракция с нулевой стоимостью**: Код, генерируемый во время компиляции, столь же эффективен, как и написанный вручную.
- **Гибкость**: Позволяет настраивать поведение сериализации и десериализации.
- **Строгая типизация**: Использует систему типов Rust для обеспечения целостности данных.
- **Широкое распространение**: Является стандартной библиотекой для обмена данными в экосистеме Rust.

## Принцип работы

Основой Serde является дизайн промежуточного представления (Intermediate Representation, IR), который разделяет процессы сериализации и десериализации на два этапа:

1. **Сериализация**: Преобразует структуры данных Rust в универсальное промежуточное представление, а затем в целевой формат.
2. **Десериализация**: Преобразует входные форматы в универсальное промежуточное представление, а затем в структуры данных Rust.

Такая конструкция позволяет добавлять новые форматы данных без изменения приложений, использующих Serde.

## Базовое использование

### Настройка зависимостей

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0" # Или другие библиотеки форматов, например serde_yaml, toml и т.д.
```

### Использование производных макросов

Наиболее распространённый способ использования — применение производных макросов для автоматической реализации трейтов сериализации и десериализации для структур:

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    // Преобразование Point в строку JSON
    let serialized = serde_json::to_string(&point).unwrap();
    println!("Результат сериализации: {}", serialized); // Вывод: {"x":1,"y":2}

    // Преобразование строки JSON обратно в Point
    let deserialized: Point = serde_json::from_str(&serialized).unwrap();
    println!("Результат десериализации: {:?}", deserialized); // Вывод: Point { x: 1, y: 2 }
}
```

### Настройка с помощью атрибутов

Serde предоставляет богатый набор атрибутов для настройки поведения сериализации:

```rust
#[derive(Serialize, Deserialize, Debug)]
struct User {
    #[serde(rename = "user_id")]
    id: u64,
    
    #[serde(default)]
    name: String,
    
    #[serde(skip_serializing_if = "Option::is_none")]
    email: Option<String>,
    
    #[serde(skip)]
    temporary_data: usize,
}
```

### Поддерживаемые форматы данных

Serde интегрируется с различными форматами данных, каждый из которых представлен своим крейтом:

- **serde_json**: Формат JSON
- **serde_yaml**: Формат YAML
- **toml**: Формат TOML
- **bincode**: Бинарный формат
- **postcard**: Оптимизированный по объёму бинарный формат
- **rmp/rmp-serde**: Формат MessagePack
- **ciborium**: Формат CBOR
- ...и другие форматы

## Продвинутое использование

### Ручная реализация трейтов

Для особых требований можно вручную реализовать трейты `Serialize` и `Deserialize`:

```rust
use serde::{Serialize, Serializer, Deserialize, Deserializer};

struct MyType {
    // Поля...
}

impl Serialize for MyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Пользовательская логика сериализации
    }
}

impl<'de> Deserialize<'de> for MyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Пользовательская логика десериализации
    }
}
```

### Преобразование типов

Можно создавать отображения между различными представлениями данных:

```rust
#[derive(Serialize, Deserialize)]
#[serde(remote = "chrono::DateTime<chrono::Utc>")]
struct DateTimeRef {
    #[serde(with = "chrono::serde::ts_seconds")]
    pub inner: chrono::DateTime<chrono::Utc>,
}
```

## Обучение и ресурсы

Serde — это многофункциональная библиотека, и данная статья охватывает лишь основы. Чтобы полностью раскрыть потенциал Serde, рекомендуется:

1. Посетить [официальную документацию Serde](https://serde.rs/) для получения подробной информации об API и примеров.
2. Ознакомиться с [репозиторием на GitHub](https://github.com/serde-rs/serde) для доступа к исходному коду и последним обновлениям.

## Заключение

Как фундаментальная библиотека в экосистеме Rust, Serde предоставляет мощные и гибкие инструменты для обмена данными. Освоив Serde, вы сможете легко справляться с различными требованиями к обмену данными, делая ваши приложения более надёжными и совместимыми.
{/* Auto generated, origin file hash:88d6bf5835e9a0a222ddde6f611b4ef0 */}