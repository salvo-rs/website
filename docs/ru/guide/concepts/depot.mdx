# Depot

import { Tab, Tabs } from '@rspress/core/theme';

[Depot](https://docs.rs/salvo_core/latest/salvo_core/struct.Depot.html) — это структура для хранения временных данных, связанных с обработкой одного запроса. Промежуточные обработчики (middleware) могут помещать в Depot данные, полученные в ходе своей работы, для использования последующими обработчиками.

При получении запроса от клиента (например, браузера) сервер создаёт экземпляр `Depot`. Этот экземпляр существует на протяжении всей обработки запроса всеми промежуточными обработчиками и конечным `Handler`, после чего уничтожается.

Например, в middleware аутентификации можно сохранить информацию о `current_user`, а затем в последующих middleware или `Handler` прочитать данные о текущем пользователе.

## Быстрое понимание

`Depot` используется для хранения и совместного использования данных в процессе обработки запроса. Он реализует типобезопасный контейнер данных и поддерживает две основные модели использования:

1.  **Хранилище ключ-значение**: доступ к значениям по строковым ключам через методы `insert`/`get`.
2.  **Внедрение по типу**: доступ к значениям на основе их типа через методы `inject`/`obtain`.

Как показано в примерах, `Depot` особенно полезен для передачи данных между middleware и обработчиками запросов. Middleware может установить значения в `Depot` (например, информацию о пользователе, статус аутентификации), а последующие обработчики могут получить эти значения без необходимости повторных вычислений или запросов. Дизайн `Depot` обеспечивает согласованность и доступность данных на протяжении всей цепочки обработки запроса, что делает его ключевым инструментом для построения сложных веб-приложений.

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/use-depot/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/use-depot/Cargo.toml"
  ```
  </Tab>
</Tabs>

## Установка и получение данных через `insert` и `get`

Как показано выше, можно вставить пару `key` и `value` в `Depot` с помощью `insert`. Для значений этого типа можно напрямую извлечь их с помощью `get`.

```rust
depot.insert("a", "b");
assert_eq!(depot.get::<&str>("a").copied().unwrap(), "b")
```

Если ключ не существует, или ключ существует, но тип значения не соответствует ожидаемому, возвращается `None`.

## Установка и получение данных через `inject` и `obtain`

Иногда существуют данные, для которых не важен конкретный ключ, и для данного типа существует только один экземпляр. В таких случаях можно использовать `inject` для вставки данных и `obtain` для их извлечения. Эти методы не требуют указания ключа.

```rust
depot.inject(Config::new());
depot.obtain::<Config>();
```

# Обзор методов структуры Depot

| Категория | Метод | Описание |
|------|------|------|
| **Создание/Ёмкость** | `new()` | Создаёт пустой Depot |
| | `with_capacity(capacity)` | Создаёт Depot с указанной начальной ёмкостью |
| | `capacity()` | Возвращает текущую ёмкость |
| | `inner()` | Возвращает ссылку на внутренний HashMap |
| **Внедрение/Получение по типу** | `inject<V>(value)` | Внедряет значение по его типу |
| | `obtain<T>()` | Получает ссылку на внедрённое значение по типу |
| | `obtain_mut<T>()` | Получает изменяемую ссылку на внедрённое значение по типу |
| | `contains<T>()` | Проверяет, содержится ли значение данного типа |
| | `scrape<T>()` | Извлекает и удаляет внедрённое значение по типу |
| **Операции с ключами** | `insert(key, value)` | Вставляет пару ключ-значение |
| | `get<V>(key)` | Получает ссылку на значение по ключу |
| | `get_mut<V>(key)` | Получает изменяемую ссылку на значение по ключу |
| | `contains_key(key)` | Проверяет, содержится ли указанный ключ |
| | `remove<V>(key)` | Удаляет пару ключ-значение и возвращает значение |
| | `delete(key)` | Удаляет пару ключ-значение |
{/* Auto generated, origin file hash:11bf72b48a504b8ce6ae390caf56080c */}