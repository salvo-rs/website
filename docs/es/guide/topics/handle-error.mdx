# Manejo de Errores

## Métodos Comunes de Manejo de Errores en Aplicaciones Rust

El manejo de errores en Rust difiere de lenguajes como Java, ya que no cuenta con estructuras como `try...catch`. La práctica habitual es definir un tipo de error global a nivel de aplicación:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("io: `{0}`")]
    Io(#[from] io::Error),
    #[error("utf8: `{0}`")]
    FromUtf8(#[from] FromUtf8Error),
    #[error("diesel: `{0}`")]
    Diesel(#[from] diesel::result::Error),
    ...
}

pub type AppResult<T> = Result<T, AppError>;
```

Aquí se utiliza la biblioteca `thiserror`, que permite definir fácilmente tipos de error personalizados, simplificando el código. Para facilitar la escritura, también se define un `AppResult`.

### thiserror vs anyhow

En el ecosistema de manejo de errores de Rust, dos bibliotecas comúnmente utilizadas son `thiserror` y `anyhow`:

- **thiserror**: Ideal para desarrolladores de bibliotecas, ya que permite definir tipos de error claros. Utiliza macros derivadas para ayudar a implementar el trait `std::error::Error` en tipos de error personalizados, permitiendo definir cómo se representan los errores. Es la mejor opción al construir una biblioteca o cuando se necesita proporcionar tipos de error claros a los usuarios.

- **anyhow**: Dirigida a desarrolladores de aplicaciones, proporciona un tipo de error genérico `anyhow::Error` que puede contener cualquier error que implemente el trait `std::error::Error`. Se centra más en la propagación de errores que en su definición, siendo especialmente adecuada para código a nivel de aplicación. Permite convertir rápidamente diversos errores en `anyhow::Error`, reduciendo la necesidad de escribir código repetitivo.

En algunos casos, es posible utilizar ambas bibliotecas simultáneamente: `thiserror` para definir tipos de error en bibliotecas y `anyhow` para manejar y propagar esos errores en aplicaciones.

## Manejo de Errores en Handlers

En Salvo, los `Handler` también suelen encontrar diversos errores, como errores de conexión a bases de datos, acceso a archivos, conexiones de red, etc. Para este tipo de errores, se puede aplicar el enfoque de manejo de errores mencionado anteriormente:

```rust
#[handler]
async fn home()-> AppResult<()> {

}
```

Aquí, `home` devuelve directamente un `AppResult<()>`. Pero, ¿cómo se debe mostrar este error? Necesitamos implementar `Writer` para el tipo de error personalizado `AppResult`, donde podemos decidir cómo mostrar el error:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        res.render(Text::Plain("¡Soy un error, jajaja!"));
    }
}
```

Los `Handler` en Salvo pueden devolver `Result`, siempre que tanto el tipo `Ok` como `Err` en `Result` implementen el trait `Writer`.

### Manejo de Errores con anyhow

Dado que anyhow es ampliamente utilizado, Salvo ofrece soporte integrado para `anyhow::Error`. Al habilitar la funcionalidad `anyhow`, `anyhow::Error` implementa el trait `Writer` y se mapea a `InternalServerError`:

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Para utilizar la funcionalidad anyhow, es necesario habilitar el feature `anyhow` de Salvo en Cargo.toml:

```toml
[dependencies]
salvo = { version = "*", features = ["anyhow"] }
anyhow = "1.0"
```

De esta manera, sus funciones de manejo pueden devolver directamente `anyhow::Result<T>`:

```rust
#[handler]
async fn home() -> anyhow::Result<impl Writer> {
    let data = fetch_data().context("Error al obtener datos")?;
    Ok(Text::Plain(data))
}
```

Los errores a menudo contienen información sensible que, por lo general, no se desea mostrar a usuarios comunes, ya que sería inseguro y carecería de privacidad. Sin embargo, si es desarrollador o administrador del sitio, su perspectiva podría ser diferente: quizás desee que el error se muestre completamente desnudo, revelando la información de error más precisa.

Como se puede observar, en el método `write` tenemos acceso a referencias de `Request` y `Depot`, lo que permite implementar fácilmente la funcionalidad descrita:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let user = depot.obtain::<User>();
        if user.is_admin {
            res.render(Text::Plain(e.to_string()));
        } else {
            res.render(Text::Plain("¡Soy un error, jajaja!"));
        }
    }
}
```

## Visualización de Páginas de Error

Las páginas de error integradas en Salvo satisfacen la mayoría de las necesidades, ya que pueden mostrar páginas en Html, Json o Xml según el tipo de datos de la solicitud. Sin embargo, en ciertos casos, aún puede ser deseable personalizar la visualización de páginas de error.

Esto se puede lograr implementando un `Catcher` personalizado. Para una explicación detallada, consulte la sección sobre [`Catcher`](../concepts/catcher.html).
{/* Auto generated, origin file hash:ccc3ad5dca846f6b6415dbe84e0c5166 */}