# WebTransport

WebTransport es un protocolo de transporte de red basado en HTTP/3 que proporciona capacidades de comunicación bidireccional entre clientes y servidores, garantizando baja latencia, alto rendimiento y seguridad.

## Casos de Uso

WebTransport es especialmente adecuado para los siguientes escenarios:

- **Aplicaciones en Tiempo Real**: Juegos en línea, herramientas de colaboración en tiempo real, videoconferencias y otras aplicaciones que requieren comunicación de baja latencia.
- **Transferencia de Archivos Grandes**: Admite transmisión de datos de alto rendimiento, ideal para streaming de medios y carga/descarga de archivos grandes.
- **Comunicación Multiplexada**: Permite establecer múltiples flujos de datos bidireccionales y unidireccionales simultáneamente.
- **Comunicación por Datagramas**: Admite comunicación por datagramas sin garantía de orden o fiabilidad, adecuada para escenarios con requisitos de tiempo real extremadamente altos.

En comparación con WebSocket, WebTransport ofrece menor latencia y patrones de comunicación más flexibles, especialmente con mejor rendimiento en entornos de red inestables.

## Implementación en Salvo

El framework Salvo proporciona soporte integrado para WebTransport, permitiendo a los desarrolladores construir fácilmente aplicaciones basadas en WebTransport. Las características clave incluyen:

- Soporte para establecer sesiones WebTransport
- Soporte para comunicación de flujos bidireccionales
- Soporte para comunicación de flujos unidireccionales
- Soporte para transmisión de datagramas
- Flujos de comunicación iniciados por el servidor

### Ejemplo Sencillo

A continuación se muestra un ejemplo simplificado de implementación de un servidor WebTransport usando Salvo:

```rust
#[handler]
async fn connect(req: &mut Request) -> Result<(), salvo::Error> {
    let session = req.web_transport_mut().await.unwrap();
    
    // Manejar datagramas
    if let Ok(Some((_, datagram))) = session.accept_datagram().await {
        // Procesar datagrama recibido
        let mut resp = BytesMut::from(&b"Response: "[..]);
        resp.put(datagram);
        session.send_datagram(resp.freeze())?;
    }
    
    // Manejar flujos bidireccionales
    if let Ok(Some(webtransport::server::AcceptedBi::BidiStream(_, stream))) = session.accept_bi().await {
        let (send, recv) = salvo::proto::quic::BidiStream::split(stream);
        // Procesar datos del flujo bidireccional
    }
    
    Ok(())
}
```

### Configuración e Inicio

Iniciar una aplicación Salvo con soporte WebTransport requiere configurar certificados TLS y un listener QUIC:

```rust
let cert = include_bytes!("../certs/cert.pem").to_vec();
let key = include_bytes!("../certs/key.pem").to_vec();

// Configurar enrutamiento
let router = Router::new().push(Router::with_path("counter").goal(connect));

// Configurar TLS
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

// Configurar listeners
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());
let acceptor = QuinnListener::new(config, ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;

// Iniciar servidor
Server::new(acceptor).serve(router).await;
```

## Ejemplo Completo

Para aprender más sobre el uso de WebTransport en Salvo, consulta el ejemplo completo en GitHub:
[https://github.com/salvo-rs/salvo/blob/main/examples/webtransport](https://github.com/salvo-rs/salvo/blob/main/examples/webtransport)

Este ejemplo incluye implementaciones completas tanto para servidor como cliente, demostrando cómo manejar varios tipos de comunicación WebTransport.
{/* Auto generated, origin file hash:d98d4da0351033ac716bd9facbe3fa45 */}