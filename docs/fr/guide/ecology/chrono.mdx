---
title: Bibliothèque de Dates et Heures en Rust
---

# Chrono : Bibliothèque de Dates et Heures en Rust

[Chrono](https://docs.rs/chrono/latest/chrono/) vise à fournir toutes les fonctionnalités nécessaires pour effectuer des opérations correctes sur les dates et heures dans le calendrier grégorien proléptique :

- Le type `DateTime` est conscient du fuseau horaire par défaut, avec des types distincts non liés aux fuseaux horaires.
- Les opérations pouvant produire une date ou heure invalide ou ambiguë renvoient `Option` ou `MappedLocalTime`.
- Analyse et formatage configurables avec une syntaxe de formatage de dates et heures inspirée de strftime.
- Le fuseau horaire `Local` fonctionne avec le fuseau horaire local actuel du système d'exploitation.
- Les types et opérations sont implémentés pour être raisonnablement efficaces.
- Pour éviter d'augmenter la taille du binaire, Chrono n'inclut pas de données de fuseaux horaires par défaut. Utilisez les crates compagnons `Chrono-TZ` ou `tzfile` pour une prise en charge complète des fuseaux horaires.

## Fonctionnalités

[Chrono](https://docs.rs/chrono/latest/chrono/) prend en charge divers environnements d'exécution et systèmes d'exploitation, avec plusieurs fonctionnalités qui peuvent être activées ou désactivées.

### Fonctionnalités par défaut :

- `alloc` : Active les fonctionnalités dépendant de l'allocation (principalement le formatage de chaînes).
- `std` : Active les fonctionnalités dépendant de la bibliothèque standard. Il s'agit d'un sur-ensemble de `alloc`, ajoutant l'interopérabilité avec les types et traits de la bibliothèque standard.
- `clock` : Active la lecture du fuseau horaire local (`Local`). C'est un sur-ensemble de `now`.
- `now` : Active la lecture de l'heure système (`now`).
- `wasmbind` : Fournit une interface vers l'API JS Date pour la cible wasm32.

### Fonctionnalités optionnelles :

- `serde` : Active la sérialisation/désérialisation via serde.
- `rkyv` : Obsolète, utilisez les fonctionnalités `rkyv-*`.
- `rkyv-16`, `rkyv-32`, `rkyv-64` : Active la sérialisation/désérialisation via rkyv, utilisant respectivement des entiers 16 bits, 32 bits ou 64 bits.
- `rkyv-validation` : Active la prise en charge de la validation rkyv avec bytecheck.
- `arbitrary` : Construit des instances arbitraires de types avec la crate Arbitrary.
- `unstable-locales` : Active la localisation. Cela ajoute diverses méthodes avec le suffixe `_localized`.

## Aperçu

### Différence de Temps / Durée

Chrono fournit le type `TimeDelta` pour représenter l'amplitude d'un intervalle de temps. Il s'agit d'une durée "exacte" représentée en secondes et nanosecondes, et ne représente pas les composants "nominaux" tels que les jours ou les mois.

Le type `TimeDelta` s'appelait auparavant `Duration` (toujours disponible comme alias de type). Une différence notable avec le `core::time::Duration` similaire est qu'il s'agit d'une valeur signée plutôt que non signée.

### Date et Heure

Chrono fournit le type `DateTime` pour représenter une date et une heure dans un fuseau horaire.

`DateTime` est conscient du fuseau horaire et doit être construit à partir d'un objet `TimeZone`, qui définit comment la date locale est convertie vers et depuis UTC. Il existe trois implémentations connues de `TimeZone` :

- `Utc` spécifie le fuseau horaire UTC. Il est le plus efficace.
- `Local` spécifie le fuseau horaire local du système.
- `FixedOffset` spécifie un fuseau horaire à décalage fixe arbitraire, tel que UTC+09:00 ou UTC-10:30.

Les valeurs `DateTime` avec différents types de `TimeZone` sont distinctes et ne peuvent pas être mélangées, mais peuvent être converties les unes dans les autres en utilisant la méthode `DateTime::with_timezone`.

Vous pouvez obtenir la date et l'heure actuelles dans le fuseau horaire UTC (`Utc::now()`) ou dans le fuseau horaire local (`Local::now()`).

```rust
use chrono::prelude::*;

let utc: DateTime<Utc> = Utc::now(); // ex. `2014-11-28T12:45:59.324310806Z`
let local: DateTime<Local> = Local::now(); // ex. `2014-11-28T21:45:59.324310806+09:00`
```

De plus, vous pouvez créer vos propres dates et heures :

```rust
use chrono::offset::MappedLocalTime;
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap(); // `2014-07-08T09:10:11Z`
```

### Formatage et Analyse

Le formatage se fait via la méthode `format`, dont le format est équivalent au format strftime familier.

La méthode `to_string` par défaut et le spécificateur `{:?}` donnent également une représentation raisonnable. Chrono fournit également les méthodes `to_rfc2822` et `to_rfc3339` pour les formats courants.

Chrono fournit désormais également le formatage de dates dans presque toutes les langues sans bibliothèques C supplémentaires. Cette fonctionnalité est disponible sous la fonctionnalité `unstable-locales` :

```rust
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 11, 28, 12, 0, 9).unwrap();
assert_eq!(dt.format("%Y-%m-%d %H:%M:%S").to_string(), "2014-11-28 12:00:09");
assert_eq!(dt.format_localized("%A %e %B %Y, %T", Locale::fr_BE).to_string(), 
           "vendredi 28 novembre 2014, 12:00:09");
```

L'analyse peut se faire de deux manières :

1. Le trait standard `FromStr` (et la méthode `parse` sur les chaînes) peut être utilisé pour analyser les valeurs `DateTime<FixedOffset>`, `DateTime<Utc>` et `DateTime<Local>`.
2. `DateTime::parse_from_str` analyse une date et une heure avec un décalage et renvoie `DateTime<FixedOffset>`.

```rust
use chrono::prelude::*;

let dt = "2014-11-28T12:00:09Z".parse::<DateTime<Utc>>().unwrap();
let fixed_dt = DateTime::parse_from_str("2014-11-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z").unwrap();
```

### Conversion vers/depuis les Horodatages d'Époque

Construisez `DateTime<Utc>` à partir d'un horodatage UNIX en utilisant `DateTime::from_timestamp(seconds, nanoseconds)`.

Obtenez l'horodatage (en secondes) d'un `DateTime` en utilisant `DateTime.timestamp`. De plus, vous pouvez obtenir le nombre supplémentaire de nanosecondes avec `DateTime.timestamp_subsec_nanos`.

```rust
use chrono::{DateTime, Utc};

// Construire une datetime à partir de l'époque :
let dt: DateTime<Utc> = DateTime::from_timestamp(1_500_000_000, 0).unwrap();
assert_eq!(dt.to_rfc2822(), "Fri, 14 Jul 2017 02:40:00 +0000");

// Obtenir la valeur d'époque depuis une datetime :
let dt = DateTime::parse_from_rfc2822("Fri, 14 Jul 2017 02:40:00 +0000").unwrap();
assert_eq!(dt.timestamp(), 1_500_000_000);
```

## Limitations

- Seul le calendrier grégorien proléptique est pris en charge (c'est-à-dire étendu pour prendre en charge les dates avant l'ère).
- Les types de date sont limités à environ +/- 262 000 ans à partir de l'ère commune.
- Les types de temps sont limités à une précision à la nanoseconde.
- Les secondes intercalaires peuvent être représentées, mais Chrono ne les prend pas entièrement en charge.
{/* Auto generated, origin file hash:10bcf1127b3b63767462c43c36ecf9da */}