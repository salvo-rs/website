# キャッシュ

キャッシュ機能を提供するミドルウェア。

Cacheミドルウェアは、`Response`の`StatusCode`、`Headers`、`Body`に対してキャッシュ機能を提供します。すでにキャッシュされた内容については、次回リクエストを処理する際に、Cacheミドルウェアがメモリ内にキャッシュされた内容を直接クライアントに送信します。

注意：このプラグインは、`Body`が`ResBody::Stream`である`Response`をキャッシュしません。このタイプの`Response`に適用された場合、Cacheはこれらのリクエストを処理せず、エラーも発生しません。

## 主な機能

- `CacheIssuer`は、割り当てられたキャッシュキーの抽象化を提供します。`RequestIssuer`はその実装の一つで、リクエストのURLのどの部分とリクエストの`Method`に基づいてキャッシュキーを生成するかを定義できます。独自のキャッシュキー生成ロジックを定義することも可能です。キャッシュキーは文字列型である必要はなく、`Hash + Eq + Send + Sync + 'static`制約を満たす任意の型をキーとして使用できます。

- `CacheStore`は、データの保存と取得操作を提供します。`MokaStore`は、`moka`をベースにした組み込みのメモリキャッシュ実装です。独自の実装方法を定義することもできます。

- `Cache`は`Handler`を実装した構造体で、内部には`skipper`フィールドもあり、キャッシュが不要なリクエストをスキップするように指定できます。デフォルトでは、`MethodSkipper`を使用して`Method::GET`以外のすべてのリクエストをスキップします。

  内部実装のサンプルコード：

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## 他のフレームワークからの迅速な移行

以前に他のフレームワークのキャッシュメカニズムを使用したことがある場合、以下の概念マッピングがSalvoのキャッシュ実装への適応を助けます：

### Rustフレームワーク移行ガイド

- **Actix-webからの移行**: Actix-webの`actix-web-cache`などのプラグインは通常個別に導入する必要がありますが、Salvoのキャッシュはコアライブラリの一部です。

  ```rust
  // Actix-web キャッシュ例
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Salvo 対応実装
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### 他の言語フレームワーク移行ガイド

- **Go/Ginからの移行**: Ginはミドルウェアパターンを使用しており、Salvoも同様のアプローチを採用しています：

  ```go
  // Gin キャッシュ例
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Salvo 対応実装
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Spring Bootからの移行**: Spring Bootの宣言型キャッシュは、Salvoの明示的なミドルウェア設定に変換する必要があります：

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Salvo 対応実装 - ルートレベルでキャッシュを適用
  let custom_issuer = YourCustomIssuer::new(); // CacheIssuerインターフェースを実装
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Express.jsからの移行**: Expressのキャッシュミドルウェアは概念的にSalvoと類似していますが、構文が異なります：

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Salvo 対応実装
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

他のフレームワークから移行する際には、Salvoキャッシュのいくつかの重要な概念に注意する必要があります：

1. **キャッシュキー生成** - `CacheIssuer`インターフェースで制御
2. **キャッシュストレージ** - `CacheStore`インターフェースで実装
3. **キャッシュスキップロジック** - `skipper`メカニズムでカスタマイズ

デフォルトでは、SalvoはGETリクエストのみをキャッシュします。これは多くのフレームワークのデフォルト動作と一致しています。

_**サンプルコード**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* 本行由工具自动生成,原文哈希值:df2bc60555363c109d61ba033738ce41 */}