---
title: Fonctionnalité Craft
---

# Fonctionnalité Craft

Craft permet aux développeurs de générer automatiquement des fonctions de traitement et des points de terminaison via des annotations simples, tout en s'intégrant parfaitement à la génération de documentation OpenAPI.

## Cas d'utilisation

La fonctionnalité Craft est particulièrement utile dans les scénarios suivants :

- Lorsque vous avez besoin de créer rapidement des fonctions de traitement de routage à partir de méthodes de structure
- Lorsque vous souhaitez réduire le code passe-partout lié à l'extraction manuelle des paramètres et à la gestion des erreurs
- Lorsque vous avez besoin de générer automatiquement une documentation OpenAPI pour votre API
- Lorsque vous souhaitez découpler la logique métier du framework web

## Utilisation de base

Pour utiliser la fonctionnalité Craft, importez les modules suivants :

```rust
use salvo::oapi::extract::*;
use salvo::prelude::*;
```

### Créer une structure de service

Utilisez la macro `#[craft]` pour annoter votre bloc `impl`, ce qui permet de convertir les méthodes de structure en fonctions de traitement ou en points de terminaison.

```rust
#[derive(Clone)]
pub struct Opts {
    state: i64,
}

#[craft]
impl Opts {
    // Constructeur
    fn new(state: i64) -> Self {
        Self { state }
    }
    
    // Plus de méthodes...
}
```

### Créer une fonction de traitement

Utilisez `#[craft(handler)]` pour convertir une méthode en fonction de traitement :

```rust
#[craft(handler)]
fn add1(&self, left: QueryParam<i64>, right: QueryParam<i64>) -> String {
    (self.state + *left + *right).to_string()
}
```

Cette méthode deviendra une fonction de traitement qui :
- Extrait automatiquement les valeurs `left` et `right` des paramètres de requête
- Accède à l'état `state` dans la structure
- Renvoie le résultat du calcul sous forme de réponse chaîne de caractères

### Créer un point de terminaison

Utilisez `#[craft(endpoint)]` pour convertir une méthode en point de terminaison :

```rust
#[craft(endpoint)]
pub(crate) fn add2(
    self: ::std::sync::Arc<Self>,
    left: QueryParam<i64>,
    right: QueryParam<i64>,
) -> String {
    (self.state + *left + *right).to_string()
}
```

Les points de terminaison peuvent utiliser `Arc` pour partager l'état, ce qui est particulièrement utile lors du traitement de requêtes concurrentes.

### Points de terminaison statiques

Vous pouvez également créer des points de terminaison statiques qui ne dépendent pas de l'état d'une instance :

```rust
#[craft(endpoint(responses((status_code = 400, description = "Wrong request parameters."))))]
pub fn add3(left: QueryParam<i64>, right: QueryParam<i64>) -> String {
    (*left + *right).to_string()
}
```

Dans cet exemple, une description personnalisée de la réponse d'erreur est ajoutée, qui sera reflétée dans la documentation OpenAPI générée.

## Extracteurs de paramètres

Le module `oapi::extract` de Salvo fournit plusieurs extracteurs de paramètres, les plus courants étant :

- `QueryParam<T>` : Extrait les paramètres de la chaîne de requête
- `PathParam<T>` : Extrait les paramètres du chemin de l'URL
- `FormData<T>` : Extrait les paramètres des données de formulaire
- `JsonBody<T>` : Extrait les paramètres du corps de la requête JSON

Ces extracteurs effectuent automatiquement l'analyse et la conversion de type des paramètres, simplifiant considérablement l'écriture des fonctions de traitement.

## Intégration avec OpenAPI

La fonctionnalité Craft peut générer automatiquement une documentation API conforme aux spécifications OpenAPI. Dans l'exemple :

```rust
let router = Router::new()
    .push(Router::with_path("add1").get(opts.add1()))
    .push(Router::with_path("add2").get(opts.add2()))
    .push(Router::with_path("add3").get(Opts::add3()));

// Générer la documentation OpenAPI
let doc = OpenApi::new("Example API", "0.0.1").merge_router(&router);

// Ajouter les routes de documentation OpenAPI et Swagger UI
let router = router
    .push(doc.into_router("/api-doc/openapi.json"))
    .push(SwaggerUi::new("/api-doc/openapi.json").into_router("swagger-ui"));
```

Après cette configuration, la documentation API sera disponible au point de terminaison `/api-doc/openapi.json`, et Swagger UI sera accessible via le chemin `/swagger-ui`.

## Exemple complet

Voici un exemple complet montrant comment utiliser la fonctionnalité Craft pour créer trois types de points de terminaison différents :

```rust
use salvo::oapi::extract::*;
use salvo::prelude::*;
use std::sync::Arc;

#[derive(Clone)]
pub struct Opts {
    state: i64,
}

#[craft]
impl Opts {
    fn new(state: i64) -> Self {
        Self { state }
    }

    #[craft(handler)]
    fn add1(&self, left: QueryParam<i64>, right: QueryParam<i64>) -> String {
        (self.state + *left + *right).to_string()
    }

    #[craft(endpoint)]
    pub(crate) fn add2(
        self: ::std::sync::Arc<Self>,
        left: QueryParam<i64>,
        right: QueryParam<i64>,
    ) -> String {
        (self.state + *left + *right).to_string()
    }

    #[craft(endpoint(responses((status_code = 400, description = "Wrong request parameters."))))]
    pub fn add3(left: QueryParam<i64>, right: QueryParam<i64>) -> String {
        (*left + *right).to_string()
    }
}

#[tokio::main]
async fn main() {
    // Créer un état partagé avec une valeur initiale de 1
    let opts = Arc::new(Opts::new(1));

    // Configurer les routes pour les trois points de terminaison
    let router = Router::new()
        .push(Router::with_path("add1").get(opts.add1()))
        .push(Router::with_path("add2").get(opts.add2()))
        .push(Router::with_path("add3").get(Opts::add3()));

    // Générer la documentation OpenAPI
    let doc = OpenApi::new("Example API", "0.0.1").merge_router(&router);
    
    // Ajouter les routes de documentation OpenAPI et Swagger UI
    let router = router
        .push(doc.into_router("/api-doc/openapi.json"))
        .push(SwaggerUi::new("/api-doc/openapi.json").into_router("swagger-ui"));

    // Démarrer le serveur sur localhost:5800
    let acceptor = TcpListener::new("127.0.0.1:5800").bind().await;
    Server::new(acceptor).serve(router).await;
}
```
{/* 本行由工具自动生成,原文哈希值:2eb3d6ef348beb8a71682d2ad3a8bfd6 */}