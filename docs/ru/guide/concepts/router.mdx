# Роутер

## Что такое роутинг

[`Router`](https://docs.rs/salvo_core/latest/salvo_core/routing/struct.Router.html) определяет, какие промежуточные обработчики (middleware) и `Handler` будут обрабатывать HTTP-запрос. Это базовая и ключевая функциональность в Salvo.

Внутренне `Router` фактически состоит из набора фильтров (Filter). Когда поступает запрос, роутер последовательно сверху вниз проверяет, соответствует ли запрос ему самому и его дочерним элементам. Если совпадение найдено, последовательно выполняются все промежуточные обработчики, образующие цепочку от этого роутера и его дочерних роутеров. Если в процессе обработки статус `Response` устанавливается как ошибка (4XX, 5XX) или перенаправление (3XX), последующие промежуточные обработчики и `Handler` пропускаются. Вы также можете вручную вызвать `ctrl.skip_rest()`, чтобы пропустить оставшиеся промежуточные обработчики и `Handler`.

В процессе сопоставления существует информация о пути URL, которую можно рассматривать как объект, который должен быть полностью "потреблён" фильтрами в процессе сопоставления. Если в каком-либо Router все фильтры успешно сопоставлены и информация о пути URL полностью "потреблена", это считается "успешным сопоставлением".

Например:

```rust
Router::with_path("articles").get(list_articles).post(create_article);
```

Фактически эквивалентно:

```rust
Router::new()
    // PathFilter может фильтровать путь запроса. Успешное сопоставление произойдёт только если путь запроса содержит сегмент "articles",
    // иначе сопоставление не удастся. Например: /articles/123 — успешно, а /articles_list/123
    // хоть и содержит "articles", но из-за наличия "_list" после него — неуспешно.
    .filter(PathFilter::new("articles"))

    // Если корневой роутер успешно сопоставлен, и метод запроса — GET, то внутренний дочерний роутер может быть успешно сопоставлен,
    // и запрос будет обработан list_articles.
    .push(Router::new().filter(filters::get()).handle(list_articles))

    // Если корневой роутер успешно сопоставлен, и метод запроса — POST, то внутренний дочерний роутер может быть успешно сопоставлен,
    // и запрос будет обработан create_article.
    .push(Router::new().filter(filters::post()).handle(create_article));
```

Если обратиться к `GET /articles/`, это считается успешным сопоставлением, и выполнится `list_articles`. Однако, если обратиться к `GET /articles/123`, сопоставление с роутером не удастся и вернётся ошибка 404, потому что `Router::with_path("articles")` "потребил" только `/articles` из информации о пути URL, часть `/123` осталась не "потреблённой", поэтому сопоставление считается неудачным. Чтобы сопоставление было успешным, роутер можно изменить так:

```rust
Router::with_path("articles/{**}").get(list_articles).post(create_article);
```

Здесь `{**}` соответствует любому оставшемуся пути, поэтому он сможет сопоставить `GET /articles/123` и выполнить `list_articles`.

## Плоское определение

Мы можем определять маршруты в плоском стиле:

```rust
Router::with_path("writers").get(list_writers).post(create_writer);
Router::with_path("writers/{id}").get(show_writer).patch(edit_writer).delete(delete_writer);
Router::with_path("writers/{id}/articles").get(list_writer_articles);
```

## Иерархическое определение

Мы также можем определять маршруты иерархически, что является рекомендуемым способом:

```rust
Router::with_path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```
Такая форма определения для сложных проектов позволяет сделать определение Router более ясным и простым.

Многие методы в `Router` после вызова возвращают сам объект (Self), что позволяет писать код в цепочке. Иногда вам нужно решить, как маршрутизировать, основываясь на определённых условиях. Система маршрутизации также предоставляет функцию `then`, которую легко использовать:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::with_path("{id}").get(show_article))
            .then(|router|{
                if admin_mode() {
                    router.post(create_article).push(
                        Router::with_path("{id}").patch(update_article).delete(delete_writer)
                    )
                } else {
                    router
                }
            }),
    );
```
Этот пример показывает, что маршруты для создания, редактирования и удаления статей будут добавлены только тогда, когда сервер находится в режиме `admin_mode`.

## Получение параметров из маршрута

В приведённом выше коде `{id}` определяет параметр. Мы можем получить его значение через экземпляр `Request`:

```rust
#[handler]
async fn show_writer(req: &mut Request) {
    let id = req.param::<i64>("id").unwrap();
}
```

`{id}` соответствует одному сегменту пути. В нормальных условиях `id` статьи — это просто число. В этом случае мы можем использовать регулярное выражение, чтобы ограничить правило сопоставления для `id`: `r"{id|\d+}"`.

Для числовых типов есть более простой способ — использовать `<id:num>`. Конкретные варианты записи:
- `{id:num}` — соответствует любому количеству цифровых символов;
- `{id:num[10]}` — соответствует только фиксированному количеству цифровых символов, здесь 10 означает, что будет сопоставлено ровно 10 цифровых символов;
- `{id:num(..10)}` — соответствует от 1 до 9 цифровых символов;
- `{id:num(3..10)}` — соответствует от 3 до 9 цифровых символов;
- `{id:num(..=10)}` — соответствует от 1 до 10 цифровых символов;
- `{id:num(3..=10)}` — соответствует от 3 до 10 цифровых символов;
- `{id:num(10..)}` — соответствует как минимум 10 цифровым символам.

Также можно использовать `{**}`, `{*+}` или `{*?}` для сопоставления всех оставшихся сегментов пути. Для лучшей читаемости кода можно также добавить подходящее имя, чтобы сделать семантику пути более ясной, например: `{**file_path}`.

- `{**}`: означает, что часть, соответствующая подстановочному знаку, может быть пустой строкой. Например, путь `/files/{**rest_path}` будет соответствовать `/files`, `/files/abc.txt`, `/files/dir/abc.txt`;
- `{*+}`: означает, что часть, соответствующая подстановочному знаку, должна существовать и не может быть пустой строкой. Например, путь `/files/{*+rest_path}` не будет соответствовать `/files`, но будет соответствовать `/files/abc.txt`, `/files/dir/abc.txt`;
- `{*?}`: означает, что часть, соответствующая подстановочному знаку, может быть пустой строкой, но может содержать только один сегмент пути. Например, путь `/files/{*？rest_path}` не будет соответствовать `/files/dir/abc.txt`, но будет соответствовать `/files`, `/files/abc.txt`;

Допускается комбинировать несколько выражений для сопоставления с одним сегментом пути, например `/articles/article_{id:num}/`, `/images/{name}.{ext}`.

## Добавление промежуточных обработчиков

Промежуточные обработчики можно добавить с помощью функции `hoop` на роутере:

```rust
Router::new()
    .hoop(check_authed)
    .path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```

В этом примере корневой роутер использует `check_authed` для проверки, вошёл ли текущий пользователь в систему. На все дочерние роутеры будет влиять этот промежуточный обработчик.

Если пользователи просто просматривают информацию о `writer` и статьи, мы предпочли бы, чтобы они могли делать это без входа в систему. Мы можем определить маршруты следующим образом:

```rust
Router::new()
    .push(
        Router::new()
            .hoop(check_authed)
            .path("writers")
            .post(create_writer)
            .push(Router::with_path("{id}").patch(edit_writer).delete(delete_writer)),
    )
    .push(
        Router::with_path("writers").get(list_writers).push(
            Router::with_path("{id}")
                .get(show_writer)
                .push(Router::with_path("articles").get(list_writer_articles)),
        ),
    );
```

Хотя два роутера имеют одинаковое определение пути `path("articles")`, они всё равно могут быть добавлены к одному родительскому роутеру.

## Фильтры

Внутри `Router` сопоставление маршрутов определяется с помощью фильтров. Фильтры поддерживают базовые логические операции `or` или `and`. Роутер может содержать несколько фильтров, и когда все фильтры успешно сопоставлены, роутер считается успешно сопоставленным.

Структура пути веб-сайта является древовидной, но эта древовидная структура не эквивалентна древовидной структуре организации маршрутов. Один путь на сайте может соответствовать нескольким узлам маршрутов. Например, некоторый контент по пути `articles/` требует входа в систему для просмотра, а другой — нет. Мы можем организовать дочерние пути, требующие аутентификации, под роутером, содержащим промежуточный обработчик проверки входа, а те, которые не требуют проверки, — под другим роутером без проверки входа:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::with_path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

Роутер использует фильтры для фильтрации запросов и отправки их соответствующим промежуточным обработчикам и `Handler`.

`path` и `method` — два наиболее часто используемых фильтра. `path` используется для сопоставления с информацией о пути; `method` используется для сопоставления с методом запроса, например: GET, POST, PATCH и т.д.

Мы можем использовать `and`, `or` для соединения фильтров роутера:

```rust
Router::with_filter(filters::path("hello").and(filters::get()));
```

### Фильтры пути

Фильтры на основе пути запроса используются наиболее часто. В фильтрах пути можно определять параметры, например:

```rust
Router::with_path("articles/{id}").get(show_article);
Router::with_path("files/{**rest_path}").get(serve_file)
```

В `Handler` можно получить их через функцию `get_param` объекта `Request`:

```rust
#[handler]
pub async fn show_article(req: &mut Request) {
    let article_id = req.param::<i64>("id");
}

#[handler]
pub async fn serve_file(req: &mut Request) {
    let rest_path = req.param::<i64>("rest_path");
}
```

### Фильтры метода

Фильтруют запросы на основе `Method` HTTP-запроса, например:

```rust
Router::new().get(show_article).patch(update_article).delete(delete_article);
```

Здесь `get`, `patch`, `delete` — всё это фильтры методов. Фактически эквивалентно:

```rust
use salvo::routing::filter;

let mut root_router = Router::new();
let show_router = Router::with_filter(filters::get()).handle(show_article);
let update_router = Router::with_filter(filters::patch()).handle(update_article);
let delete_router = Router::with_filter(filters::get()).handle(delete_article);
Router::new().push(show_router).push(update_router).push(delete_router);
```

## Пользовательские Wisp

Для некоторых часто встречающихся выражений сопоставления мы можем дать короткое имя с помощью `PathFilter::register_wisp_regex` или `PathFilter::register_wisp_builder`. Например, формат GUID часто встречается в путях. Обычно при каждом сопоставлении нужно писать так:

```rust
Router::with_path("/articles/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
Router::with_path("/users/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
```

Каждый раз писать такое сложное регулярное выражение легко ошибиться, и код становится некрасивым. Можно сделать так:

```rust
use salvo::routing::filter::PathFilter;

#[tokio::main]
async fn main() {
    let guid = regex::Regex::new("[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}").unwrap();
    PathFilter::register_wisp_regex("guid", guid);
    Router::new()
        .push(Router::with_path("/articles/{id:guid}").get(show_article))
        .push(Router::with_path("/users/{id:guid}").get(show_user));
}
```

Достаточно зарегистрировать один раз, и в дальнейшем можно напрямую использовать простую запись `{id:guid}` для сопоставления с GUID, упрощая написание кода.

## Как понять Router, если раньше изучались веб-фреймворки класса Controller?
Основные различия между веб-фреймворками, основанными на маршрутизации (такими как Salvo), и традиционными фреймворками MVC или Controller:

- **Гибкость**: Дизайн маршрутизации позволяет более гибко определять процесс обработки запросов, можно точно контролировать логику обработки каждого пути. Например, в Salvo вы можете напрямую определить функцию обработки для конкретного пути:
  ```rust
  Router::with_path("articles").get(list_articles).post(create_article);
  ```
  В то время как в дизайне Controller обычно нужно сначала определить класс контроллера, а затем определить несколько методов в классе для обработки разных запросов:
  ```java
  @Controller
  public class ArticleController {
      @GetMapping("/articles")
      public List<Article> listArticles() { /* ... */ }
      
      @PostMapping("/articles")
      public Article createArticle(@RequestBody Article article) { /* ... */ }
  }
  ```

- **Интеграция промежуточного ПО**: Фреймворки маршрутизации обычно предоставляют более простые способы интеграции промежуточного ПО, которые можно применять к определённым маршрутам. Промежуточное ПО Salvo можно точно применять к конкретным маршрутам:
  ```rust
  Router::new()
      .push(
          Router::with_path("admin/articles")
              .hoop(admin_auth_middleware)  // Применяет промежуточное ПО аутентификации только к маршрутам администратора
              .get(list_all_articles)
              .post(create_article),
      )
      .push(
          Router::with_path("articles")  // Публичные маршруты не требуют аутентификации
              .get(list_public_articles),
      );
  ```

- **Организация кода**: Дизайн маршрутизации склоняется к организации кода на основе функций или конечных точек API, а не к разделению на модель-представление-контроллер MVC.
  Дизайн маршрутизации поощряет организацию кода в соответствии с функциональностью конечных точек API:
  ```rust
  // user_routes.rs - маршруты и логика обработки, связанные с пользователями
  pub fn user_routes() -> Router {
      Router::with_path("users")
          .get(list_users)
          .post(create_user)
          .push(Router::with_path
{/* Auto generated, origin file hash:ba0a1eadc077c274134c7a533d887f99 */}