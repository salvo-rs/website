# Um diese Kunst zu meistern

## Warum dieses Framework geschrieben wurde

Als Anfänger stellte ich damals fest, dass ich zu begriffsstutzig war, um Frameworks wie actix-web oder Rocket zu erlernen. Als ich einen früheren Go-Webdienst in Rust neu implementieren wollte, schien jedes Framework auf den ersten Blick komplexer zu sein als die bestehenden Go-Frameworks. Die Lernkurve von Rust ist schon steil genug – warum also sollten Webframeworks noch zusätzlich verkompliziert werden?

Als Tokio das Axum-Framework veröffentlichte, war ich frohen Mutes, dass ich mein eigenes Webframework nicht mehr weiterpflegen müsste. Doch in der Praxis erwies sich Axum als trügerisch einfach: Zu viel Type-Gymnastik und generische Definitionen erforderten tiefgehende Rust-Kenntnisse und das mühsame Schreiben unverständlicher Boilerplate, nur um eine einfache Middleware zu implementieren.

Daher entschied ich mich, mein eigenes, besonderes Webframework weiterzuentwickeln – eines, das intuitiv bedienbar, funktionsreich und für Anfänger geeignet ist.

## Ist Salvo das Richtige für Sie?

Salvo ist einfach, aber dennoch umfassend und leistungsstark – praktisch das mächtigste Framework in der Rust-Welt. Trotz seiner Stärke ist es einfach zu erlernen und zu nutzen, ganz ohne frustrierende Hürden.

- **Geeignet für Rust-Einsteiger:** CRUD-Operationen sind alltäglich. Mit Salvo sind solche Aufgaben so einfach wie in anderen Webframeworks (z. B. Express, Koa, Gin, Flask) – in mancher Hinsicht sogar abstrakter und eleganter.
  
- **Geeignet für den Produktiveinsatz:** Salvo bietet stabile und schnelle Server, auch wenn Version 1.0 noch nicht veröffentlicht ist. Die Kernfunktionen sind über Jahre erprobt, stabil und werden zeitnah gepatcht.
  
- **Geeignet für Sie, deren Haarpracht schwindet, während die täglichen Herausforderungen wachsen.**

## Wie wird Einfachheit erreicht?

Viele Low-Level-Implementierungen bietet Hyper bereits. Daher ist es sinnvoll, allgemeine Anforderungen auf Hyper aufzubauen – so auch Salvo. Seine Kernfunktionen umfassen ein leistungsfähiges, flexibles Routingsystem sowie gängige Module wie Acme, OpenAPI und JWT-Auth.

In Salvo sind Handler und Middleware vereinheitlicht: Middleware **ist** ein Handler. Beide werden über `hoop` an Router angehängt. Im Wesentlichen verarbeiten sie Request-Anfragen und können Daten in die Response schreiben. Ein Handler empfängt drei Parameter: `Request`, `Depot` (für temporäre Daten während der Verarbeitung) und `Response`.

Zur Vereinfachung können nicht benötigte Parameter weggelassen oder in beliebiger Reihenfolge angegeben werden.

```rust
use salvo::prelude::*;

#[handler]
async fn hello_world(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {
    res.render("Hello world");
}
#[handler]
async fn hello_world(res: &mut Response) {
    res.render("Hello world");
}
```

Die API des Routingsystems ist ebenfalls äußerst einfach, aber dennoch mächtig. Für den Normalfall genügt die Beschäftigung mit dem Typ `Router`.  
Zudem generiert Salvo automatisch OpenAPI-Dokumentation und extrahiert Parameter, sofern Strukturen die entsprechenden Traits implementieren. Es verarbeitet verschiedene Fehler automatisch und gibt benutzerfreundliche Hinweise zurück. Dadurch wird das Schreiben von Handlern so intuitiv wie das Schreiben gewöhnlicher Funktionen. In späteren Tutorials werden diese Funktionen detailliert erklärt. Hier ein Beispiel:

```rust
#[endpoint(tags("Nachrichtenprotokoll"))]
pub async fn create_message_log_handler(
    input: JsonBody<CreateOrUpdateMessageLog>,
    depot: &mut Depot,
) -> APPResult<Json<MessageLog>> {
    let db = utils::get_db(depot)?;
    let log = create_message_log(&input, db).await?;
    Ok(Json(log))
}
```

In diesem Beispiel parst `JsonBody<CreateOrUpdateMessageLog>` automatisch JSON-Daten aus dem Request-Body und konvertiert sie in den Typ `CreateOrUpdateMessageLog` (unterstützt auch mehrere Datenquellen und verschachtelte Typen). Gleichzeitig generiert das `#[endpoint]`-Attribut automatisch OpenAPI-Dokumentation für diese Schnittstelle und vereinfacht die Parameter-Extraktion sowie Fehlerbehandlung.

## Das Routingsystem

Das Routingsystem unterscheidet sich meiner Meinung nach von anderen Frameworks. Router können flach oder baumartig strukturiert werden. Dabei wird zwischen **Geschäftslogikbaum** und **Zugriffspfadbaum** unterschieden. Der Geschäftslogikbaum organisiert Router nach fachlichen Anforderungen und bildet einen Router-Baum, der nicht zwangsläufig mit der Zugriffspfad-Struktur übereinstimmt.

Normalerweise schreiben wir Routen so:

```rust
Router::new().path("articles").get(list_articles).post(create_article);
Router::new()
    .path("articles/{id}")
    .get(show_article)
    .patch(edit_article)
    .delete(delete_article);
```

Oft erfordern das Auflisten und Anzeigen von Artikeln keine Benutzeranmeldung, während das Erstellen, Bearbeiten und Löschen Authentifizierung benötigt. Salvos verschachteltes Routingsystem erfüllt diese Anforderung ideal. Routen ohne Authentifizierung können zusammengefasst werden:

```rust
Router::new()
    .path("articles")
    .get(list_articles)
    .push(Router::new().path("{id}").get(show_article));
```

Routen mit Authentifizierung werden gruppiert und durch entsprechende Middleware abgesichert:

```rust
Router::new()
    .path("articles")
    .hoop(auth_check)
    .post(list_articles)
    .push(Router::new().path("{id}").patch(edit_article).delete(delete_article));
```

Obwohl beide Router den gleichen `path("articles")` haben, können sie demselben Eltern-Router hinzugefügt werden. Die finale Route sieht dann so aus:

```rust
Router::new()
    .push(
        Router::new()
            .path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::new()
            .path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

`{id}` matcht ein Pfadsegment. Da Artikel-IDs normalerweise nur Zahlen sind, kann die Matching-Regel mit einem regulären Ausdruck eingeschränkt werden: `r"{id:/\d+/}"`.
{/* Auto generated, origin file hash:bd1fc4c816e814fa9f1d5c39301ad59a */}