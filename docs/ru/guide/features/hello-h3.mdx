# Поддержка HTTP/3

Salvo предоставляет поддержку HTTP/3, которую можно активировать с помощью функции `quinn`. HTTP/3 основан на протоколе QUIC и обеспечивает меньшую задержку и более высокую производительность по сравнению с традиционными HTTP/1.1 и HTTP/2, особенно в нестабильных сетевых условиях.

## Включение поддержки HTTP/3

Чтобы включить поддержку HTTP/3 в Salvo, необходимо активировать функцию `quinn` в файле `Cargo.toml`:

```toml
salvo = { workspace = true, features = ["quinn"] }
```

## Сценарии использования HTTP/3

HTTP/3 особенно подходит для следующих случаев:

- Приложения на мобильных устройствах и в нестабильных сетевых условиях
- Приложения реального времени с требованиями низкой задержки
- Сценарии с параллельной загрузкой множества мелких файлов
- Приложения, требующие миграции соединений (например, плавное переключение с Wi-Fi на сотовую сеть без разрыва соединения)

## Пример кода

Ниже представлен простой пример HTTP/3 сервера, поддерживающего как HTTP/3 (QUIC), так и HTTPS (TCP):

```rust
use salvo::conn::rustls::{Keycert, RustlsConfig};
use salvo::prelude::*;

// Функция-обработчик, возвращающая "Hello World"
#[handler]
async fn hello() -> &'static str {
    "Hello World"
}

#[tokio::main]
async fn main() {
    // Инициализация системы логирования
    tracing_subscriber::fmt().init();

    // Загрузка TLS-сертификата и приватного ключа из встроенных PEM-файлов
    let cert = include_bytes!("../certs/cert.pem").to_vec();
    let key = include_bytes!("../certs/key.pem").to_vec();

    // Создание роутера и добавление конечной точки
    let router = Router::new().get(hello);

    // Настройка TLS с использованием Rustls
    let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

    // Создание TLS-шифрованного TCP-слушателя на порту 5800
    let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());

    // Создание QUIC-слушателя и его объединение с TCP-слушателем
    let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 5800))
        .join(listener)
        .bind()
        .await;

    // Запуск сервера с поддержкой HTTP/3 (QUIC) и HTTPS (TCP)
    Server::new(acceptor).serve(router).await;
}
```

## Анализ ключевого кода

### Конфигурация TLS

```rust
// Настройка TLS с использованием Rustls
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));
```

Поскольку HTTP/3 основан на протоколе QUIC, который требует TLS 1.3 для шифрования, необходимо настроить TLS-сертификаты и ключи. В Salvo мы используем `RustlsConfig` для настройки TLS.

### Объединение слушателей

```rust
// Создание TLS-шифрованного TCP-слушателя
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());

// Создание QUIC-слушателя и его объединение с TCP-слушателем
let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;
```

Этот код является ключевой частью обработки HTTP/3 в Salvo. Сначала создается TCP-слушатель с поддержкой TLS (для HTTP/1.1 и HTTP/2), затем создается QUIC-слушатель (для HTTP/3). Метод `join` объединяет эти два слушателя, позволяя серверу одновременно обрабатывать запросы по разным протоколам.

## Запуск примера

Для запуска этого примера необходимы действительные TLS-сертификаты и приватные ключи. В среде разработки можно использовать самоподписанные сертификаты. Полный пример кода можно найти в [репозитории Salvo на GitHub](https://github.com/salvo-rs/salvo/tree/main/examples/hello-h3).

Обратите внимание, что поскольку многие клиенты ещё не полностью поддерживают HTTP/3, для этого сервера критически важно поддерживать как HTTP/3, так и HTTPS.

## Важные замечания

1. HTTP/3 требует поддержки TLS 1.3, поэтому необходимо настроить действительные сертификаты и ключи.
2. Клиенты должны поддерживать протокол HTTP/3 для использования этой функции; в противном случае будет использоваться HTTP/1.1 или HTTP/2.
3. В производственных средах следует использовать сертификаты, выпущенные доверенным центром сертификации (CA), вместо самоподписанных сертификатов.
{/* Auto generated, origin file hash:f135699b9ae12daf6d88fc1e8c22a61e */}