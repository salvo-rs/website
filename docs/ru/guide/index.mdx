# Искусство освоения

## Зачем создавать этот фреймворк

В то время, будучи новичком, я обнаружил, что я слишком глуп, чтобы научиться использовать существующие фреймворки, такие как actix-web и Rocket. Когда я захотел переписать свой старый веб-сервис на Go с использованием Rust, на первый взгляд каждый фреймворк казался сложнее, чем существующие фреймворки в Go. Учитывая, что кривая обучения Rust и так достаточно крутая, зачем же делать веб-фреймворк таким сложным?

Когда Tokio представил фреймворк Axum, я был рад, думая, что мне больше не придется поддерживать свой собственный веб-фреймворк. Однако на практике я обнаружил, что Axum, хотя и кажется простым, требует слишком много гимнастики с типами и обобщенными определениями. Для создания простого промежуточного слоя необходимо глубокое понимание языка Rust и готовность писать множество замысловатых шаблонных кодов.

Поэтому я решил продолжить поддержку своего особенного (удобного, функционально богатого и подходящего для новичков) веб-фреймворка.

## Подходит ли вам Salvo (Сайфенг)

Хотя Salvo прост, он достаточно мощный и всеобъемлющий, его можно считать одним из сильнейших в мире Rust. Однако, несмотря на свою мощь, он прост в изучении и использовании. Он точно не заставит вас страдать, как от «отсечения лишнего».

- Он подходит для начинающих, которые только изучают Rust. CRUD — это чрезвычайно обычная и часто используемая функциональность. Если использовать Salvo для подобных задач, вы обнаружите, что он так же прост, как и веб-фреймворки на других языках (например, Express, Koa, gin, flask...), а в некоторых аспектах даже более абстрактный и лаконичный.

- Он подходит для тех, кто хочет использовать Rust в производственной среде, обеспечивая стабильный и быстрый сервер. Хотя Salvo еще не достиг версии 1.0, его основные функции прошли несколько лет итераций, достаточно стабильны, и проблемы исправляются своевременно.

- Он подходит для вас, чьи волосы уже не так густы, но продолжают выпадать каждый день.

## Как достичь достаточной простоты

Многие низкоуровневые реализации уже реализованы в Hyper, поэтому для общих потребностей реализация на основе Hyper — правильный выбор. То же самое и с Salvo. Основные функции — это мощная и гибкая система маршрутизации, а также множество часто используемых функций, таких как Acme, OpenAPI, JWT Auth и другие.

В Salvo унифицированы Handler и Middleware. Middleware — это Handler. Они добавляются к Router через hoop маршрутизации. По сути, и Middleware, и Handler обрабатывают запрос Request и могут записывать данные в Response. Handler принимает три параметра: Request, Depot и Response, где Depot используется для хранения временных данных в процессе обработки запроса.

Для удобства написания, если параметры не нужны, их можно опустить, а также игнорировать порядок передачи параметров.

```rust
use salvo::prelude::*;

#[handler]
async fn hello_world(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {
    res.render("Hello world");
}
#[handler]
async fn hello_world(res: &mut Response) {
    res.render("Hello world");
}
```

Кроме того, API, предоставляемое системой маршрутизации, чрезвычайно простое, но функционально мощное. При обычном использовании в основном нужно сосредоточиться только на типе Router.
Кроме того, если структура реализует соответствующие трейты, Salvo может автоматически генерировать документацию OpenAPI, извлекать параметры, автоматически обрабатывать различные ошибки и возвращать понятные сообщения. Это делает написание обработчиков таким же простым и интуитивно понятным, как написание обычных функций. В последующих уроках мы подробно рассмотрим эти функции. Вот пример:

```rust

#[endpoint(tags("消息日志"))]
pub async fn create_message_log_handler(
    input: JsonBody<CreateOrUpdateMessageLog>,
    depot: &mut Depot,
) -> APPResult<Json<MessageLog>> {
    let db = utils::get_db(depot)?;
    let log = create_message_log(&input, db).await?;
    Ok(Json(log))
}
```

В этом примере `JsonBody<CreateOrUpdateMessageLog>` автоматически анализирует данные JSON из тела запроса и преобразует их в тип `CreateOrUpdateMessageLog` (также поддерживает несколько источников данных, вложенные типы). В то же время макрос `#[endpoint]` автоматически генерирует документацию OpenAPI для этого интерфейса и упрощает код извлечения параметров и обработки ошибок.

## Система маршрутизации

Я чувствую, что система маршрутизации отличается от других фреймворков. Router можно писать линейно или в виде дерева. Здесь различают дерево бизнес-логики и дерево каталогов доступа. Дерево бизнес-логики разделяет структуру маршрутизатора в соответствии с потребностями бизнес-логики, образуя дерево маршрутизаторов, которое не обязательно совпадает с деревом каталогов доступа.

В нормальных условиях мы пишем маршруты так:

```rust
Router::new().path("articles").get(list_articles).post(create_article);
Router::new()
    .path("articles/{id}")
    .get(show_article)
    .patch(edit_article)
    .delete(delete_article);
```

Часто просмотр статей и списка статей не требует входа пользователя в систему, но создание, редактирование и удаление статей требуют аутентификации и прав доступа пользователя. Вложенная система маршрутизации в Salvo хорошо удовлетворяет эту потребность. Мы можем объединить маршруты, не требующие входа пользователя:

```rust
Router::new()
    .path("articles")
    .get(list_articles)
    .push(Router::new().path("{id}").get(show_article));
```

А затем объединить маршруты, требующие входа пользователя, и использовать соответствующий промежуточный слой для проверки аутентификации пользователя:
```rust
Router::new()
    .path("articles")
    .hoop(auth_check)
    .post(list_articles)
    .push(Router::new().path("{id}").patch(edit_article).delete(delete_article));
```

Хотя оба этих маршрута имеют одинаковый `path("articles")`, они все равно могут быть добавлены к одному и тому же родительскому маршрутизатору, поэтому итоговый маршрут выглядит так:

```rust
Router::new()
    .push(
        Router::new()
            .path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::new()
            .path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

`{id}` соответствует сегменту пути. В нормальных условиях `id` статьи — это просто число. В этом случае мы можем использовать регулярное выражение, чтобы ограничить правило соответствия для `id`: `r"{id:/\d+/}"`.
{/* 本行由工具自动生成,原文哈希值:bd1fc4c816e814fa9f1d5c39301ad59a */}