# Para dominar esta técnica

## Por qué escribir este framework

En ese entonces, como principiante, descubrí que era demasiado torpe para aprender a usar frameworks existentes como actix-web o Rocket. Cuando quise reescribir en Rust un servicio web que antes tenía en Go, a primera vista, cada framework parecía más complejo que los existentes en Go. Ya de por sí la curva de aprendizaje de Rust es bastante empinada, ¿para qué hacer que los frameworks web sean tan complicados?

Cuando Tokio lanzó el framework Axum, me alegré pensando que ya no tendría que mantener mi propio framework web. Sin embargo, la realidad fue que Axum, aunque aparentemente simple, implicaba demasiada gimnasia de tipos y definiciones genéricas en su uso práctico. Para implementar un middleware sencillo, era necesario tener un conocimiento profundo de Rust y escribir montones de código boilerplate críptico y tedioso.

Así que decidí seguir manteniendo este framework web mío, que es bastante peculiar (cómodo, rico en funciones y adecuado para principiantes).

## ¿Es Salvo adecuado para ti?

Aunque Salvo es simple, es lo suficientemente completo y potente, básicamente puede considerarse el más fuerte en el ecosistema de Rust. Sin embargo, a pesar de ser un sistema tan poderoso, aprenderlo y usarlo es realmente sencillo. Definitivamente no te causará el dolor de "cortarte los genitales con tu propia espada".

- Es adecuado para principiantes que están empezando a aprender Rust. CRUD es una funcionalidad extremadamente común y de uso frecuente. Si usas Salvo para tareas similares, descubrirás que es tan simple como los frameworks web que has usado en otros lenguajes (por ejemplo: Express, Koa, gin, flask...), e incluso más abstracto y conciso en algunos aspectos.

- Es adecuado para quienes desean usar Rust en entornos de producción, proporcionando servidores robustos y rápidos. Aunque Salvo no ha lanzado la versión 1.0, sus funciones principales han pasado por años de iteraciones, son lo suficientemente estables y los problemas se solucionan con prontitud.

- Es adecuado para ti, cuyo cabello ya no es abundante pero sigue cayéndose a diario.

## Cómo lograr la suficiente simplicidad

Hyper ya ha implementado muchas funcionalidades de bajo nivel, por lo que, para necesidades generales, basarse en Hyper no está mal. Salvo hace lo mismo. Su funcionalidad central es un sistema de enrutamiento potente y flexible, junto con muchas funciones de uso común, como Acme, OpenAPI, autenticación JWT, etc.

En Salvo, Handler y Middleware están unificados. Middleware es Handler. Se agregan al Router a través del "hoop" del enrutador. En esencia, tanto Middleware como Handler procesan solicitudes Request y pueden escribir datos en Response. Handler recibe tres parámetros: Request, Depot y Response, donde Depot se utiliza para almacenar datos temporales durante el procesamiento de la solicitud.

Para facilitar la escritura, se pueden omitir ciertos parámetros cuando no son necesarios, y también se puede ignorar el orden de los parámetros.

```rust
use salvo::prelude::*;

#[handler]
async fn hello_world(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {
    res.render("Hello world");
}
#[handler]
async fn hello_world(res: &mut Response) {
    res.render("Hello world");
}
```

Además, la API proporcionada por el sistema de enrutamiento es extremadamente simple, pero poderosa. Para necesidades de uso normales, básicamente solo necesitas enfocarte en el tipo Router.
Además, si una estructura implementa los traits relevantes, Salvo puede generar automáticamente documentación OpenAPI y extraer parámetros, manejar diferentes errores automáticamente y devolver mensajes amigables. Esto hace que escribir handlers sea tan simple e intuitivo como escribir funciones ordinarias. En tutoriales posteriores, explicaremos estas funciones en detalle paso a paso. Aquí hay un ejemplo:

```rust
#[endpoint(tags("registro de mensajes"))]
pub async fn create_message_log_handler(
    input: JsonBody<CreateOrUpdateMessageLog>,
    depot: &mut Depot,
) -> APPResult<Json<MessageLog>> {
    let db = utils::get_db(depot)?;
    let log = create_message_log(&input, db).await?;
    Ok(Json(log))
}
```

En este ejemplo, `JsonBody<CreateOrUpdateMessageLog>` analizará automáticamente los datos JSON del cuerpo de la solicitud y los convertirá al tipo `CreateOrUpdateMessageLog` (también admite múltiples fuentes de datos y tipos anidados). Al mismo tiempo, la macro `#[endpoint]` generará automáticamente documentación OpenAPI para esta interfaz y simplificará el código de extracción de parámetros y manejo de errores.

## Sistema de enrutamiento

Siento que el sistema de enrutamiento es diferente al de otros frameworks. Router se puede escribir de forma plana o como un árbol. Aquí se distingue entre el árbol de lógica de negocio y el árbol de directorios de acceso. El árbol de lógica de negocio divide la estructura del router según las necesidades de la lógica de negocio, formando un árbol de routers, que no necesariamente coincide con el árbol de directorios de acceso.

Normalmente escribimos las rutas así:

```rust
Router::new().path("articles").get(list_articles).post(create_article);
Router::new()
    .path("articles/{id}")
    .get(show_article)
    .patch(edit_article)
    .delete(delete_article);
```

A menudo, ver la lista de artículos y los detalles de un artículo no requiere que el usuario inicie sesión, pero crear, editar o eliminar artículos sí requiere permisos de autenticación de usuario. El sistema de enrutamiento anidado de Salvo puede satisfacer muy bien esta necesidad. Podemos agrupar las rutas que no requieren inicio de sesión:

```rust
Router::new()
    .path("articles")
    .get(list_articles)
    .push(Router::new().path("{id}").get(show_article));
```

Luego, agrupamos las rutas que requieren inicio de sesión y usamos el middleware correspondiente para verificar si el usuario ha iniciado sesión:

```rust
Router::new()
    .path("articles")
    .hoop(auth_check)
    .post(list_articles)
    .push(Router::new().path("{id}").patch(edit_article).delete(delete_article));
```

Aunque ambas rutas tienen el mismo `path("articles")`, aún pueden agregarse al mismo router padre, por lo que el router final termina así:

```rust
Router::new()
    .push(
        Router::new()
            .path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::new()
            .path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

`{id}` coincide con un segmento de la ruta. Normalmente, el `id` de un artículo es solo un número. En ese caso, podemos usar una expresión regular para restringir la regla de coincidencia de `id`: `r"{id:/\d+/}"`.
{/* Auto generated, origin file hash:bd1fc4c816e814fa9f1d5c39301ad59a */}