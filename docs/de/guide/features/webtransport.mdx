# WebTransport

WebTransport ist ein auf HTTP/3 basierendes Netzwerkübertragungsprotokoll, das bidirektionale Kommunikationsfähigkeiten zwischen Client und Server bietet und gleichzeitig geringe Latenz, hohen Durchsatz und Sicherheit gewährleistet.

## Anwendungsszenarien

WebTransport eignet sich besonders für folgende Szenarien:

- **Echtzeitanwendungen**: Online-Spiele, Echtzeit-Kollaborationstools, Videokonferenzen und andere Anwendungen, die eine Kommunikation mit geringer Latenz erfordern
- **Große Dateiübertragungen**: Unterstützt Datenübertragungen mit hohem Durchsatz, geeignet für Medienstreams und das Hoch- und Herunterladen großer Dateien
- **Multiplex-Kommunikation**: Ermöglicht gleichzeitig mehrere bidirektionale und unidirektionale Datenströme
- **Datagramm-Kommunikation**: Unterstützt die Kommunikation über Datagramme ohne Garantie für Reihenfolge und Zuverlässigkeit, geeignet für Szenarien mit extrem hohen Echtzeitanforderungen

Im Vergleich zu WebSocket bietet WebTransport eine geringere Latenz und flexiblere Kommunikationsmodi, insbesondere in instabilen Netzwerkumgebungen.

## Salvo-Implementierung

Das Salvo-Framework bietet integrierte Unterstützung für WebTransport, sodass Entwickler problemlos WebTransport-basierte Anwendungen erstellen können. Hauptmerkmale umfassen:

- Unterstützung für die Einrichtung von WebTransport-Sitzungen
- Unterstützung für die Kommunikation über bidirektionale Ströme (Bidirectional Streams)
- Unterstützung für die Kommunikation über unidirektionale Ströme (Unidirectional Streams)
- Unterstützung für die Übertragung von Datagrammen (Datagrams)
- Server können Kommunikationsströme aktiv initiieren

### Einfaches Beispiel

Hier ist ein vereinfachtes Beispiel für einen WebTransport-Server mit Salvo:

```rust
#[handler]
async fn connect(req: &mut Request) -> Result<(), salvo::Error> {
    let session = req.web_transport_mut().await.unwrap();
    
    // Datagramme verarbeiten
    if let Ok(Some((_, datagram))) = session.accept_datagram().await {
        // Empfangenes Datagramm verarbeiten
        let mut resp = BytesMut::from(&b"Response: "[..]);
        resp.put(datagram);
        session.send_datagram(resp.freeze())?;
    }
    
    // Bidirektionale Ströme verarbeiten
    if let Ok(Some(webtransport::server::AcceptedBi::BidiStream(_, stream))) = session.accept_bi().await {
        let (send, recv) = salvo::proto::quic::BidiStream::split(stream);
        // Daten des bidirektionalen Stroms verarbeiten
    }
    
    Ok(())
}
```

### Konfiguration und Start

Um eine Salvo-Anwendung mit WebTransport-Unterstützung zu starten, müssen TLS-Zertifikate und ein QUIC-Listener konfiguriert werden:

```rust
let cert = include_bytes!("../certs/cert.pem").to_vec();
let key = include_bytes!("../certs/key.pem").to_vec();

// Routing konfigurieren
let router = Router::new().push(Router::with_path("counter").goal(connect));

// TLS konfigurieren
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

// Listener einrichten
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());
let acceptor = QuinnListener::new(config, ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;

// Server starten
Server::new(acceptor).serve(router).await;
```

## Vollständiges Beispiel

Um mehr über die Verwendung von WebTransport in Salvo zu erfahren, sehen Sie sich das vollständige Beispiel auf GitHub an:
[https://github.com/salvo-rs/salvo/blob/main/examples/webtransport](https://github.com/salvo-rs/salvo/blob/main/examples/webtransport)

Dieses Beispiel enthält eine vollständige Implementierung von Server- und Client-Seite und zeigt, wie verschiedene Arten von WebTransport-Kommunikation verarbeitet werden.
{/* Auto generated, origin file hash:56518c15094059054cd812ca62f2a97c */}