# 快取

提供快取功能的中介軟體。

Cache 中介軟體可以對 `Response` 中的 `StatusCode`、`Headers`、`Body` 提供快取功能。對於已經快取的內容，當下次處理請求時，Cache 中介軟體會直接把快取在記憶體中的內容傳送給客戶端。

注意，此外掛不會快取 `Body` 是 `ResBody::Stream` 的 `Response`。如果應用到這一類型的 `Response`，Cache 不會處理這些請求，也不會引起錯誤。

## 主要功能

- `CacheIssuer` 提供了對分配的快取鍵值的抽象。`RequestIssuer` 是它的一個實現，可以定義依據請求的 URL 的哪些部分以及請求的 `Method` 產生快取的鍵。你也可以定義你自己的快取鍵產生邏輯。快取的鍵不一定是字串類型，任何滿足 `Hash + Eq + Send + Sync + 'static` 約束的類型都可以作為鍵。

- `CacheStore` 提供對資料的存取操作。`MokaStore` 是內建的基於 `moka` 的一個記憶體快取實現。你也可以定義自己的實現方式。

- `Cache` 是實現了 `Handler` 的結構體，內部還有一個 `skipper` 欄位，可以指定跳過某些不需要快取的請求。預設情況下，會使用 `MethodSkipper` 跳過除了 `Method::GET` 以外的所有請求。

  內部實現範例程式碼：

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## 從其他框架快速遷移

如果你之前使用過其他框架的快取機制，下面的概念對映將幫助你更快適應 Salvo 的快取實現：

### Rust 框架遷移指南

- **從 Actix-web 遷移**：Actix-web 中的 `actix-web-cache` 等外掛通常需要單獨引入，而 Salvo 的快取是核心函式庫的一部分。

  ```rust
  // Actix-web 快取範例
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Salvo 對應實現
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### 其他語言框架遷移指南

- **從 Go/Gin 遷移**：Gin 使用中介軟體模式，Salvo 也採用類似的方式：

  ```go
  // Gin 快取範例
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Salvo 對應實現
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **從 Spring Boot 遷移**：Spring Boot 的宣告式快取需要轉換為 Salvo 的顯式中介軟體配置：

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Salvo 對應實現 - 在路由層級應用快取
  let custom_issuer = YourCustomIssuer::new(); // 實現 CacheIssuer 介面
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **從 Express.js 遷移**：Express 的快取中介軟體與 Salvo 概念上類似，但語法不同：

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Salvo 對應實現
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

在從其他框架遷移時，需要注意 Salvo 快取的幾個關鍵概念：

1. **快取鍵產生** - 透過 `CacheIssuer` 介面控制
2. **快取儲存** - 透過 `CacheStore` 介面實現
3. **快取跳過邏輯** - 透過 `skipper` 機制自訂

預設情況下，Salvo 僅快取 GET 請求，這與多數框架的預設行為一致。

_**範例程式碼**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* Auto generated, origin file hash:df2bc60555363c109d61ba033738ce41 */}