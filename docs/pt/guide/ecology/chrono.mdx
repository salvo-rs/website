---
title: Biblioteca de Data e Hora em Rust
---

# Chrono: Biblioteca de Data e Hora em Rust

[Chrono](https://docs.rs/chrono/latest/chrono/) visa fornecer toda a funcionalidade necessária para realizar operações de data e hora corretas no calendário gregoriano proleptico:

- O tipo `DateTime` é consciente do fuso horário por padrão, enquanto também fornece tipos independentes de fuso horário separados.
- Operações que podem produzir datas e horas inválidas ou ambíguas retornam `Option` ou `MappedLocalTime`.
- Análise e formatação configuráveis com sintaxe de formatação de data e hora inspirada no strftime.
- O fuso horário `Local` pode funcionar com o fuso horário atual do sistema operacional.
- Tipos e operações são implementados com consideração de eficiência razoável.
- Para limitar o tamanho do binário, o Chrono não vem com dados de fuso horário por padrão. Use a crate complementar `Chrono-TZ` ou `tzfile` para obter suporte completo de fuso horário.

## Funcionalidades

[Chrono](https://docs.rs/chrono/latest/chrono/) suporta vários ambientes de execução e sistemas operacionais, com vários recursos que podem ser habilitados ou desabilitados.

### Recursos padrão:

- `alloc`: Habilita funcionalidades que dependem de alocação de memória (principalmente formatação de strings).
- `std`: Habilita funcionalidades que dependem da biblioteca padrão. Este é um superconjunto de `alloc`, adicionando interoperabilidade com tipos e traits da biblioteca padrão.
- `clock`: Habilita a leitura do fuso horário local (`Local`). Este é um superconjunto de `now`.
- `now`: Habilita a leitura do tempo do sistema (`now`).
- `wasmbind`: Fornece uma interface com a API Date do JS para alvos wasm32.

### Recursos opcionais:

- `serde`: Habilita serialização/desserialização via serde.
- `rkyv`: Obsoleto, use os recursos `rkyv-*`.
- `rkyv-16`, `rkyv-32`, `rkyv-64`: Habilita serialização/desserialização via rkyv, usando inteiros de 16, 32 ou 64 bits respectivamente.
- `rkyv-validation`: Habilita suporte de validação rkyv usando bytecheck.
- `arbitrary`: Constrói instâncias arbitrárias de tipos usando a crate Arbitrary.
- `unstable-locales`: Habilita localização. Isso adiciona vários métodos com sufixo `_localized`.

## Visão Geral

### Diferença de Tempo/Duração

Chrono fornece o tipo `TimeDelta` para representar a magnitude de um intervalo de tempo. Esta é uma duração "exata" expressa em segundos e nanossegundos, não representando componentes "nominais" como dias ou meses.

O tipo `TimeDelta` era anteriormente chamado `Duration` (ainda fornecido como um alias de tipo). Uma distinção notável em relação ao `core::time::Duration` similar é que ele é um valor com sinal em vez de sem sinal.

### Data e Hora

Chrono fornece o tipo `DateTime` para representar uma data e hora em um fuso horário.

`DateTime` é consciente do fuso horário e deve ser construído a partir de um objeto `TimeZone`, que define como uma data local é convertida para e de uma data UTC. Existem três implementações conhecidas de `TimeZone`:

- `Utc` especifica o fuso horário UTC. É o mais eficiente.
- `Local` especifica o fuso horário local do sistema.
- `FixedOffset` especifica um fuso horário fixo arbitrário, como UTC+09:00 ou UTC-10:30.

`DateTime`s de diferentes tipos `TimeZone` são distintos e não podem ser misturados, mas podem ser convertidos entre si usando o método `DateTime::with_timezone`.

Você pode obter a data e hora atuais no fuso horário UTC (`Utc::now()`) ou no fuso horário local (`Local::now()`).

```rust
use chrono::prelude::*;

let utc: DateTime<Utc> = Utc::now(); // por exemplo `2014-11-28T12:45:59.324310806Z`
let local: DateTime<Local> = Local::now(); // por exemplo `2014-11-28T21:45:59.324310806+09:00`
```

Além disso, você pode criar suas próprias datas e horas:

```rust
use chrono::offset::MappedLocalTime;
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap(); // `2014-07-08T09:10:11Z`
```

### Formatação e Análise

A formatação é feita através do método `format`, cujo formato é equivalente ao familiar formato strftime.

O método padrão `to_string` e o especificador `{:?}` também fornecem uma representação razoável. Chrono também fornece métodos `to_rfc2822` e `to_rfc3339` para formatos comuns.

Chrono agora também fornece formatação de data em praticamente qualquer idioma sem bibliotecas C adicionais. Este recurso está disponível sob o recurso `unstable-locales`:

```rust
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 11, 28, 12, 0, 9).unwrap();
assert_eq!(dt.format("%Y-%m-%d %H:%M:%S").to_string(), "2014-11-28 12:00:09");
assert_eq!(dt.format_localized("%A %e %B %Y, %T", Locale::fr_BE).to_string(), 
           "vendredi 28 novembre 2014, 12:00:09");
```

A análise pode ser feita de duas maneiras:

1. O trait padrão `FromStr` (e o método `parse` em strings) pode ser usado para analisar valores `DateTime<FixedOffset>`, `DateTime<Utc>` e `DateTime<Local>`.
2. `DateTime::parse_from_str` analisa uma data e hora com um deslocamento e retorna `DateTime<FixedOffset>`.

```rust
use chrono::prelude::*;

let dt = "2014-11-28T12:00:09Z".parse::<DateTime<Utc>>().unwrap();
let fixed_dt = DateTime::parse_from_str("2014-11-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z").unwrap();
```

### Conversão com Timestamps EPOCH

Use `DateTime::from_timestamp(seconds, nanoseconds)` para construir um `DateTime<Utc>` a partir de um timestamp UNIX.

Use `DateTime.timestamp` para obter o timestamp (em segundos) de um `DateTime`. Além disso, você pode usar `DateTime.timestamp_subsec_nanos` para obter a contagem adicional de nanossegundos.

```rust
use chrono::{DateTime, Utc};

// Construir datetime a partir da epoch:
let dt: DateTime<Utc> = DateTime::from_timestamp(1_500_000_000, 0).unwrap();
assert_eq!(dt.to_rfc2822(), "Fri, 14 Jul 2017 02:40:00 +0000");

// Obter valor da epoch a partir de datetime:
let dt = DateTime::parse_from_rfc2822("Fri, 14 Jul 2017 02:40:00 +0000").unwrap();
assert_eq!(dt.timestamp(), 1_500_000_000);
```

## Limitações

- Apenas o calendário gregoriano proleptico é suportado (ou seja, estendido para suportar datas anteriores).
- Tipos de data são limitados a aproximadamente ±262.000 anos a partir da era comum.
- Tipos de tempo são limitados à precisão de nanossegundos.
- Segundos bissextos podem ser representados, mas o Chrono não os suporta completamente.
{/* 本行由工具自动生成,原文哈希值:67733bfd2ba618b44f19c1449b096c42 */}