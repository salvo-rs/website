# Soporte para HTTP/3

Salvo proporciona soporte para HTTP/3, que puede habilitarse mediante la funcionalidad `quinn`. HTTP/3, basado en el protocolo QUIC, ofrece menor latencia y mejor rendimiento en comparación con HTTP/1.1 y HTTP/2 tradicionales, especialmente en entornos de red inestables.

## Habilitar soporte para HTTP/3

Para habilitar el soporte de HTTP/3 en Salvo, debes activar la funcionalidad `quinn` en el archivo `Cargo.toml`:

```toml
salvo = { workspace = true, features = ["quinn"] }
```

## Casos de uso de HTTP/3

HTTP/3 es especialmente adecuado para los siguientes escenarios:

- Aplicaciones en dispositivos móviles y entornos de red inestables
- Aplicaciones en tiempo real que requieren baja latencia
- Escenarios de descarga paralela de múltiples archivos pequeños
- Aplicaciones que necesitan migración de conexión (por ejemplo, cambiar de WiFi a red celular sin interrupción)

## Código de ejemplo

A continuación se muestra un ejemplo simple de servidor HTTP/3 que soporta tanto HTTP/3 (QUIC) como HTTPS (TCP):

```rust
use salvo::conn::rustls::{Keycert, RustlsConfig};
use salvo::prelude::*;

// Función manejadora que responde "Hello World"
#[handler]
async fn hello() -> &'static str {
    "Hello World"
}

#[tokio::main]
async fn main() {
    // Inicializar el sistema de registro
    tracing_subscriber::fmt().init();

    // Cargar certificado TLS y clave privada desde archivos PEM embebidos
    let cert = include_bytes!("../certs/cert.pem").to_vec();
    let key = include_bytes!("../certs/key.pem").to_vec();

    // Crear enrutador y añadir un endpoint
    let router = Router::new().get(hello);

    // Configurar TLS usando Rustls
    let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

    // Crear listener TCP con cifrado TLS en el puerto 5800
    let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());

    // Crear listener QUIC y combinarlo con el listener TCP
    let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 5800))
        .join(listener)
        .bind()
        .await;

    // Iniciar servidor que soporta HTTP/3 (QUIC) y HTTPS (TCP)
    Server::new(acceptor).serve(router).await;
}
```

## Análisis del código clave

### Configuración TLS

```rust
// Configurar TLS usando Rustls
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));
```

Dado que HTTP/3 se basa en el protocolo QUIC, que requiere TLS 1.3 para cifrado, es necesario configurar certificados y claves TLS. En Salvo, utilizamos `RustlsConfig` para configurar TLS.

### Combinación de listeners

```rust
// Crear listener TCP con cifrado TLS
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());

// Crear listener QUIC y combinarlo con el listener TCP
let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;
```

Este código es la parte central del manejo de HTTP/3 en Salvo. Primero crea un listener TCP con soporte TLS (para HTTP/1.1 y HTTP/2), luego crea un listener QUIC (para HTTP/3). El método `join` combina ambos listeners, permitiendo al servidor manejar solicitudes de diferentes protocolos simultáneamente.

## Ejecutar el ejemplo

Para ejecutar este ejemplo, necesitas certificados TLS y claves privadas válidas. En entornos de desarrollo, puedes usar certificados autofirmados. El código completo del ejemplo está disponible en el [repositorio de GitHub de Salvo](https://github.com/salvo-rs/salvo/tree/main/examples/hello-h3).

Es importante notar que muchos clientes aún no soportan completamente HTTP/3, por lo que es necesario que este servidor soporte tanto HTTP/3 como HTTPS.

## Consideraciones importantes

1. HTTP/3 requiere soporte para TLS 1.3, por lo que deben configurarse certificados y claves válidos.
2. Los clientes necesitan soportar el protocolo HTTP/3 para aprovechar esta funcionalidad; de lo contrario, se revertirá a HTTP/1.1 o HTTP/2.
3. En entornos de producción, deben usarse certificados emitidos por una Autoridad Certificadora reconocida, no certificados autofirmados.
{/* Auto generated, origin file hash:b4abbc723f2cb070d8584564bf96ce8a */}