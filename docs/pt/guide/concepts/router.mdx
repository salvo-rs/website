# Router

## O que é Roteamento

[`Router`](https://docs.rs/salvo_core/latest/salvo_core/routing/struct.Router.html) define quais middlewares e `Handler`s processarão uma requisição HTTP. Esta é a funcionalidade mais fundamental e central no Salvo.

Internamente, um `Router` é composto por uma série de filtros (Filters). Quando uma requisição chega, o roteador testa, na ordem de adição, de cima para baixo, se ele mesmo e seus descendentes podem corresponder à requisição. Se a correspondência for bem-sucedida, os middlewares em toda a cadeia formada pelo roteador e seus descendentes são executados sequencialmente. Se durante o processamento o status do `Response` for definido como erro (4XX, 5XX) ou redirecionamento (3XX), os middlewares e `Handler`s subsequentes serão ignorados. Você também pode chamar manualmente `ctrl.skip_rest()` para ignorar os middlewares e `Handler`s seguintes.

Durante o processo de correspondência, existe uma informação de caminho da URL, que pode ser vista como um objeto que precisa ser completamente consumido pelos Filtros durante a correspondência. Se todos os Filtros em um determinado Router corresponderem com sucesso e essa informação de caminho da URL tiver sido completamente consumida, considera-se uma "correspondência bem-sucedida".

Por exemplo:

```rust
Router::with_path("articles").get(list_articles).post(create_article);
```

É funcionalmente equivalente a:

```rust
Router::new()
    // O PathFilter pode filtrar o caminho da requisição. Só corresponde com sucesso se o caminho contiver o segmento "articles",
    // caso contrário, a correspondência falha. Ex: /articles/123 tem correspondência bem-sucedida, enquanto /articles_list/123
    // contém "articles", mas como há _list depois, a correspondência falha.
    .filter(PathFilter::new("articles"))

    // Se o root corresponder com sucesso e o método da requisição for GET, o roteador filho interno corresponderá com sucesso,
    // e a requisição será tratada por list_articles.
    .push(Router::new().filter(filters::get()).handle(list_articles))

    // Se o root corresponder com sucesso e o método da requisição for POST, o roteador filho interno corresponderá com sucesso,
    // e a requisição será tratada por create_article.
    .push(Router::new().filter(filters::post()).handle(create_article));
```

Se acessar `GET /articles/`, considera-se correspondência bem-sucedida e executa `list_articles`. No entanto, se acessar `GET /articles/123`, a correspondência do roteador falha e retorna um erro 404, porque `Router::with_path("articles")` consumiu apenas `/articles` da informação do caminho da URL, restando `/123` não consumido, portanto a correspondência falha. Para conseguir corresponder com sucesso, o roteador pode ser alterado para:

```rust
Router::with_path("articles/{**}").get(list_articles).post(create_article);
```

Aqui, `{**}` corresponderá a qualquer caminho excedente, permitindo que `GET /articles/123` corresponda e execute `list_articles`.

## Definição Plana

Podemos definir rotas em um estilo plano:

```rust
Router::with_path("writers").get(list_writers).post(create_writer);
Router::with_path("writers/{id}").get(show_writer).patch(edit_writer).delete(delete_writer);
Router::with_path("writers/{id}/articles").get(list_writer_articles);
```

## Definição em Árvore

Também podemos definir rotas em uma estrutura de árvore, que é a forma recomendada:

```rust
Router::with_path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```
Esta forma de definição, para projetos complexos, torna a definição do Router clara, hierárquica e simples.

Muitos métodos em `Router` retornam a si mesmos (Self) após serem chamados, facilitando a escrita de código em cadeia. Às vezes, você precisa decidir como rotear com base em certas condições. O sistema de roteamento também fornece a função `then`, que é fácil de usar:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::with_path("{id}").get(show_article))
            .then(|router|{
                if admin_mode() {
                    router.post(create_article).push(
                        Router::with_path("{id}").patch(update_article).delete(delete_writer)
                    )
                } else {
                    router
                }
            }),
    );
```
Este exemplo significa que as rotas para criar, editar e excluir artigos só serão adicionadas quando o servidor estiver em `admin_mode`.

## Obtendo Parâmetros da Rota

No código acima, `{id}` define um parâmetro. Podemos obter seu valor através da instância `Request`:

```rust
#[handler]
async fn show_writer(req: &mut Request) {
    let id = req.param::<i64>("id").unwrap();
}
```

`{id}` corresponde a um segmento no caminho. Normalmente, o `id` de um artigo é apenas um número. Nesse caso, podemos usar uma expressão regular para restringir a regra de correspondência de `id`, como `r"{id|\d+}"`.

Para este tipo numérico, há um método mais simples usando `<id:num>`, com as seguintes formas específicas:
- `{id:num}`: corresponde a qualquer número de caracteres numéricos;
- `{id:num[10]}`: corresponde apenas a uma quantidade específica fixa de caracteres numéricos, onde 10 significa que corresponde exatamente a 10 caracteres numéricos;
- `{id:num(..10)}`: corresponde de 1 a 9 caracteres numéricos;
- `{id:num(3..10)}`: corresponde de 3 a 9 caracteres numéricos;
- `{id:num(..=10)}`: corresponde de 1 a 10 caracteres numéricos;
- `{id:num(3..=10)}`: corresponde de 3 a 10 caracteres numéricos;
- `{id:num(10..)}`: corresponde a pelo menos 10 caracteres numéricos.

Também é possível corresponder a todos os segmentos de caminho restantes através de `{**}`, `{*+}` ou `{*?}`. Para melhor legibilidade do código, também podemos adicionar nomes apropriados para tornar a semântica do caminho mais clara, por exemplo: `{**file_path}`.

- `{**}`: significa que a parte correspondente ao curinga pode ser uma string vazia. Por exemplo, o caminho `/files/{**rest_path}` corresponderá a `/files`, `/files/abc.txt`, `/files/dir/abc.txt`;
- `{*+}`: significa que a parte correspondente ao curinga deve existir e não pode corresponder a uma string vazia. Por exemplo, o caminho `/files/{*+rest_path}` não corresponderá a `/files`, mas corresponderá a `/files/abc.txt`, `/files/dir/abc.txt`;
- `{*?}`: significa que a parte correspondente ao curinga pode ser uma string vazia, mas só pode conter um segmento de caminho. Por exemplo, o caminho `/files/{*？rest_path}` não corresponderá a `/files/dir/abc.txt`, mas corresponderá a `/files`, `/files/abc.txt`;

É permitido combinar várias expressões para corresponder ao mesmo segmento de caminho, por exemplo `/articles/article_{id:num}/`, `/images/{name}.{ext}`.

## Adicionando Middleware

Podemos adicionar middleware através da função `hoop` no roteador:

```rust
Router::new()
    .hoop(check_authed)
    .path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```

Neste exemplo, o roteador raiz usa `check_authed` para verificar se o usuário atual já fez login. Todos os roteadores descendentes serão afetados por este middleware.

Se os usuários apenas desejam visualizar informações e artigos do `writer`, preferimos que possam navegar sem fazer login. Podemos definir as rotas assim:

```rust
Router::new()
    .push(
        Router::new()
            .hoop(check_authed)
            .path("writers")
            .post(create_writer)
            .push(Router::with_path("{id}").patch(edit_writer).delete(delete_writer)),
    )
    .push(
        Router::with_path("writers").get(list_writers).push(
            Router::with_path("{id}")
                .get(show_writer)
                .push(Router::with_path("articles").get(list_writer_articles)),
        ),
    );
```

Embora duas rotas tenham a mesma definição de caminho `path("articles")`, elas ainda podem ser adicionadas ao mesmo roteador pai.

## Filtros

Internamente, o `Router` determina se uma rota corresponde através de filtros. Os filtros suportam operações lógicas básicas usando `or` ou `and`. Uma rota pode conter vários filtros; quando todos os filtros correspondem com sucesso, a rota corresponde com sucesso.

A informação de caminho de um site é uma estrutura em árvore, mas essa estrutura não é equivalente à estrutura em árvore usada para organizar as rotas. Um caminho do site pode corresponder a vários nós de rota. Por exemplo, sob o caminho `articles/`, alguns conteúdos exigem login para visualização, enquanto outros não. Podemos organizar os subcaminhos que exigem login em um roteador que inclui middleware de verificação de login. Os que não exigem verificação de login podem ser organizados em outro roteador sem essa verificação:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::with_path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

O roteamento usa filtros para filtrar requisições e enviá-las para os middlewares e `Handler`s correspondentes para processamento.

`path` e `method` são dois dos filtros mais comuns. `path` é usado para corresponder à informação do caminho; `method` é usado para corresponder ao Método da requisição, como: GET, POST, PATCH, etc.

Podemos usar `and`, `or` para conectar filtros do roteador:

```rust
Router::with_filter(filters::path("hello").and(filters::get()));
```

### Filtro de Caminho

Filtros baseados no caminho da requisição são os mais usados. Filtros de caminho podem definir parâmetros, por exemplo:

```rust
Router::with_path("articles/{id}").get(show_article);
Router::with_path("files/{**rest_path}").get(serve_file)
```

No `Handler`, podemos obter através da função `get_param` do objeto `Request`:

```rust
#[handler]
pub async fn show_article(req: &mut Request) {
    let article_id = req.param::<i64>("id");
}

#[handler]
pub async fn serve_file(req: &mut Request) {
    let rest_path = req.param::<i64>("rest_path");
}
```

### Filtro de Método

Filtra requisições com base no `Method` da requisição `HTTP`, por exemplo:

```rust
Router::new().get(show_article).patch(update_article).delete(delete_article);
```

Aqui, `get`, `patch`, `delete` são todos filtros de Método. É funcionalmente equivalente a:

```rust
use salvo::routing::filter;

let mut root_router = Router::new();
let show_router = Router::with_filter(filters::get()).handle(show_article);
let update_router = Router::with_filter(filters::patch()).handle(update_article);
let delete_router = Router::with_filter(filters::get()).handle(delete_article);
Router::new().push(show_router).push(update_router).push(delete_router);
```

## Wisp Personalizado

Para certas expressões de correspondência que aparecem frequentemente, podemos nomear uma forma abreviada através de `PathFilter::register_wisp_regex` ou `PathFilter::register_wisp_builder`. Por exemplo, o formato GUID aparece frequentemente em caminhos. A forma normal seria escrever assim sempre que precisar corresponder:

```rust
Router::with_path("/articles/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
Router::with_path("/users/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
```

Escrever essa expressão regular complexa toda vez é propenso a erros e o código fica menos legível. Podemos fazer assim:

```rust
use salvo::routing::filter::PathFilter;

#[tokio::main]
async fn main() {
    let guid = regex::Regex::new("[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}").unwrap();
    PathFilter::register_wisp_regex("guid", guid);
    Router::new()
        .push(Router::with_path("/articles/{id:guid}").get(show_article))
        .push(Router::with_path("/users/{id:guid}").get(show_user));
}
```

Basta registrar uma vez, e depois podemos usar diretamente a forma simples `{id:guid}` para corresponder a GUIDs, simplificando a escrita do código.

## Como entender o Router vindo de frameworks web baseados em Controller?
As principais diferenças entre frameworks web baseados em roteamento (como Salvo) e frameworks tradicionais baseados em MVC ou Controller são:

- **Flexibilidade**: O design baseado em roteamento permite definir o fluxo de processamento da requisição de forma mais flexível, podendo controlar com precisão a lógica de processamento de cada caminho. Por exemplo, no Salvo você pode definir diretamente a função de processamento para um caminho específico:
  ```rust
  Router::with_path("articles").get(list_articles).post(create_article);
  ```
  Enquanto no design baseado em Controller, geralmente é necessário primeiro definir uma classe controladora e, dentro dela, definir vários métodos para lidar com diferentes requisições:
  ```java
  @Controller
  public class ArticleController {
      @GetMapping("/articles")
      public List<Article> listArticles() { /* ... */ }
      
      @PostMapping("/articles")
      public Article createArticle(@RequestBody Article article) { /* ... */ }
  }
  ```

- **Integração de Middleware**: Frameworks de roteamento geralmente fornecem formas mais concisas de integrar middleware, podendo aplicar middleware a rotas específicas. O middleware do Salvo pode ser aplicado com precisão a rotas específicas:
  ```rust
  Router::new()
      .push(
          Router::with_path("admin/articles")
              .hoop(admin_auth_middleware)  // Aplica middleware de autenticação apenas à rota de admin
              .get(list_all_articles)
              .post(create_article),
      )
      .push(
          Router::with_path("articles")  // Rota pública não requer autenticação
              .get(list_public_articles),
      );
  ```

- **Organização do Código**: O design baseado em roteamento tende a organizar o código com base na funcionalidade ou no endpoint da API, em vez de seguir a divisão em camadas Model-View-Controller do MVC.
  O design baseado em roteamento incentiva a organização do código de acordo com a funcionalidade do endpoint da API:
  ```rust
  // user_routes.rs - Rotas e lógica de processamento relacionadas ao usuário
  pub fn user_routes() -> Router {
      Router::with_path("users")
          .get(list_users)
          .post(create_user)
          .push(Router::with_path("{id}").get(get_user).delete(delete_user))
  }
  
  // article_routes.rs - Rotas e lógica de processamento relacionadas a artigos
  pub fn article_routes() -> Router {
      Router::with_path("articles")
          .get(list_articles)
          .post(create_article)
  }
  
  // Combinando rotas na aplicação principal
  let router = Router::new()
      .push(user_routes())
      .push(article_routes());
  ```

- **Leveza**: Geralmente, o design baseado em roteamento é mais leve, reduzindo conceitos e restrições impostos pelo framework. Você pode introduzir apenas os componentes
{/* 本行由工具自动生成,原文哈希值:ba0a1eadc077c274134c7a533d887f99 */}