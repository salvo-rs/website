# Prise en charge d'HTTP/3

Salvo offre une prise en charge d'HTTP/3, qui peut être activée via la fonctionnalité `quinn`. HTTP/3, basé sur le protocole QUIC, offre une latence réduite et de meilleures performances par rapport aux protocoles HTTP/1.1 et HTTP/2 traditionnels, en particulier dans des environnements réseau instables.

## Activer la prise en charge d'HTTP/3

Pour activer la prise en charge d'HTTP/3 dans Salvo, vous devez activer la fonctionnalité `quinn` dans le fichier `Cargo.toml` :

```toml
salvo = { workspace = true, features = ["quinn"] }
```

## Cas d'utilisation d'HTTP/3

HTTP/3 est particulièrement adapté aux scénarios suivants :

- Applications mobiles et environnements réseau instables
- Applications en temps réel nécessitant une faible latence
- Téléchargements parallèles de nombreux petits fichiers
- Applications nécessitant une migration de connexion (par exemple, passage du WiFi au réseau cellulaire sans interruption)

## Exemple de code

Voici un exemple simple de serveur HTTP/3 prenant en charge à la fois HTTP/3 (QUIC) et HTTPS (TCP) :

```rust
use salvo::conn::rustls::{Keycert, RustlsConfig};
use salvo::prelude::*;

// Fonction de gestion répondant "Hello World"
#[handler]
async fn hello() -> &'static str {
    "Hello World"
}

#[tokio::main]
async fn main() {
    // Initialisation du système de journalisation
    tracing_subscriber::fmt().init();

    // Chargement du certificat TLS et de la clé privée depuis des fichiers PEM intégrés
    let cert = include_bytes!("../certs/cert.pem").to_vec();
    let key = include_bytes!("../certs/key.pem").to_vec();

    // Création du routeur avec un point de terminaison
    let router = Router::new().get(hello);

    // Configuration TLS avec Rustls
    let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

    // Création d'un écouteur TCP avec chiffrement TLS sur le port 5800
    let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());

    // Création d'un écouteur QUIC combiné avec l'écouteur TCP
    let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 5800))
        .join(listener)
        .bind()
        .await;

    // Démarrage du serveur prenant en charge HTTP/3 (QUIC) et HTTPS (TCP)
    Server::new(acceptor).serve(router).await;
}
```

## Analyse du code clé

### Configuration TLS

```rust
// Configuration TLS avec Rustls
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));
```

HTTP/3 étant basé sur le protocole QUIC, qui nécessite TLS 1.3 pour le chiffrement, une configuration de certificat et de clé TLS est requise. Dans Salvo, nous utilisons `RustlsConfig` pour configurer TLS.

### Combinaison des écouteurs

```rust
// Création d'un écouteur TCP avec chiffrement TLS
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());

// Création d'un écouteur QUIC combiné avec l'écouteur TCP
let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;
```

Ce code constitue la partie centrale de la gestion d'HTTP/3 dans Salvo. Il crée d'abord un écouteur TCP avec TLS (pour HTTP/1.1 et HTTP/2), puis un écouteur QUIC (pour HTTP/3). La méthode `join` combine ces deux écouteurs, permettant au serveur de traiter simultanément des requêtes utilisant différents protocoles.

## Exécution de l'exemple

Pour exécuter cet exemple, vous devez disposer d'un certificat TLS et d'une clé privée valides. En environnement de développement, un certificat auto-signé peut être utilisé. Le code complet de l'exemple est disponible dans le [dépôt GitHub de Salvo](https://github.com/salvo-rs/salvo/tree/main/examples/hello-h3).

Notez que de nombreux clients ne prennent pas encore entièrement en charge HTTP/3, il est donc essentiel que ce serveur prenne en charge à la fois HTTP/3 et HTTPS.

## Points à noter

1. HTTP/3 nécessite TLS 1.3, une configuration valide de certificat et de clé est donc obligatoire.
2. Les clients doivent prendre en charge le protocole HTTP/3 pour bénéficier de cette fonctionnalité, sinon ils reviendront à HTTP/1.1 ou HTTP/2.
3. En production, utilisez des certificats signés par une autorité de certification reconnue plutôt que des certificats auto-signés.
{/* 本行由工具自动生成,原文哈希值:b4abbc723f2cb070d8584564bf96ce8a */}