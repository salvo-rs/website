# Обработчик (Handler)

## Краткий обзор

Обработчик (Handler) — это ключевая концепция фреймворка Salvo, которую можно просто понимать как единицу обработки запросов. Он имеет два основных назначения:

1. **В качестве конечной точки (Endpoint)**: Объект, реализующий `Handler`, может быть помещён в систему маршрутизации в качестве конечной точки для обработки запросов. При использовании макроса `#[handler]` функция может напрямую использоваться как конечная точка; а при использовании макроса `#[endpoint]` она не только служит конечной точкой, но и может автоматически генерировать документацию OpenAPI (эта часть будет подробно рассмотрена в последующей документации).

2. **В качестве промежуточного ПО (Middleware)**: Тот же `Handler` также может использоваться как промежуточное ПО для обработки до или после того, как запрос достигнет конечной точки.

Процесс обработки запросов в Salvo можно рассматривать как "конвейер": запрос сначала проходит через серию промежуточных обработчиков (вертикальная обработка), а затем достигает соответствующей конечной точки (горизонтальная обработка). Как промежуточное ПО, так и конечные точки являются реализациями `Handler`, что обеспечивает согласованность и гибкость всей системы.

### Диаграмма потока Handler в Salvo

```mermaid
flowchart TD
    Client[Клиент] -->|Запрос| Request[HTTP-запрос]
    Request --> M1

    subgraph "Реализация Handler"
        M1[Промежуточное ПО для логирования] -->|Вертикальная обработка| M2[Промежуточное ПО для аутентификации] -->|Вертикальная обработка| M3[Другое бизнес-промежуточное ПО]
        M3 --> Router[Сопоставление маршрутов]

        Router -->|Горизонтальная обработка| E1["Конечная точка 1<br>#[handler]"]
        Router -->|Горизонтальная обработка| E2["Конечная точка 2<br>#[endpoint]"]
        Router -->|Горизонтальная обработка| E3["Конечная точка 3<br>Реализация трейта Handler"]
    end

    E1 --> Response[HTTP-ответ]
    E2 --> Response
    E3 --> Response
    Response --> Client

    classDef middleware fill:#afd,stroke:#4a4,stroke-width:2px;
    classDef endpoint fill:#bbf,stroke:#55a,stroke-width:2px;

    class M1,M2,M3 middleware;
    class E1,E2,E3 endpoint;
```

### Промежуточное ПО и модель луковицы (Onion Model)

Суть модели луковицы заключается в том, что с помощью позиционирования вызова `ctrl.call_next()` до и после основного кода реализуется двунаправленный процесс обработки запроса и ответа, позволяя каждому промежуточному обработчику участвовать в полном цикле "запрос-ответ".
### Пример структуры полного промежуточного обработчика

```rust
async fn example_middleware(req: &mut Request, depot: &mut Depot,resp: &mut Response, ctrl: &mut FlowCtrl) {
    // Предварительная обработка (фаза запроса)
    // Здесь размещается логика, выполняемая при входе запроса

    // Вызов следующего обработчика в цепочке
    ctrl.call_next(req, depot,resp).await;

    // Последующая обработка (фаза ответа)
    // Здесь размещается логика, выполняемая после завершения обработки запроса
}
```

```mermaid
flowchart TB
    Client[Клиент] -->|Запрос| Request[HTTP-запрос]

    subgraph "Процесс обработки по модели луковицы"
        direction TB

        subgraph M1["Промежуточное ПО 1"]
            M1A["Предобработка<br>Логирование: начало запроса"] --> M1B["Постобработка<br>Логирование: конец запроса"]
        end

        subgraph M2["Промежуточное ПО 2"]
            M2A["Предобработка<br>Запись времени начала запроса"] --> M2B["Постобработка<br>Расчёт времени обработки"]
        end

        subgraph M3["Промежуточное ПО 3"]
            M3A["Предобработка<br>Проверка прав пользователя"] --> M3B["Постобработка<br>"]
        end

        subgraph Core["Основная логика обработки"]
            Handler["Обработчик конечной точки<br>#[handler]"]
        end

        Request --> M1A
        M1A --> M2A
        M2A --> M3A
        M3A --> Handler
        Handler --> M3B
        M3B --> M2B
        M2B --> M1B
        M1B --> Response
    end

    Response[HTTP-ответ] --> Client

    classDef middleware1 fill:#f9d,stroke:#333,stroke-width:2px;
    classDef middleware2 fill:#afd,stroke:#333,stroke-width:2px;
    classDef middleware3 fill:#bbf,stroke:#333,stroke-width:2px;
    classDef core fill:#fd7,stroke:#333,stroke-width:2px;

    class M1A,M1B middleware1;
    class M2A,M2B middleware2;
    class M3A,M3B middleware3;
    class Handler core;
```

## Что такое Handler

Handler — это конкретный объект, отвечающий за обработку Request-запросов. Сам Handler является трейтом (Trait), содержащим внутри асинхронный метод `handle`:

```rust
#[async_trait]
pub trait Handler: Send + Sync + 'static {
    async fn handle(&self, req: &mut Request, depot: &mut Depot, res: &mut Response);
}
```

Сигнатура функции обработки `handle` по умолчанию включает четыре параметра, идущих в следующем порядке: `&mut Request, &mut Depot. &mut Response, &mut FlowCtrl`. Depot — это временное хранилище, которое может содержать данные, связанные с текущим запросом.

В зависимости от способа использования, Handler может применяться как промежуточное ПО (hoop), которое может выполнять некоторые действия до или после того, как запрос достигнет основного `Handler`, обрабатывающего запрос. Например: проверка входа в систему, сжатие данных и т.д.

Промежуточное ПО добавляется с помощью функции `hoop` у `Router`. Добавленное промежуточное ПО влияет на текущий `Router` и все его дочерние `Router`.

`Handler` также может использоваться как `Handler`, участвующий в сопоставлении маршрутов и выполняемый в конечном итоге, называемый `goal`.

## `Handler` в качестве промежуточного ПО (hoop)

Когда `Handler` используется как промежуточное ПО, его можно добавить к следующим трём типам объектов, поддерживающих промежуточное ПО:

- `Service`: Любой запрос будет проходить через промежуточное ПО в `Service`.

- `Router`: Только при успешном сопоставлении маршрута запрос последовательно проходит через промежуточное ПО, определённое в `Service`, и все промежуточные обработчики, собранные на пути сопоставления.

- `Catcher`: При возникновении ошибки и отсутствии записи пользовательской информации об ошибке запрос пройдёт через промежуточное ПО в `Catcher`.

- `Handler`: Сам `Handler` поддерживает добавление промежуточного ПО для обёртки, выполняющей некоторую предварительную или последующую логику.

## Использование макроса `#[handler]`

`#[handler]` может значительно упростить написание кода и повысить его гибкость.

Его можно добавить к функции, заставив её реализовать `Handler`:

```rust
#[handler]
async fn hello() -> &'static str {
    "hello world!"
}
```

Это эквивалентно:

```rust
struct hello;

#[async_trait]
impl Handler for hello {
    async fn handle(&self, _req: &mut Request, _depot: &mut Depot, res: &mut Response, _ctrl: &mut FlowCtrl) {
        res.render(Text::Plain("hello world!"));
    }
}
```

Как видно, при использовании `#[handler]` код становится намного проще:

- Больше не требуется вручную добавлять `#[async_trait]`.
- Неиспользуемые параметры в функции опущены, а необходимые параметры могут располагаться в любом порядке.
- Для объектов, реализующих абстракцию `Writer` или `Scribe`, они могут напрямую возвращаться как результат функции. Здесь `&'static str` реализует `Scribe`, поэтому может быть напрямую возвращён как результат функции.

`#[handler]` можно применять не только к функциям, но и к блоку `impl` для `struct`, заставляя `struct` реализовать `Handler`. В этом случае функция `handle` внутри блока кода `impl` будет распознана как конкретная реализация метода `handle` в `Handler`:

```rust
struct Hello;

#[handler]
impl Hello {
    async fn handle(&self, res: &mut Response) {
        res.render(Text::Plain("hello world!"));
    }
}
```

## Обработка ошибок

`Handler` в Salvo может возвращать `Result`, при условии, что типы `Ok` и `Err` внутри `Result` реализуют трейт `Writer`.
Учитывая широкое использование anyhow, при включении функции `anyhow`, `anyhow::Error` будет реализовывать трейт `Writer`. `anyhow::Error` будет отображаться как `InternalServerError`.

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Для пользовательских типов ошибок вы можете выводить различные страницы ошибок в соответствии с потребностями.

```rust
use salvo::anyhow;
use salvo::prelude::*;

struct CustomError;
#[async_trait]
impl Writer for CustomError {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.status_code(StatusCode::INTERNAL_SERVER_ERROR);
        res.render("custom error");
    }
}

#[handler]
async fn handle_anyhow() -> Result<(), anyhow::Error> {
    Err(anyhow::anyhow!("anyhow error"))
}
#[handler]
async fn handle_custom() -> Result<(), CustomError> {
    Err(CustomError)
}

#[tokio::main]
async fn main() {
    let router = Router::new()
        .push(Router::new().path("anyhow").get(handle_anyhow))
        .push(Router::new().path("custom").get(handle_custom));
    let acceptor = TcpListener::new("127.0.0.1:5800").bind().await;
    Server::new(acceptor).serve(router).await;
}
```

## Прямая реализация трейта Handler

```rust
use salvo_core::prelude::*;
use crate::salvo_core::http::Body;

pub struct MaxSizeHandler(u64);
#[async_trait]
impl Handler for MaxSizeHandler {
    async fn handle(&self, req: &mut Request, depot: &mut Depot, res: &mut Response, ctrl: &mut FlowCtrl) {
        if let Some(upper) = req.body().and_then(|body| body.size_hint().upper()) {
            if upper > self.0 {
                res.render(StatusError::payload_too_large());
                ctrl.skip_rest();
            } else {
                ctrl.call_next(req, depot, res).await;
            }
        }
    }
}
```
{/* 本行由工具自动生成,原文哈希值:aba76a058ee7c27a6a982876209eae78 */}