# Per padroneggiare quest'arte

## Perché scrivere questo framework

All'epoca, essendo un principiante, mi resi conto di essere troppo inesperto per imparare a utilizzare framework esistenti come actix-web e Rocket. Quando decisi di reimplementare in Rust un mio precedente servizio web scritto in Go, a prima vista ogni framework sembrava più complesso di quelli disponibili in Go. Dal momento che la curva di apprendimento di Rust è già piuttosto ripida, perché complicare ulteriormente le cose con un framework web troppo intricato?

Quando Tokio presentò il framework Axum, fui felice pensando che non avrei più dovuto mantenere un mio framework web personale. Tuttavia, la realtà si rivelò diversa: Axum, sebbene apparentemente semplice, richiedeva durante l'uso eccessive acrobazie con i tipi e definizioni generiche. Per implementare anche un semplice middleware, era necessaria una profonda conoscenza di Rust e la pazienza di scrivere grandi quantità di codice template oscuro e difficile da comprendere.

Pertanto, decisi di continuare a mantenere il mio framework web, che considero piuttosto unico (pratico, ricco di funzionalità e adatto ai principianti).

## Salvo è adatto a te?

Sebbene Salvo sia semplice, offre funzionalità complete e potenti, tanto da poter essere considerato uno dei più solidi nell'ecosistema Rust. Eppure, nonostante la sua potenza, impararlo e utilizzarlo è estremamente facile. Non proverai assolutamente la sofferenza di dover "tagliare via parti di te stesso" per usarlo.

- È adatto a chi sta muovendo i primi passi con Rust. Operazioni CRUD sono estremamente comuni e di uso frequente. Utilizzando Salvo per compiti simili, scoprirai che è semplice come i framework web che hai usato in altri linguaggi (ad esempio: Express, Koa, Gin, Flask...), e in alcuni aspetti è persino più astratto e conciso.

- È adatto a chi desidera utilizzare Rust in ambienti di produzione, fornendo server robusti e veloci. Sebbene Salvo non abbia ancora raggiunto la versione 1.0, le sue funzionalità core sono state affinate attraverso anni di iterazioni, sono sufficientemente stabili e gli eventuali problemi vengono risolti tempestivamente.

- È adatto a te, che hai già perso molti capelli e ne perdi ancora ogni giorno.

## Come raggiunge una tale semplicità

Hyper ha già implementato molte funzionalità di basso livello, quindi per le esigenze generali, basarsi su Hyper è una scelta solida. Lo stesso vale per Salvo. Le sue funzionalità core includono un sistema di routing potente e flessibile, insieme a molte funzioni comuni come Acme, OpenAPI, autenticazione JWT, ecc.

In Salvo, Handler e Middleware sono unificati. Un Middleware è un Handler. Vengono aggiunti a un Router attraverso il metodo `hoop` del routing. In sostanza, sia Middleware che Handler elaborano le richieste Request e possono scrivere dati nella Response. L'Handler riceve tre parametri: Request, Depot e Response, dove Depot viene utilizzato per memorizzare dati temporanei durante l'elaborazione della richiesta.

Per facilitare la scrittura, è possibile omettere alcuni parametri quando non sono necessari e ignorare l'ordine di inserimento dei parametri.

```rust
use salvo::prelude::*;

#[handler]
async fn hello_world(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {
    res.render("Hello world");
}
#[handler]
async fn hello_world(res: &mut Response) {
    res.render("Hello world");
}
```

Inoltre, l'API fornita dal sistema di routing è estremamente semplice, ma le sue funzionalità sono potenti. Per le esigenze d'uso normali, è sufficiente concentrarsi principalmente sul tipo `Router`.
Inoltre, se una struttura implementa i tratti (trait) rilevanti, Salvo può generare automaticamente documentazione OpenAPI ed estrarre parametri, gestire automaticamente diversi tipi di errore e restituire messaggi di errore user-friendly. Questo rende la scrittura di handler semplice e intuitiva come scrivere funzioni ordinarie. Nei tutorial successivi esploreremo queste funzionalità in dettaglio. Ecco un esempio:

```rust
#[endpoint(tags("messaggi log"))]
pub async fn create_message_log_handler(
    input: JsonBody<CreateOrUpdateMessageLog>,
    depot: &mut Depot,
) -> APPResult<Json<MessageLog>> {
    let db = utils::get_db(depot)?;
    let log = create_message_log(&input, db).await?;
    Ok(Json(log))
}
```

In questo esempio, `JsonBody<CreateOrUpdateMessageLog>` analizzerà automaticamente i dati JSON dal corpo della richiesta e li convertirà nel tipo `CreateOrUpdateMessageLog` (supporta anche più sorgenti dati e tipi annidati). Allo stesso tempo, la macro `#[endpoint]` genererà automaticamente la documentazione OpenAPI per questo endpoint, semplificando il codice per l'estrazione dei parametri e la gestione degli errori.

## Sistema di routing

Personalmente, ritengo che il sistema di routing sia diverso rispetto ad altri framework. I Router possono essere scritti in modo lineare o ad albero. Qui distinguiamo tra albero della logica di business e albero delle directory di accesso. L'albero della logica di business organizza la struttura dei router in base alle esigenze funzionali, formando un albero di router che non necessariamente coincide con l'albero delle directory di accesso.

Normalmente scriviamo le route in questo modo:

```rust
Router::new().path("articles").get(list_articles).post(create_article);
Router::new()
    .path("articles/{id}")
    .get(show_article)
    .patch(edit_article)
    .delete(delete_article);
```

Spesso, visualizzare un articolo e l'elenco degli articoli non richiede l'accesso dell'utente, mentre creare, modificare o eliminare articoli richiede autorizzazioni di autenticazione. Il sistema di routing annidato supportato da Salvo soddisfa bene questa esigenza. Possiamo raggruppare le route che non richiedono autenticazione:

```rust
Router::new()
    .path("articles")
    .get(list_articles)
    .push(Router::new().path("{id}").get(show_article));
```

Poi raggruppiamo le route che richiedono l'accesso dell'utente e utilizziamo un middleware appropriato per verificare l'autenticazione:
```rust
Router::new()
    .path("articles")
    .hoop(auth_check)
    .post(list_articles)
    .push(Router::new().path("{id}").patch(edit_article).delete(delete_article));
```

Sebbene entrambi i router abbiano lo stesso `path("articles")`, possono comunque essere aggiunti allo stesso router padre. Quindi il router finale avrà questa struttura:

```rust
Router::new()
    .push(
        Router::new()
            .path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::new()
            .path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

`{id}` corrisponde a un segmento del percorso. Normalmente l'`id` di un articolo è solo un numero, quindi possiamo utilizzare un'espressione regolare per limitare la regola di corrispondenza di `id`: `r"{id:/\d+/}"`.
{/* Auto generated, origin file hash:bd1fc4c816e814fa9f1d5c39301ad59a */}