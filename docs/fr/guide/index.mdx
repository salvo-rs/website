# Pour maîtriser cet art

## Pourquoi créer ce framework

À l'époque, en tant que débutant, je me suis rendu compte que j'étais trop limité pour apprendre à utiliser des frameworks existants comme actix-web ou Rocket. Lorsque j'ai voulu réécrire en Rust un service web que j'avais précédemment développé en Go, j'ai constaté qu'à première vue, chaque framework semblait plus complexe que ceux disponibles en Go. La courbe d'apprentissage de Rust étant déjà assez raide, pourquoi rendre les frameworks web encore plus compliqués ?

Lorsque Tokio a lancé le framework Axum, j'ai été ravi à l'idée de ne plus avoir à maintenir mon propre framework web. Cependant, j'ai rapidement réalisé qu'Axum, bien qu'apparemment simple, impliquait une gymnastique de types excessive et des définitions génériques complexes. Pour créer un simple middleware, il fallait une compréhension approfondie de Rust et la patience d'écrire de nombreuses lignes de code template obscures.

C'est pourquoi j'ai décidé de continuer à maintenir mon framework web, qui est plutôt unique (pratique, riche en fonctionnalités et adapté aux débutants).

## Salvo est-il fait pour vous ?

Bien que simple, Salvo est suffisamment complet et puissant pour être considéré comme l'un des plus robustes de l'écosystème Rust. Malgré sa puissance, son apprentissage et son utilisation restent extrêmement simples. Vous n'aurez certainement pas à souffrir inutilement.

- Il convient aux débutants qui apprennent Rust. Les opérations CRUD sont des fonctionnalités courantes et fréquemment utilisées. Avec Salvo, vous constaterez que ces tâches sont aussi simples qu'avec d'autres frameworks web dans d'autres langages (comme Express, Koa, Gin, Flask...), voire même plus abstraites et concises dans certains aspects.

- Il convient à ceux qui souhaitent utiliser Rust en production pour fournir des serveurs robustes et rapides. Bien que Salvo n'ait pas encore atteint la version 1.0, ses fonctionnalités principales ont été affinées au fil des années, garantissant une stabilité suffisante et des corrections de bugs rapides.

- Il convient à vous, dont les cheveux se font déjà rares mais continuent de tomber chaque jour.

## Comment atteindre une simplicité suffisante

De nombreuses implémentations de bas niveau sont déjà prises en charge par Hyper, ce qui en fait un choix judicieux pour la plupart des besoins. Salvo suit la même logique. Ses fonctionnalités principales incluent un système de routage puissant et flexible, ainsi que de nombreuses fonctionnalités courantes telles qu'Acme, OpenAPI, JWT Auth, etc.

Dans Salvo, les Handlers et les Middlewares sont unifiés. Un Middleware est simplement un Handler. Ils sont ajoutés au Router via la méthode `hoop`. Fondamentalement, les Middlewares et les Handlers traitent tous deux les requêtes Request et peuvent écrire des données dans la Response. Un Handler reçoit trois paramètres : Request, Depot et Response, où Depot est utilisé pour stocker des données temporaires pendant le traitement de la requête.

Pour faciliter l'écriture, il est possible d'omettre certains paramètres lorsqu'ils ne sont pas nécessaires, et l'ordre des paramètres peut être ignoré.

```rust
use salvo::prelude::*;

#[handler]
async fn hello_world(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {
    res.render("Hello world");
}
#[handler]
async fn hello_world(res: &mut Response) {
    res.render("Hello world");
}
```

De plus, l'API fournie par le système de routage est extrêmement simple, mais puissante. Pour la plupart des cas d'utilisation, il suffit de se concentrer sur le type Router.
En outre, si une structure implémente les traits appropriés, Salvo peut générer automatiquement une documentation OpenAPI, extraire les paramètres, gérer différentes erreurs et renvoyer des messages conviviaux. Cela rend l'écriture des handlers aussi simple et intuitive que celle de fonctions ordinaires. Dans les tutoriels suivants, nous expliquerons ces fonctionnalités en détail. Voici un exemple :

```rust

#[endpoint(tags("消息日志"))]
pub async fn create_message_log_handler(
    input: JsonBody<CreateOrUpdateMessageLog>,
    depot: &mut Depot,
) -> APPResult<Json<MessageLog>> {
    let db = utils::get_db(depot)?;
    let log = create_message_log(&input, db).await?;
    Ok(Json(log))
}
```

Dans cet exemple, `JsonBody<CreateOrUpdateMessageLog>` analyse automatiquement les données JSON du corps de la requête et les convertit en type `CreateOrUpdateMessageLog` (prise en charge de multiples sources de données et de types imbriqués). De plus, la macro `#[endpoint]` génère automatiquement la documentation OpenAPI pour cette interface, simplifiant ainsi l'extraction des paramètres et la gestion des erreurs.

## Système de routage

Je trouve que le système de routage est différent de celui des autres frameworks. Le Router peut être écrit de manière plate ou sous forme arborescente. Il distingue l'arbre logique métier de l'arbre d'accès aux répertoires. L'arbre logique métier organise la structure des routes en fonction des besoins métier, formant un arbre de routes qui ne correspond pas nécessairement à l'arbre d'accès aux répertoires.

Normalement, nous écrivons les routes de cette manière :

```rust
Router::new().path("articles").get(list_articles).post(create_article);
Router::new()
    .path("articles/{id}")
    .get(show_article)
    .patch(edit_article)
    .delete(delete_article);
```

Souvent, consulter la liste des articles ou un article spécifique ne nécessite pas de connexion utilisateur, tandis que créer, modifier ou supprimer un article requiert une authentification. Le système de routage imbriqué de Salvo répond parfaitement à ce besoin. Nous pouvons regrouper les routes qui ne nécessitent pas de connexion :

```rust
Router::new()
    .path("articles")
    .get(list_articles)
    .push(Router::new().path("{id}").get(show_article));
```

Ensuite, nous regroupons les routes qui nécessitent une connexion utilisateur et utilisons un middleware approprié pour vérifier l'authentification :

```rust
Router::new()
    .path("articles")
    .hoop(auth_check)
    .post(list_articles)
    .push(Router::new().path("{id}").patch(edit_article).delete(delete_article));
```

Bien que ces deux routes aient le même `path("articles")`, elles peuvent être ajoutées au même routeur parent. Ainsi, le routeur final ressemble à ceci :

```rust
Router::new()
    .push(
        Router::new()
            .path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::new()
            .path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

`{id}` correspond à un segment du chemin. Normalement, l'`id` d'un article n'est qu'un nombre. Nous pouvons utiliser une expression régulière pour restreindre les règles de correspondance de l'`id`, par exemple `r"{id:/\d+/}"`.
{/* 本行由工具自动生成,原文哈希值:bd1fc4c816e814fa9f1d5c39301ad59a */}