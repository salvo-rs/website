# Caching

Middleware, das Caching-Funktionalität bereitstellt.

Das Cache-Middleware kann `Response`-Inhalte wie `StatusCode`, `Headers` und `Body` zwischenspeichern. Bei bereits zwischengespeicherten Inhalten sendet das Cache-Middleware bei der nächsten Anfragebearbeitung direkt den im Arbeitsspeicher gepufferten Inhalt an den Client.

Hinweis: Dieses Plugin speichert keine `Response`-Objekte zwischen, deren `Body` vom Typ `ResBody::Stream` ist. Wenn es auf solche `Response`-Typen angewendet wird, verarbeitet Cache diese Anfragen nicht und löst auch keine Fehler aus.

## Hauptfunktionen

- `CacheIssuer` bietet eine Abstraktion für die Zuweisung von Cache-Schlüsseln. `RequestIssuer` ist eine Implementierung davon und kann definieren, welche Teile der Anfrage-URL und welche `Method` der Anfrage zur Generierung des Cache-Schlüssels verwendet werden. Sie können auch Ihre eigene Logik zur Generierung von Cache-Schlüsseln definieren. Der Cache-Schlüssel muss nicht unbedingt ein String sein; jeder Typ, der die Einschränkungen `Hash + Eq + Send + Sync + 'static` erfüllt, kann als Schlüssel dienen.

- `CacheStore` bietet Lese- und Schreiboperationen für Daten. `MokaStore` ist eine integrierte, auf `moka` basierende In-Memory-Cache-Implementierung. Sie können auch Ihre eigene Implementierung definieren.

- `Cache` ist eine Struktur, die `Handler` implementiert und intern ein `skipper`-Feld enthält, mit dem Anfragen angegeben werden können, die nicht zwischengespeichert werden sollen. Standardmäßig wird `MethodSkipper` verwendet, um alle Anfragen außer `Method::GET` zu überspringen.

  Beispielcode für die interne Implementierung:

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Schnelle Migration von anderen Frameworks

Wenn Sie zuvor Caching-Mechanismen anderer Frameworks verwendet haben, hilft Ihnen das folgende Konzept-Mapping, sich schneller an die Cache-Implementierung von Salvo zu gewöhnen:

### Migrationsleitfaden für Rust-Frameworks

- **Migration von Actix-web**: Plugins wie `actix-web-cache` in Actix-web müssen normalerweise separat eingebunden werden, während Caching in Salvo Teil der Kernbibliothek ist.

  ```rust
  // Actix-web Cache-Beispiel
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Entsprechende Salvo-Implementierung
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Migrationsleitfaden für Frameworks anderer Sprachen

- **Migration von Go/Gin**: Gin verwendet ein Middleware-Modell, Salvo verwendet einen ähnlichen Ansatz:

  ```go
  // Gin Cache-Beispiel
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Entsprechende Salvo-Implementierung
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Migration von Spring Boot**: Das deklarative Caching von Spring Boot muss in eine explizite Middleware-Konfiguration von Salvo umgewandelt werden:

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Entsprechende Salvo-Implementierung - Cache auf Routing-Ebene anwenden
  let custom_issuer = YourCustomIssuer::new(); // CacheIssuer-Interface implementieren
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Migration von Express.js**: Das Cache-Middleware von Express.js ist konzeptionell ähnlich zu Salvo, aber die Syntax ist unterschiedlich:

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Entsprechende Salvo-Implementierung
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

Bei der Migration von anderen Frameworks sind folgende Schlüsselkonzepte des Salvo-Cachings zu beachten:

1. **Cache-Schlüsselgenerierung** - Gesteuert über das `CacheIssuer`-Interface
2. **Cache-Speicher** - Implementiert über das `CacheStore`-Interface
3. **Cache-Überspringungslogik** - Angepasst über den `skipper`-Mechanismus

Standardmäßig speichert Salvo nur GET-Anfragen zwischen, was mit dem Standardverhalten der meisten Frameworks übereinstimmt.

_**Beispielcode**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* Auto generated, origin file hash:df2bc60555363c109d61ba033738ce41 */}