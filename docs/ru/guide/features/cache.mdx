# Кэширование

Промежуточное ПО, предоставляющее функциональность кэширования.

Промежуточное ПО Cache может кэшировать `StatusCode`, `Headers` и `Body` в `Response`. Для уже закэшированного контента, при обработке следующего запроса, промежуточное ПО Cache напрямую отправит клиенту содержимое, сохранённое в памяти.

Обратите внимание, что этот плагин не кэширует `Response`, у которого `Body` имеет тип `ResBody::Stream`. Если он применяется к такому типу `Response`, Cache не будет обрабатывать эти запросы, но и не вызовет ошибок.

## Основные функции

- `CacheIssuer` предоставляет абстракцию для генерации ключей кэша. `RequestIssuer` — одна из его реализаций, позволяющая определять генерацию ключа кэша на основе определённых частей URL запроса и его `Method`. Вы также можете определить свою собственную логику генерации ключей кэша. Ключ кэша не обязательно должен быть строкой — любой тип, удовлетворяющий ограничениям `Hash + Eq + Send + Sync + 'static`, может использоваться в качестве ключа.

- `CacheStore` предоставляет операции для сохранения и извлечения данных. `MokaStore` — это встроенная реализация кэша в памяти на основе `moka`. Вы также можете определить собственную реализацию.

- `Cache` — это структура, реализующая `Handler`, которая также содержит поле `skipper`, позволяющее указать, какие запросы следует пропускать без кэширования. По умолчанию используется `MethodSkipper`, который пропускает все запросы, кроме `Method::GET`.

  Пример внутренней реализации:

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Быстрая миграция с других фреймворков

Если вы ранее использовали механизмы кэширования в других фреймворках, следующее сопоставление концепций поможет вам быстрее адаптироваться к реализации кэширования в Salvo:

### Руководство по миграции с Rust-фреймворков

- **Миграция с Actix-web**: Плагины вроде `actix-web-cache` в Actix-web обычно требуют отдельного подключения, тогда как кэширование в Salvo является частью основной библиотеки.

  ```rust
  // Пример кэширования в Actix-web
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Соответствующая реализация в Salvo
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Руководство по миграции с фреймворков на других языках

- **Миграция с Go/Gin**: Gin использует паттерн промежуточного ПО, и Salvo также применяет аналогичный подход:

  ```go
  // Пример кэширования в Gin
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Соответствующая реализация в Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Миграция с Spring Boot**: Декларативное кэширование в Spring Boot необходимо преобразовать в явную конфигурацию промежуточного ПО в Salvo:

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Соответствующая реализация в Salvo - применение кэша на уровне маршрута
  let custom_issuer = YourCustomIssuer::new(); // Реализуем интерфейс CacheIssuer
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Миграция с Express.js**: Промежуточное ПО для кэширования в Express концептуально похоже на Salvo, но отличается синтаксисом:

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Соответствующая реализация в Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

При миграции с других фреймворков обратите внимание на несколько ключевых концепций кэширования в Salvo:

1. **Генерация ключа кэша** — управляется через интерфейс `CacheIssuer`.
2. **Хранилище кэша** — реализуется через интерфейс `CacheStore`.
3. **Логика пропуска кэширования** — настраивается через механизм `skipper`.

По умолчанию Salvo кэширует только GET-запросы, что согласуется с поведением большинства фреймворков.

_**Пример кода**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* 本行由工具自动生成,原文哈希值:df2bc60555363c109d61ba033738ce41 */}