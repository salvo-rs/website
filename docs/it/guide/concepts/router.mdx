# Router

## Cos'è il Router

[`Router`](https://docs.rs/salvo_core/latest/salvo_core/routing/struct.Router.html) definisce quali middleware e `Handler` elaboreranno una richiesta HTTP. Questa è la funzionalità più fondamentale e centrale in Salvo.

Internamente, `Router` è composto da una serie di filtri (Filter). Quando arriva una richiesta, il router testa in ordine, dall'alto verso il basso, se se stesso e i suoi discendenti possono corrispondere alla richiesta. Se la corrispondenza ha successo, vengono eseguiti in sequenza i middleware presenti nell'intera catena formata dal router e dai suoi discendenti. Se durante l'elaborazione lo stato della `Response` viene impostato su errore (4XX, 5XX) o reindirizzamento (3XX), i middleware e `Handler` successivi vengono saltati. Puoi anche chiamare manualmente `ctrl.skip_rest()` per saltare i middleware e `Handler` successivi.

Durante il processo di corrispondenza, esiste un'informazione sul percorso dell'URL, che può essere considerata un oggetto che deve essere completamente "consumato" dai Filter durante la corrispondenza. Se tutti i Filter in un determinato Router hanno successo nella corrispondenza e questa informazione sul percorso dell'URL è stata completamente consumata, allora si considera che la corrispondenza abbia "successo".

Ad esempio:

```rust
Router::with_path("articles").get(list_articles).post(create_article);
```

È effettivamente equivalente a:

```rust
Router::new()
    // PathFilter può filtrare il percorso della richiesta. La corrispondenza ha successo solo se il percorso della richiesta contiene il segmento "articles",
    // altrimenti fallisce. Ad esempio: /articles/123 ha successo, mentre /articles_list/123
    // sebbene contenga "articles", non ha successo perché è seguito da "_list".
    .filter(PathFilter::new("articles"))

    // Se il router root ha successo nella corrispondenza e il metodo della richiesta è GET, il router figlio interno può corrispondere con successo,
    // e la richiesta viene gestita da list_articles.
    .push(Router::new().filter(filters::get()).handle(list_articles))

    // Se il router root ha successo nella corrispondenza e il metodo della richiesta è POST, il router figlio interno può corrispondere con successo,
    // e la richiesta viene gestita da create_article.
    .push(Router::new().filter(filters::post()).handle(create_article));
```

Se si accede a `GET /articles/`, si considera la corrispondenza riuscita e viene eseguito `list_articles`. Tuttavia, se si accede a `GET /articles/123`, la corrispondenza del router fallisce e viene restituito un errore 404, perché `Router::with_path("articles")` ha consumato solo `/articles` dall'informazione sul percorso dell'URL, lasciando `/123` non consumato, quindi la corrispondenza fallisce. Per far sì che la corrispondenza abbia successo, il router può essere modificato in:

```rust
Router::with_path("articles/{**}").get(list_articles).post(create_article);
```

Qui `{**}` corrisponderà a qualsiasi percorso residuo, quindi potrà corrispondere a `GET /articles/123` ed eseguire `list_articles`.

## Definizione Piatta

Possiamo definire i router in uno stile piatto:

```rust
Router::with_path("writers").get(list_writers).post(create_writer);
Router::with_path("writers/{id}").get(show_writer).patch(edit_writer).delete(delete_writer);
Router::with_path("writers/{id}/articles").get(list_writer_articles);
```

## Definizione ad Albero

Possiamo anche definire i router in una struttura ad albero, che è il modo consigliato:

```rust
Router::with_path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```
Questa forma di definizione, per progetti complessi, rende la definizione dei Router chiara, semplice e gerarchica.

Molti metodi in `Router` restituiscono se stessi (Self) dopo essere stati chiamati, per facilitare la scrittura del codice in stile catena. A volte, è necessario decidere come instradare in base a determinate condizioni. Il sistema di routing fornisce anche la funzione `then`, facile da usare:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::with_path("{id}").get(show_article))
            .then(|router|{
                if admin_mode() {
                    router.post(create_article).push(
                        Router::with_path("{id}").patch(update_article).delete(delete_writer)
                    )
                } else {
                    router
                }
            }),
    );
```
Questo esempio indica che le route per creare, modificare ed eliminare articoli verranno aggiunte solo quando il server è in `admin_mode`.

## Ottenere Parametri dal Router

Nel codice sopra, `{id}` definisce un parametro. Possiamo ottenerne il valore tramite l'istanza `Request`:

```rust
#[handler]
async fn show_writer(req: &mut Request) {
    let id = req.param::<i64>("id").unwrap();
}
```

`{id}` corrisponde a un segmento nel percorso. Normalmente l'`id` di un articolo è solo un numero, quindi possiamo usare un'espressione regolare per limitare la regola di corrispondenza di `id`, `r"{id|\d+}"`.

Per questo tipo numerico, c'è un metodo più semplice usando `<id:num>`, con le seguenti scritture:
- `{id:num}`: corrisponde a qualsiasi numero di caratteri numerici;
- `{id:num[10]}`: corrisponde solo a un numero specifico di caratteri numerici, qui 10 significa che corrisponde esattamente a 10 caratteri numerici;
- `{id:num(..10)}`: corrisponde da 1 a 9 caratteri numerici;
- `{id:num(3..10)}`: corrisponde da 3 a 9 caratteri numerici;
- `{id:num(..=10)}`: corrisponde da 1 a 10 caratteri numerici;
- `{id:num(3..=10)}`: corrisponde da 3 a 10 caratteri numerici;
- `{id:num(10..)}`: corrisponde ad almeno 10 caratteri numerici.

È anche possibile corrispondere a tutti i segmenti di percorso rimanenti tramite `{**}`, `{*+}` o `{*?}`. Per una migliore leggibilità del codice, si può aggiungere un nome appropriato per rendere il percorso più chiaro semanticamente, ad esempio: `{**file_path}`.

- `{**}`: rappresenta una corrispondenza con wildcard che può essere una stringa vuota. Ad esempio, il percorso `/files/{**rest_path}` corrisponderà a `/files`, `/files/abc.txt`, `/files/dir/abc.txt`;
- `{*+}`: rappresenta una corrispondenza con wildcard che deve esistere, non può corrispondere a una stringa vuota. Ad esempio, il percorso `/files/{*+rest_path}` non corrisponderà a `/files` ma corrisponderà a `/files/abc.txt`, `/files/dir/abc.txt`;
- `{*?}`: rappresenta una corrispondenza con wildcard che può essere una stringa vuota, ma può contenere solo un segmento di percorso. Ad esempio, il percorso `/files/{*?rest_path}` non corrisponderà a `/files/dir/abc.txt` ma corrisponderà a `/files`, `/files/abc.txt`;

È consentito combinare più espressioni per corrispondere allo stesso segmento di percorso, ad esempio `/articles/article_{id:num}/`, `/images/{name}.{ext}`.

## Aggiungere Middleware

È possibile aggiungere middleware tramite la funzione `hoop` sul router:

```rust
Router::new()
    .hoop(check_authed)
    .path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```

In questo esempio, il router root utilizza `check_authed` per verificare se l'utente corrente ha effettuato l'accesso. Tutti i router discendenti saranno influenzati da questo middleware.

Se gli utenti vogliono solo visualizzare le informazioni sugli `writer` e gli articoli, preferiamo che possano farlo senza effettuare l'accesso. Possiamo definire il router in questo modo:

```rust
Router::new()
    .push(
        Router::new()
            .hoop(check_authed)
            .path("writers")
            .post(create_writer)
            .push(Router::with_path("{id}").patch(edit_writer).delete(delete_writer)),
    )
    .push(
        Router::with_path("writers").get(list_writers).push(
            Router::with_path("{id}")
                .get(show_writer)
                .push(Router::with_path("articles").get(list_writer_articles)),
        ),
    );
```

Nonostante due router abbiano la stessa definizione di percorso `path("articles")`, possono comunque essere aggiunti allo stesso router padre.

## Filtri

Internamente, `Router` determina se una corrispondenza ha successo attraverso i filtri. I filtri supportano operazioni logiche di base utilizzando `or` o `and`. Un router può contenere più filtri; quando tutti i filtri corrispondono con successo, la corrispondenza del router ha successo.

La struttura del percorso di un sito web è una struttura ad albero, ma questa struttura ad albero non è equivalente alla struttura ad albero organizzativa dei router. Un percorso del sito web può corrispondere a più nodi router. Ad esempio, alcuni contenuti sotto il percorso `articles/` richiedono l'accesso per essere visualizzati, mentre altri no. Possiamo organizzare i sottopercorsi che richiedono l'accesso sotto un router che contiene il middleware di verifica dell'accesso. Quelli che non richiedono la verifica dell'accesso possono essere organizzati sotto un altro router senza tale verifica:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::with_path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

Il router utilizza i filtri per filtrare le richieste e inviarle ai corrispondenti middleware e `Handler` per l'elaborazione.

`path` e `method` sono due dei filtri più comunemente utilizzati. `path` viene utilizzato per corrispondere alle informazioni sul percorso; `method` viene utilizzato per corrispondere al metodo della richiesta, ad esempio: GET, POST, PATCH, ecc.

Possiamo utilizzare `and`, `or` per collegare i filtri del router:

```rust
Router::with_filter(filters::path("hello").and(filters::get()));
```

### Filtri di Percorso

I filtri basati sul percorso della richiesta sono i più frequentemente utilizzati. Nei filtri di percorso è possibile definire parametri, ad esempio:

```rust
Router::with_path("articles/{id}").get(show_article);
Router::with_path("files/{**rest_path}").get(serve_file)
```

Nel `Handler`, è possibile ottenere i parametri tramite la funzione `get_param` dell'oggetto `Request`:

```rust
#[handler]
pub async fn show_article(req: &mut Request) {
    let article_id = req.param::<i64>("id");
}

#[handler]
pub async fn serve_file(req: &mut Request) {
    let rest_path = req.param::<i64>("rest_path");
}
```

### Filtri di Metodo

Filtrano le richieste in base al `Method` della richiesta `HTTP`, ad esempio:

```rust
Router::new().get(show_article).patch(update_article).delete(delete_article);
```

Qui `get`, `patch`, `delete` sono tutti filtri di metodo. Sono effettivamente equivalenti a:

```rust
use salvo::routing::filter;

let mut root_router = Router::new();
let show_router = Router::with_filter(filters::get()).handle(show_article);
let update_router = Router::with_filter(filters::patch()).handle(update_article);
let delete_router = Router::with_filter(filters::get()).handle(delete_article);
Router::new().push(show_router).push(update_router).push(delete_router);
```

## Wisp Personalizzati

Per alcune espressioni di corrispondenza che compaiono frequentemente, possiamo assegnare un nome breve tramite `PathFilter::register_wisp_regex` o `PathFilter::register_wisp_builder`. Ad esempio, il formato GUID appare spesso nei percorsi. Normalmente, ogni volta che è necessario effettuare una corrispondenza, si scrive così:

```rust
Router::with_path("/articles/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
Router::with_path("/users/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
```

Scrivere ogni volta questa complessa espressione regolare è soggetto a errori e rende il codice meno leggibile. Si può fare così:

```rust
use salvo::routing::filter::PathFilter;

#[tokio::main]
async fn main() {
    let guid = regex::Regex::new("[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}").unwrap();
    PathFilter::register_wisp_regex("guid", guid);
    Router::new()
        .push(Router::with_path("/articles/{id:guid}").get(show_article))
        .push(Router::with_path("/users/{id:guid}").get(show_user));
}
```

È sufficiente registrarlo una volta, dopodiché è possibile utilizzare la semplice scrittura `{id:guid}` per corrispondere ai GUID, semplificando la scrittura del codice.

## Come Comprendere il Router Provenendo da Framework Web di Tipo Controller?

Le principali differenze tra un framework web basato sulla progettazione del routing (come Salvo) e i framework tradizionali MVC o basati su Controller sono:

- **Flessibilità**: La progettazione del routing consente una definizione più flessibile del flusso di elaborazione delle richieste, permettendo un controllo preciso della logica di elaborazione per ogni percorso. Ad esempio, in Salvo puoi definire direttamente la funzione di gestione per un percorso specifico:
  ```rust
  Router::with_path("articles").get(list_articles).post(create_article);
  ```
  Nella progettazione basata su Controller, di solito è necessario definire prima una classe controller, quindi definire più metodi all'interno della classe per gestire diverse richieste:
  ```java
  @Controller
  public class ArticleController {
      @GetMapping("/articles")
      public List<Article> listArticles() { /* ... */ }
      
      @PostMapping("/articles")
      public Article createArticle(@RequestBody Article article) { /* ... */ }
  }
  ```

- **Integrazione Middleware**: I framework di routing di solito forniscono modi più semplici per integrare i middleware, applicandoli a route specifiche. I middleware di Salvo possono essere applicati con precisione a route specifiche:
  ```rust
  Router::new()
      .push(
          Router::with_path("admin/articles")
              .hoop(admin_auth_middleware)  // Applica il middleware di autenticazione solo alle route amministrative
              .get(list_all_articles)
              .post(create_article),
      )
      .push(
          Router::with_path("articles")  // Route pubbliche senza autenticazione
              .get(list_public_articles),
      );
  ```

- **Organizzazione del Codice**: La progettazione del routing tende a organizzare il codice in base alla funzionalità o all'endpoint API, piuttosto che secondo la stratificazione modello-vista-controller del MVC.
  La progettazione del routing incoraggia l'organizzazione del codice in base alla funzionalità dell'endpoint API:
  ```rust
  // user_routes.rs - Route e logica di gestione relative agli utenti
  pub fn user_routes() -> Router {
      Router::with_path("users")
          .get(list_users)
          .post(create_user)
          .push(Router::with_path("{id}").get(get_user).delete(delete_user))
  }
  
  // article_routes.rs - Route e logica di gestione relative agli articoli
  pub fn article_routes() -> Router {
      Router::with_path("articles")
          .get(list_articles)
          .post(create_article)
 
{/* 本行由工具自动生成,原文哈希值:ba0a1eadc077c274134c7a533d887f99 */}