import { Tab, Tabs } from '@rspress/core/theme';

# Генерация документации OpenAPI

OpenAPI — это открытая спецификация для описания интерфейсов RESTful API. Она определяет структуру запросов и ответов, параметры, типы возвращаемых данных, коды ошибок и другие детали API в форматах JSON или YAML, что делает взаимодействие между клиентом и сервером более чётким и стандартизированным.

Изначально OpenAPI был открытой версией спецификации Swagger, но теперь стал самостоятельным проектом, получив поддержку многих крупных компаний и разработчиков. Использование спецификации OpenAPI помогает командам разработчиков лучше взаимодействовать, снижает затраты на коммуникацию и повышает эффективность разработки. Кроме того, OpenAPI предоставляет инструменты для автоматической генерации документации API, мок-данных и тестовых случаев, что упрощает процессы разработки и тестирования.

Salvo предлагает интеграцию с OpenAPI (адаптировано из [utoipa](https://github.com/juhaku/utoipa)). Благодаря особенностям своей архитектуры, Salvo элегантно автоматически извлекает информацию о типах данных OpenAPI из `Handler`. Salvo также интегрирует несколько популярных открытых интерфейсов для OpenAPI, таких как SwaggerUI, scalar, rapidoc и redoc.

Учитывая, что имена типов в Rust могут быть длинными и не всегда подходят для использования в OpenAPI, `salvo-oapi` предоставляет тип `Namer`, который позволяет настраивать правила изменения имён типов в OpenAPI в соответствии с потребностями.

_**Пример кода**_

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/oapi-hello/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/oapi-hello/Cargo.toml"
  ```
  </Tab>
</Tabs>

Введя в браузере `http://localhost:5800/swagger-ui`, вы увидите страницу Swagger UI.

Интеграция OpenAPI в Salvo выполнена весьма элегантно. Для приведённого выше примера, по сравнению с обычным проектом Salvo, мы выполнили всего несколько шагов:

- Включили функцию `oapi` в `Cargo.toml`: `salvo = { workspace = true, features = ["oapi"] }`;

- Заменили `#[handler]` на `#[endpoint]`;

- Использовали `name: QueryParam<String, false>` для получения значения строки запроса. При обращении к URL `http://localhost/hello?name=chris` этот параметр `name` будет разобран. `false` в `QueryParam<String, false>` означает, что параметр является необязательным; даже при обращении к `http://localhost/hello` ошибки не возникнет. Напротив, `QueryParam<String, true>` означает, что параметр обязателен, иначе будет возвращена ошибка.

- Создали `OpenAPI` и соответствующий `Router`. `OpenApi::new("test api", "0.0.1").merge_router(&router)` — здесь `merge_router` означает, что данный экземпляр `OpenAPI` получает необходимую информацию для документации, анализируя определённый маршрут и его дочерние маршруты. Некоторые обработчики (`Handler`) маршрутов могут не предоставлять информацию для генерации документации — такие маршруты будут проигнорированы, например, обработчики, определённые с помощью макроса `#[handler]`, а не `#[endpoint]`. То есть в реальных проектах, исходя из сроков разработки и других причин, вы можете выбрать, какие части API документировать в OpenAPI, а какие — нет. В дальнейшем можно постепенно увеличивать количество интерфейсов, генерирующих документацию OpenAPI, и всё, что для этого потребуется — заменить `#[handler]` на `#[endpoint]` и изменить сигнатуру функции.

## Извлекатели данных

Через `use salvo::oapi::extract::*;` можно импортировать предустановленные, часто используемые извлекатели данных. Эти извлекатели предоставляют Salvo необходимую информацию для генерации документации OpenAPI.

- `QueryParam<T, const REQUIRED: bool>`: Извлекатель данных из строки запроса. `QueryParam<T, false>` означает, что параметр необязателен и может быть опущен. `QueryParam<T, true>` означает, что параметр обязателен; если он не предоставлен, будет возвращена ошибка.

- `HeaderParam<T, const REQUIRED: bool>`: Извлекатель данных из заголовков запроса. `HeaderParam<T, false>` означает, что параметр необязателен и может быть опущен. `HeaderParam<T, true>` означает, что параметр обязателен; если он не предоставлен, будет возвращена ошибка.

- `CookieParam<T, const REQUIRED: bool>`: Извлекатель данных из кук запроса. `CookieParam<T, false>` означает, что параметр необязателен и может быть опущен. `CookieParam<T, true>` означает, что параметр обязателен; если он не предоставлен, будет возвращена ошибка.

- `PathParam<T>`: Извлекатель параметров пути из URL запроса. Если этот параметр отсутствует, сопоставление маршрута не будет успешным, поэтому случай его отсутствия не предусмотрен.

- `FormBody<T>`: Извлекает информацию из данных формы, отправленной в запросе.

- `JsonBody<T>`: Извлекает информацию из полезной нагрузки запроса в формате JSON.

## `#[endpoint]`

При генерации документации OpenAPI необходимо использовать макрос `#[endpoint]` вместо обычного макроса `#[handler]`. По сути, это расширенная версия макроса `#[handler]`.

- Он может получать необходимую для генерации OpenAPI информацию из сигнатуры функции.

- Для информации, которую неудобно предоставлять через сигнатуру, её можно указать непосредственно в виде атрибутов внутри макроса `#[endpoint]`. Информация, предоставленная таким образом, будет объединена с информацией, полученной из сигнатуры функции; в случае конфликта приоритет будет у информации, указанной в атрибутах.

Вы можете использовать встроенный в Rust атрибут `#[deprecated]`, чтобы пометить определённый обработчик как устаревший. Хотя атрибут `#[deprecated]` поддерживает добавление информации, такой как причина устаревания или версия, OpenAPI этого не поддерживает, поэтому такая информация будет проигнорирована при генерации OpenAPI.

Части документации в виде комментариев в коде автоматически извлекаются для генерации OpenAPI. Первая строка используется для создания _`summary`_, а весь комментарий — для создания _`description`_.

```rust
/// Это краткое описание операции
///
/// Все строки комментария документации будут включены в описание операции.
#[endpoint]
fn endpoint() {}
```

## ToSchema

Для определения структур данных можно использовать `#[derive(ToSchema)]`:

```rust
#[derive(ToSchema)]
struct Pet {
    id: u64,
    name: String,
}
```

Дополнительные настройки можно определить с помощью `#[salvo(schema(...))]`:

- `example = ...` может быть `json!(...)`. `json!(...)` будет разобрано `serde_json::json!` в `serde_json::Value`.

  ```rust
  #[derive(ToSchema)]
  #[salvo(schema(example = json!({"name": "bob the cat", "id": 0})))]
  struct Pet {
      id: u64,
      name: String,
  }
  ```

- `xml(...)` может использоваться для определения свойств XML-объекта:

  ```rust
  #[derive(ToSchema)]
  struct Pet {
      id: u64,
      #[salvo(schema(xml(name = "pet_name", prefix = "u")))]
      name: String,
  }
  ```

## ToParameters

Генерация [параметров пути][path_parameters] из полей структуры.

Это реализация `#[derive]` для трейта [`ToParameters`][to_parameters].

Обычно параметры пути необходимо определять в [`#[salvo_oapi::endpoint(...parameters(...))]`][path_parameters] для `endpoint`. Однако при использовании [`struct`][struct] для определения параметров этот шаг можно опустить. Тем не менее, если требуется указать описание или изменить конфигурацию по умолчанию, параметры пути, определённые в стиле [`примитивных типов`][primitive], [`String`][std_string] или [кортежей][tuple], всё равно нужно определять в `parameters(...)`.

Вы можете использовать встроенный в Rust атрибут `#[deprecated]`, чтобы пометить поле как устаревшее, что отразится в сгенерированной спецификации OpenAPI.

Атрибут `#[deprecated]` поддерживает добавление дополнительной информации, такой как причина устаревания или версия, с которой оно началось, но OpenAPI этого не поддерживает. OpenAPI поддерживает только булево значение для определения, устарело ли что-либо. Хотя можно объявить устаревание с причиной, например `#[deprecated = "There is better way to do this"]`, эта причина не будет отображена в спецификации OpenAPI.

Комментарии документации к полям структуры будут использованы в качестве описания параметров в сгенерированной спецификации OpenAPI.

```rust
#[derive(salvo_oapi::ToParameters, serde::Deserialize)]
struct Query {
    /// Поиск элементов списка дел по имени.
    name: String
}
```

### Атрибуты контейнера ToParameters для `#[salvo(parameters(...))]`

Следующие атрибуты могут использоваться в атрибуте контейнера `#[salvo(parameters(…))]` для структур, производных от `ToParameters`:

- `names(...)` определяет список имён, разделённых запятыми, для безымянных полей структуры, используемых в качестве параметров пути. Поддерживается только для безымянных структур.
- `style = ...` может определять способ сериализации всех параметров, заданный [`ParameterStyle`][style]. Значение по умолчанию основано на атрибуте _`parameter_in`_.
- `default_parameter_in = ...` определяет расположение по умолчанию для параметров этого поля, значение берётся из [`parameter::ParameterIn`][in_enum]. Если этот атрибут не указан, по умолчанию используется `query`.
- `rename_all = ...` может служить альтернативой `rename_all` от `serde`. Фактически предоставляет ту же функциональность.

Использование `names` для определения имени одного безымянного параметра.

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(names("id")))]
struct Id(u64);
```

Использование `names` для определения имён нескольких безымянных параметров.

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(names("id", "name")))]
struct IdAndName(u64, String);
```

### Атрибуты полей ToParameters для `#[salvo(parameter(...))]`

Следующие атрибуты могут использоваться для полей структуры с `#[salvo(parameter(...))]`:

- `style = ...` определяет, как параметр сериализуется с помощью [`ParameterStyle`][style]. Значение по умолчанию основано на атрибуте _`parameter_in`_.

- `parameter_in = ...` определяет, где находится параметр этого поля, используя значение из [`parameter::ParameterIn`][in_enum]. Если это значение не предоставлено, по умолчанию используется `query`.

- `explode` определяет, создавать ли новую пару _`parameter=value`_ для каждого параметра внутри _`object`_ или _`array`_.

- `allow_reserved` определяет, разрешены ли зарезервированные символы _`:/?#[]@!$&'()*+,;=`_ в значении параметра.

- `example = ...` может быть ссылкой на метод или _`json!(...)`_. Указанный пример переопределит любой пример базового типа параметра.

- `value_type = ...` может использоваться для переопределения типа по умолчанию, используемого для поля в спецификации OpenAPI. Полезно, когда тип по умолчанию не соответствует фактическому, например, при использовании сторонних типов, не определённых в [`ToSchema`][to_schema] или [`примитивных типах`][primitive]. Значением может быть любой тип Rust, который обычно может быть сериализован в JSON, или пользовательский тип, такой как _`Object`_. _`Object`_ будет отображён как универсальный объект OpenAPI.

- `inline` если включено, определение типа этого поля должно быть из [`ToSchema`][to_schema], и это определение будет встроено.

- `default = ...` может быть ссылкой на метод или _`json!(...)`_.

- `format = ...` может быть вариантом перечисления [`KnownFormat`][known_format] или строковым значением открытого типа. По умолчанию формат выводится из типа свойства в соответствии со спецификацией OpenApi.

- `write_only` определяет, что свойство используется только для операций **записи** _POST, PUT, PATCH_, но не для _GET_.

- `read_only` определяет, что свойство используется только для операций **чтения** _GET_, но не для _POST, PUT, PATCH_.

- `nullable` определяет, может ли свойство быть `null` (обратите внимание, что это отличается от необязательности).

- `required = ...` используется для принудительного указания обязательности параметра. [См. правила](https://docs.rs/salvo-oapi/latest/salvo_oapi/derive.ToParameters.html#field-nullability-and-required-rules).

- `rename = ...` может служить альтернативой `rename` от `serde`. Фактически предоставляет ту же функциональность.

- `multiple_of = ...` используется для определения множителя значения. Значение параметра считается допустимым только в том случае, если оно делится на значение этого ключевого слова с результатом в виде целого числа. Значение множителя должно быть строго больше _`0`_.

- `maximum = ...` используется для определения верхнего предела значения, включая текущее значение.

- `minimum = ...` используется для определения нижнего предела значения, включая текущее значение.

- `exclusive_maximum = ...` используется для определения верхнего предела значения, исключая текущее значение.

- `exclusive_minimum = ...` используется для определения нижнего предела значения, исключая текущее значение.

- `max_length = ...` используется для определения максимальной длины значения типа `string`.

- `min_length = ...` используется для определения минимальной длины значения типа `string`.

- `pattern = ...` используется для определения допустимого регулярного выражения, которому должно соответствовать значение поля. Регулярное выражение соответствует версии _ECMA-262_.

- `max_items = ...` может использоваться для определения максимального количества элементов, разрешённого для поля типа `array`. Значение должно быть неотрицательным целым числом.

- `min_items = ...` может использоваться для определения минимального количества элементов, разрешённого для поля типа `array`. Значение должно быть неотрицательным целым числом.

- `with_schema = ...` использует _`schema`_, созданный ссылкой на функцию, вместо _`schema`_ по умолчанию. Функция должна иметь сигнатуру `fn() -> Into<RefOr<Schema>>`. Она не принимает аргументов и должна возвращать любое значение, которое может быть преобразовано в `RefOr<Schema>`.

- `additional_properties = ...` используется для определения свободной формы типа для `map`, такой как [`HashMap`](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html) или [`BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html). Свободная форма типа позволяет использовать произвольные типы в значениях отображения. Поддерживаемые форматы: _`additional_properties`_ и _`additional_properties = true`_.

#### Правила допустимости null и обязательности для полей

Некоторые правила, касающиеся допустимости null и обязательности, применяемые к атрибутам полей _`ToParameters`_, также применимы к атрибутам полей _`ToSchema`_. [См. правила](https://docs.rs/salvo-oapi/latest/salvo_oapi/derive.ToSchema.html#field-nullability-and-required-rules).

### Поддержка частичных атрибутов `#[serde(...)]`

Наследование ToParameters в настоящее время поддерживает часть [атрибутов serde][serde attributes]. Эти поддерживаемые атрибуты будут отражены в сгенерированной документации OpenAPI. В настоящее время поддерживаются следующие атрибуты:

- `rename_all = "..."` поддерживается на уровне контейнера.
- `rename = "..."` поддерживается **только** на уровне поля.
- `default` поддерживается на уровне контейнера и поля в соответствии с [атрибутами serde][serde attributes].
- `skip_serializing_if = "..."` поддерживается **
{/* 本行由工具自动生成,原文哈希值:0cd338da7f2e4cf2b5d77a3752808958 */}