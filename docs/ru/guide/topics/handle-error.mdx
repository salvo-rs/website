# Обработка ошибок

## Распространённые подходы к обработке ошибок в приложениях на Rust

Обработка ошибок в Rust отличается от таких языков, как Java; здесь отсутствуют конструкции типа `try...catch`. Типичный подход — определить глобальный тип обработки ошибок на уровне приложения:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("io: `{0}`")]
    Io(#[from] io::Error),
    #[error("utf8: `{0}`")]
    FromUtf8(#[from] FromUtf8Error),
    #[error("diesel: `{0}`")]
    Diesel(#[from] diesel::result::Error),
    ...
}

pub type AppResult<T> = Result<T, AppError>;
```

Здесь используется библиотека `thiserror`, которая упрощает определение пользовательских типов ошибок и сокращает объём кода. Для краткости также определён псевдоним типа `AppResult`.

### thiserror vs. anyhow

В экосистеме обработки ошибок Rust часто используются две библиотеки: `thiserror` и `anyhow`:

- **thiserror**: Подходит разработчикам библиотек для определения чётких типов ошибок. Использует производные макросы для реализации трейта `std::error::Error` для пользовательских типов ошибок, позволяя при этом определять представление ошибок. При создании библиотек или предоставлении пользователям ясных типов ошибок `thiserror` является предпочтительным выбором.

- **anyhow**: Ориентирована на разработчиков приложений, предоставляет универсальный тип ошибки `anyhow::Error`, способный инкапсулировать любую ошибку, реализующую трейт `std::error::Error`. Основное внимание уделяется распространению ошибок, а не их определению, что делает её особенно удобной для кода на уровне приложения. Можно быстро преобразовывать различные ошибки в `anyhow::Error`, сокращая необходимость в шаблонном коде.

В некоторых сценариях можно использовать обе библиотеки: определять типы ошибок с помощью `thiserror` в библиотеках, а обрабатывать и распространять эти ошибки с помощью `anyhow` в приложениях.

## Обработка ошибок в обработчиках

В Salvo обработчики (`Handler`) часто сталкиваются с различными ошибками, такими как ошибки подключения к базе данных, ошибки доступа к файлам, ошибки сетевого соединения и т.д. Для подобных ошибок можно применять упомянутый выше подход к обработке:

```rust
#[handler]
async fn home() -> AppResult<()> {

}
```

Здесь `home` напрямую возвращает `AppResult<()>`. Но как эту ошибку следует отображать? Нам нужно реализовать трейт `Writer` для пользовательского типа ошибки `AppResult`, где мы можем решить, как отображать ошибку:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        res.render(Text::Plain("Я ошибка, хахаха!"));
    }
}
```

В Salvo обработчик (`Handler`) может возвращать `Result` при условии, что оба типа `Ok` и `Err` в `Result` реализуют трейт `Writer`.

### Обработка ошибок с anyhow

Учитывая широкое использование anyhow, Salvo предоставляет встроенную поддержку для `anyhow::Error`. Когда функция `anyhow` активирована, `anyhow::Error` реализует трейт `Writer` и сопоставляется с `InternalServerError`:

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Для использования функции anyhow активируйте функцию `anyhow` в Salvo в Cargo.toml:

```toml
[dependencies]
salvo = { version = "*", features = ["anyhow"] }
anyhow = "1.0"
```

Это позволяет вашим функциям-обработчикам напрямую возвращать `anyhow::Result<T>`:

```rust
#[handler]
async fn home() -> anyhow::Result<impl Writer> {
    let data = fetch_data().context("Не удалось получить данные")?;
    Ok(Text::Plain(data))
}
```

Ошибки часто содержат конфиденциальную информацию, которую по соображениям безопасности и конфиденциальности обычно не следует показывать обычным пользователям. Однако если вы разработчик или администратор сайта, может быть предпочтительнее полное отображение ошибок с наиболее точной информацией.

Как показано, в методе `write` мы можем получить доступ к ссылкам на `Request` и `Depot`, что удобно для реализации описанного выше подхода:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let user = depot.obtain::<User>();
        if user.is_admin {
            res.render(Text::Plain(e.to_string()));
        } else {
            res.render(Text::Plain("Я ошибка, хахаха!"));
        }
    }
}
```

## Отображение страниц ошибок

Встроенные страницы ошибок Salvo удовлетворяют требованиям в большинстве случаев, отображая страницы в формате Html, Json или Xml в зависимости от типа данных запроса. Однако бывают ситуации, когда всё же требуется пользовательское отображение страниц ошибок.

Этого можно достичь, реализовав пользовательский `Catcher`. Подробные инструкции см. в разделе [`Catcher`](../concepts/catcher.html).
{/* Auto generated, origin file hash:fef605b82586fd46d5b4413daad859c1 */}