---
title: Rust-Bibliothek für Datum und Uhrzeit
---

# Chrono: Rust-Bibliothek für Datum und Uhrzeit

[Chrono](https://docs.rs/chrono/latest/chrono/) zielt darauf ab, alle Funktionen bereitzustellen, die für korrekte Datums- und Uhrzeitoperationen im gregorianischen Kalender benötigt werden:

- Der `DateTime`-Typ ist standardmäßig zeitzonenbewusst und bietet gleichzeitig separate zeitzonenunabhängige Typen.
- Operationen, die ungültige oder mehrdeutige Datums- und Uhrzeitangaben erzeugen könnten, geben `Option` oder `MappedLocalTime` zurück.
- Konfigurierbares Parsen und Formatieren mit einer von strftime inspirierten Syntax für Datums- und Uhrzeitformatierung.
- Die `Local`-Zeitzone kann mit der aktuellen Zeitzone des Betriebssystems arbeiten.
- Typen und Operationen sind unter Berücksichtigung angemessener Effizienz implementiert.
- Um die Binärgröße zu begrenzen, enthält Chrono standardmäßig keine Zeitzonendaten. Verwenden Sie die begleitenden Crates `Chrono-TZ` oder `tzfile` für vollständige Zeitzonenunterstützung.

## Funktionen

[Chrono](https://docs.rs/chrono/latest/chrono/) unterstützt verschiedene Laufzeitumgebungen und Betriebssysteme und verfügt über mehrere Funktionen, die aktiviert oder deaktiviert werden können.

### Standardfunktionen:

- `alloc`: Aktiviert Funktionen, die von Speicherzuweisung abhängen (hauptsächlich Zeichenkettenformatierung).
- `std`: Aktiviert Funktionen, die von der Standardbibliothek abhängen. Dies ist eine Obermenge von `alloc` und fügt Interoperabilität mit Standardbibliothekstypen und -merkmalen hinzu.
- `clock`: Aktiviert Funktionen zum Lesen der lokalen Zeitzone (`Local`). Dies ist eine Obermenge von `now`.
- `now`: Aktiviert Funktionen zum Lesen der Systemzeit (`now`).
- `wasmbind`: Bietet eine Schnittstelle zur JS Date API für wasm32-Ziele.

### Optionale Funktionen:

- `serde`: Aktiviert Serialisierung/Deserialisierung über serde.
- `rkyv`: Veraltet, verwenden Sie die `rkyv-*`-Funktionen.
- `rkyv-16`, `rkyv-32`, `rkyv-64`: Aktiviert Serialisierung/Deserialisierung über rkyv mit 16-Bit-, 32-Bit- oder 64-Bit-Ganzzahlen.
- `rkyv-validation`: Aktiviert rkyv-Validierungsunterstützung mit bytecheck.
- `arbitrary`: Konstruiert beliebige Instanzen von Typen mit dem Arbitrary-Crate.
- `unstable-locales`: Aktiviert Lokalisierung. Dies fügt verschiedene Methoden mit dem Suffix `_localized` hinzu.

## Überblick

### Zeitdifferenz/Dauer

Chrono bietet den `TimeDelta`-Typ zur Darstellung der Größe eines Zeitintervalls. Dies ist eine "genaue" Dauer, ausgedrückt in Sekunden und Nanosekunden, die keine "nominalen" Komponenten wie Tage oder Monate darstellt.

Der `TimeDelta`-Typ wurde früher `Duration` genannt (steht weiterhin als Typalias zur Verfügung). Ein wesentlicher Unterschied zu ähnlichen `core::time::Duration` ist, dass es sich um einen vorzeichenbehafteten Wert handelt, nicht um einen vorzeichenlosen.

### Datum und Uhrzeit

Chrono bietet den `DateTime`-Typ zur Darstellung von Datum und Uhrzeit in einer Zeitzone.

`DateTime` ist zeitzonenbewusst und muss aus einem `TimeZone`-Objekt konstruiert werden, das definiert, wie lokale Daten in UTC-Daten umgewandelt werden und umgekehrt. Es gibt drei bekannte `TimeZone`-Implementierungen:

- `Utc` gibt die UTC-Zeitzone an. Sie ist am effizientesten.
- `Local` gibt die lokale Systemzeitzone an.
- `FixedOffset` gibt eine beliebige feste Zeitzone an, z.B. UTC+09:00 oder UTC-10:30.

`DateTime`-Werte verschiedener `TimeZone`-Typen sind unterschiedlich und können nicht gemischt werden, können aber mit der Methode `DateTime::with_timezone` ineinander umgewandelt werden.

Sie können das aktuelle Datum und die aktuelle Uhrzeit in der UTC-Zeitzone (`Utc::now()`) oder in der lokalen Zeitzone (`Local::now()`) abrufen.

```rust
use chrono::prelude::*;

let utc: DateTime<Utc> = Utc::now(); // z.B. `2014-11-28T12:45:59.324310806Z`
let local: DateTime<Local> = Local::now(); // z.B. `2014-11-28T21:45:59.324310806+09:00`
```

Darüber hinaus können Sie auch eigene Datums- und Uhrzeitangaben erstellen:

```rust
use chrono::offset::MappedLocalTime;
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap(); // `2014-07-08T09:10:11Z`
```

### Formatierung und Parsing

Die Formatierung erfolgt über die `format`-Methode, deren Format der bekannten strftime-Formatierung entspricht.

Die Standardmethode `to_string` und der `{:?}`-Bezeichner bieten ebenfalls eine sinnvolle Darstellung. Chrono bietet außerdem die Methoden `to_rfc2822` und `to_rfc3339` für gängige Formate.

Chrono bietet nun auch Datumsformatierung in fast jeder Sprache ohne zusätzliche C-Bibliotheken. Diese Funktion ist unter dem Feature `unstable-locales` verfügbar:

```rust
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 11, 28, 12, 0, 9).unwrap();
assert_eq!(dt.format("%Y-%m-%d %H:%M:%S").to_string(), "2014-11-28 12:00:09");
assert_eq!(dt.format_localized("%A %e %B %Y, %T", Locale::fr_BE).to_string(), 
           "vendredi 28 novembre 2014, 12:00:09");
```

Das Parsing kann auf zwei Arten erfolgen:

1. Das Standardmerkmal `FromStr` (und die `parse`-Methode auf Zeichenketten) kann zum Parsen von `DateTime<FixedOffset>`-, `DateTime<Utc>`- und `DateTime<Local>`-Werten verwendet werden.
2. `DateTime::parse_from_str` parst Datum und Uhrzeit mit Offset und gibt `DateTime<FixedOffset>` zurück.

```rust
use chrono::prelude::*;

let dt = "2014-11-28T12:00:09Z".parse::<DateTime<Utc>>().unwrap();
let fixed_dt = DateTime::parse_from_str("2014-11-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z").unwrap();
```

### Konvertierung mit EPOCH-Zeitstempeln

Verwenden Sie `DateTime::from_timestamp(seconds, nanoseconds)`, um `DateTime<Utc>` aus einem UNIX-Zeitstempel zu erstellen.

Verwenden Sie `DateTime.timestamp`, um den Zeitstempel (in Sekunden) aus einem `DateTime` zu erhalten. Darüber hinaus können Sie `DateTime.timestamp_subsec_nanos` verwenden, um zusätzliche Nanosekunden zu erhalten.

```rust
use chrono::{DateTime, Utc};

// Erstelle datetime aus der Epoche:
let dt: DateTime<Utc> = DateTime::from_timestamp(1_500_000_000, 0).unwrap();
assert_eq!(dt.to_rfc2822(), "Fri, 14 Jul 2017 02:40:00 +0000");

// Hole Epochenwert aus datetime:
let dt = DateTime::parse_from_rfc2822("Fri, 14 Jul 2017 02:40:00 +0000").unwrap();
assert_eq!(dt.timestamp(), 1_500_000_000);
```

## Einschränkungen

- Es wird nur der vorwärts verlaufende gregorianische Kalender unterstützt (d.h. erweitert, um frühere Daten zu unterstützen).
- Datumstypen sind auf etwa 262.000 Jahre vor und nach der christlichen Zeitrechnung beschränkt.
- Uhrzeittypen sind auf Nanosekundengenauigkeit beschränkt.
- Schaltsekunden können dargestellt werden, aber Chrono unterstützt sie nicht vollständig.
{/* Auto generated, origin file hash:67733bfd2ba618b44f19c1449b096c42 */}