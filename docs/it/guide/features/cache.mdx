# Cache

Middleware che fornisce funzionalità di caching.

Il middleware Cache può memorizzare nella cache `StatusCode`, `Headers` e `Body` di una `Response`. Per i contenuti già memorizzati, alla successiva richiesta, il middleware Cache invierà direttamente al client il contenuto salvato in memoria.

Nota: questo plugin non memorizza nella cache le `Response` il cui `Body` è di tipo `ResBody::Stream`. Se applicato a questo tipo di `Response`, Cache non elaborerà tali richieste, ma non causerà errori.

## Funzionalità principali

- `CacheIssuer` fornisce un'astrazione per la generazione delle chiavi di cache. `RequestIssuer` ne è un'implementazione che permette di definire quali parti dell'URL della richiesta e del `Method` utilizzare per generare la chiave. Puoi anche definire la tua logica di generazione delle chiavi. La chiave di cache non deve essere necessariamente una stringa; qualsiasi tipo che soddisfi i vincoli `Hash + Eq + Send + Sync + 'static` può essere utilizzato come chiave.

- `CacheStore` fornisce operazioni di lettura e scrittura dei dati. `MokaStore` è un'implementazione di cache in memoria integrata basata su `moka`. Puoi anche definire la tua implementazione.

- `Cache` è una struttura che implementa `Handler` e contiene internamente un campo `skipper` per specificare quali richieste saltare (non memorizzare nella cache). Per impostazione predefinita, viene utilizzato `MethodSkipper` per saltare tutte le richieste tranne quelle con `Method::GET`.

  Codice di esempio dell'implementazione interna:

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Migrazione rapida da altri framework

Se hai utilizzato meccanismi di caching in altri framework, la seguente mappatura concettuale ti aiuterà ad adattarti più rapidamente all'implementazione della cache di Salvo:

### Guida alla migrazione da framework Rust

- **Migrazione da Actix-web**: Plugin come `actix-web-cache` in Actix-web richiedono solitamente un'introduzione separata, mentre la cache di Salvo fa parte della libreria core.

  ```rust
  // Esempio di cache in Actix-web
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Implementazione corrispondente in Salvo
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Guida alla migrazione da framework in altri linguaggi

- **Migrazione da Go/Gin**: Gin utilizza il pattern middleware, e Salvo adotta un approccio simile:

  ```go
  // Esempio di cache in Gin
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Implementazione corrispondente in Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Migrazione da Spring Boot**: La cache dichiarativa di Spring Boot deve essere convertita nella configurazione esplicita del middleware di Salvo:

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Implementazione corrispondente in Salvo - Applica la cache a livello di rotta
  let custom_issuer = YourCustomIssuer::new(); // Implementa l'interfaccia CacheIssuer
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Migrazione da Express.js**: Il middleware di cache di Express è concettualmente simile a quello di Salvo, ma la sintassi è diversa:

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Implementazione corrispondente in Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

Durante la migrazione da altri framework, presta attenzione a questi concetti chiave della cache di Salvo:

1. **Generazione della chiave di cache** - Controllata tramite l'interfaccia `CacheIssuer`.
2. **Memorizzazione della cache** - Implementata tramite l'interfaccia `CacheStore`.
3. **Logica di esclusione dalla cache** - Personalizzabile tramite il meccanismo `skipper`.

Per impostazione predefinita, Salvo memorizza nella cache solo le richieste GET, in linea con il comportamento predefinito della maggior parte dei framework.

_**Codice di esempio**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* 本行由工具自动生成,原文哈希值:df2bc60555363c109d61ba033738ce41 */}