# Депо

import { Tab, Tabs } from '@rspress/core/theme';

[Depot](https://docs.rs/salvo_core/latest/salvo_core/struct.Depot.html) используется для хранения временных данных, связанных с одним запросом. Промежуточное ПО (middleware) может помещать обработанные им временные данные в Depot для использования последующими программами.

Когда сервер получает запрос от клиентского браузера, он создаёт экземпляр `Depot`. Этот экземпляр уничтожается после того, как все промежуточные обработчики и `Handler` завершат обработку запроса.

Например, мы можем установить `current_user` в промежуточном ПО для входа в систему, а затем прочитать информацию о текущем пользователе в последующих промежуточных обработчиках или `Handler`.

## Быстрое понимание

`Depot` используется для хранения и обмена данными во время обработки запроса. Он реализует типобезопасный контейнер данных, поддерживающий две основные модели использования:

1. **Хранилище "ключ-значение"**: доступ к значениям, связанным со строковыми ключами, через методы `insert`/`get`.
2. **Внедрение типа (Type Injection)**: хранение и извлечение значений на основе типа через методы `inject`/`obtain`.

Как показано в примерах, `Depot` особенно полезен для передачи данных между промежуточным ПО и обработчиками. Промежуточное ПО может устанавливать значения в `Depot` (например, информацию о пользователе, статус аутентификации), а последующие обработчики могут извлекать эти значения без избыточных вычислений или запросов. Дизайн `Depot` обеспечивает согласованность данных и доступность на протяжении всей цепочки обработки запроса, что делает его основным инструментом для построения сложных веб-приложений.

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/use-depot/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/use-depot/Cargo.toml"
  ```
  </Tab>
</Tabs>

## Установка и получение данных через `insert` и `get`

Как показано выше, вы можете вставить `ключ` и `значение` в `Depot`, используя `insert`. Для значений этого типа вы можете напрямую извлекать их с помощью `get`.

```rust
depot.insert("a", "b");
assert_eq!(depot.get::<&str>("a").copied().unwrap(), "b")
```

Если `ключ` не существует, или если `ключ` существует, но тип не совпадает, возвращается `None`.

## Установка и получение данных через `inject` и `obtain`

Иногда возникают сценарии, когда для типа существует уникальный экземпляр, не требующий привязки к конкретному `ключу`. Вы можете использовать `inject` для вставки данных, а затем `obtain` для их извлечения. Эти методы не требуют предоставления `ключа`.

```rust
depot.inject(Config::new());
depot.obtain::<Config>();
```

# Обзор методов структуры Depot

| Категория | Метод | Описание |
|----------|--------|-------------|
| **Создание/Вместимость** | `new()` | Создаёт пустой Depot |
| | `with_capacity(capacity)` | Создаёт Depot с указанной вместимостью |
| | `capacity()` | Получает вместимость |
| | `inner()` | Получает ссылку на внутренний HashMap |
| **Внедрение/Извлечение по типу** | `inject<V>(value)` | Внедряет значение по типу |
| | `obtain<T>()` | Извлекает ссылку на внедрённое значение |
| | `obtain_mut<T>()` | Извлекает изменяемую ссылку на внедрённое значение |
| | `contains<T>()` | Проверяет, содержится ли определённый тип |
| | `scrape<T>()` | Удаляет и возвращает внедрённое значение |
| **Операции "ключ-значение"** | `insert(key, value)` | Вставляет пару ключ-значение |
| | `get<V>(key)` | Извлекает ссылку на значение, связанное с ключом |
| | `get_mut<V>(key)` | Извлекает изменяемую ссылку на значение, связанное с ключом |
| | `contains_key(key)` | Проверяет, содержится ли определённый ключ |
| | `remove<V>(key)` | Удаляет ключ и возвращает значение |
| | `delete(key)` | Удаляет пару ключ-значение |
{/* Auto generated, origin file hash:b95d84ad7fe6f9c1aae94fbe8ca18072 */}