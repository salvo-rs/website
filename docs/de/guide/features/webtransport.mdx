# WebTransport

WebTransport ist ein auf HTTP/3 basierendes Netzwerktransportprotokoll, das bidirektionale Kommunikationsfähigkeiten zwischen Clients und Servern bereitstellt und dabei niedrige Latenz, hohen Durchsatz und Sicherheit gewährleistet.

## Anwendungsfälle

WebTransport eignet sich besonders für folgende Szenarien:

- **Echtzeitanwendungen**: Online-Spiele, Echtzeit-Kollaborationstools, Videokonferenzen und andere Anwendungen, die niedrige Latenz erfordern.
- **Große Dateiübertragungen**: Unterstützt Hochdurchsatz-Datenübertragung, ideal für Medienstreaming und große Datei-Uploads/Downloads.
- **Multiplex-Kommunikation**: Ermöglicht gleichzeitige Einrichtung mehrerer bidirektionaler und unidirektionaler Datenströme.
- **Datagramm-Kommunikation**: Unterstützt Datagramm-Kommunikation ohne garantierte Reihenfolge oder Zuverlässigkeit, geeignet für Szenarien mit extrem hohen Echtzeitanforderungen.

Im Vergleich zu WebSocket bietet WebTransport niedrigere Latenz und flexiblere Kommunikationsmuster, insbesondere in instabilen Netzwerkumgebungen.

## Salvo-Implementierung

Das Salvo-Framework bietet integrierte Unterstützung für WebTransport, sodass Entwickler leicht WebTransport-basierte Anwendungen erstellen können. Wichtige Funktionen umfassen:

- Unterstützung für die Einrichtung von WebTransport-Sitzungen
- Unterstützung für bidirektionale Stromkommunikation
- Unterstützung für unidirektionale Stromkommunikation
- Unterstützung für Datagramm-Übertragung
- Server-initiierte Kommunikationsströme

### Einfaches Beispiel

Hier ist ein vereinfachtes Beispiel für die Implementierung eines WebTransport-Servers mit Salvo:

```rust
#[handler]
async fn connect(req: &mut Request) -> Result<(), salvo::Error> {
    let session = req.web_transport_mut().await.unwrap();
    
    // Datagramme verarbeiten
    if let Ok(Some((_, datagram))) = session.accept_datagram().await {
        // Empfangenes Datagramm verarbeiten
        let mut resp = BytesMut::from(&b"Antwort: "[..]);
        resp.put(datagram);
        session.send_datagram(resp.freeze())?;
    }
    
    // Bidirektionale Ströme verarbeiten
    if let Ok(Some(webtransport::server::AcceptedBi::BidiStream(_, stream))) = session.accept_bi().await {
        let (send, recv) = salvo::proto::quic::BidiStream::split(stream);
        // Bidirektionale Stromdaten verarbeiten
    }
    
    Ok(())
}
```

### Konfiguration und Start

Das Starten einer Salvo-Anwendung mit WebTransport-Unterstützung erfordert die Konfiguration von TLS-Zertifikaten und einem QUIC-Listener:

```rust
let cert = include_bytes!("../certs/cert.pem").to_vec();
let key = include_bytes!("../certs/key.pem").to_vec();

// Routing konfigurieren
let router = Router::new().push(Router::with_path("counter").goal(connect));

// TLS konfigurieren
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

// Listener einrichten
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());
let acceptor = QuinnListener::new(config, ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;

// Server starten
Server::new(acceptor).serve(router).await;
```

## Vollständiges Beispiel

Um mehr über die Verwendung von WebTransport in Salvo zu erfahren, sehen Sie sich das vollständige Beispiel auf GitHub an:
[https://github.com/salvo-rs/salvo/blob/main/examples/webtransport](https://github.com/salvo-rs/salvo/blob/main/examples/webtransport)

Dieses Beispiel enthält vollständige Implementierungen für Server und Client und zeigt, wie verschiedene Arten von WebTransport-Kommunikation behandelt werden.
{/* Auto generated, origin file hash:d98d4da0351033ac716bd9facbe3fa45 */}