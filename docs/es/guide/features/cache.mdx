# Caché

Middleware que proporciona funcionalidad de almacenamiento en caché.

El middleware Cache puede almacenar en caché el `StatusCode`, `Headers` y `Body` de una `Response`. Para contenido ya almacenado en caché, cuando se procesen solicitudes posteriores, el middleware Cache enviará directamente el contenido almacenado en memoria al cliente.

Nota: Este complemento no almacena en caché `Response` cuyo `Body` sea `ResBody::Stream`. Si se aplica a este tipo de `Response`, Cache no procesará estas solicitudes y no generará errores.

## Funcionalidades principales

- `CacheIssuer` proporciona una abstracción para la asignación de claves de caché. `RequestIssuer` es una implementación que permite definir la generación de claves de caché basándose en partes específicas de la URL de la solicitud y el `Method`. También puedes definir tu propia lógica de generación de claves. Las claves de caché no necesitan ser de tipo cadena; cualquier tipo que cumpla con las restricciones `Hash + Eq + Send + Sync + 'static` puede usarse como clave.

- `CacheStore` proporciona operaciones de almacenamiento y recuperación de datos. `MokaStore` es una implementación de caché en memoria integrada basada en `moka`. También puedes definir tu propia implementación.

- `Cache` es una estructura que implementa `Handler`, que internamente incluye un campo `skipper` para especificar qué solicitudes deben omitirse del almacenamiento en caché. Por defecto, se utiliza `MethodSkipper` para omitir todas las solicitudes excepto `Method::GET`.

  Código de ejemplo de implementación interna:

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Migración rápida desde otros frameworks

Si has utilizado mecanismos de caché en otros frameworks, la siguiente correspondencia de conceptos te ayudará a adaptarte más rápido a la implementación de caché de Salvo:

### Guía de migración desde frameworks Rust

- **Migración desde Actix-web**: Complementos como `actix-web-cache` en Actix-web generalmente requieren inclusión por separado, mientras que la caché de Salvo es parte de la biblioteca principal.

  ```rust
  // Ejemplo de caché en Actix-web
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Implementación equivalente en Salvo
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Guía de migración desde frameworks de otros lenguajes

- **Migración desde Go/Gin**: Gin utiliza el patrón de middleware, similar a Salvo:

  ```go
  // Ejemplo de caché en Gin
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Implementación equivalente en Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Migración desde Spring Boot**: La caché declarativa de Spring Boot debe convertirse a configuración explícita de middleware en Salvo:

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Implementación equivalente en Salvo - aplicar caché a nivel de ruta
  let custom_issuer = YourCustomIssuer::new(); // Implementa la interfaz CacheIssuer
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Migración desde Express.js**: El middleware de caché de Express es conceptualmente similar a Salvo, pero con sintaxis diferente:

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Implementación equivalente en Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

Al migrar desde otros frameworks, es importante considerar estos conceptos clave de la caché de Salvo:

1. **Generación de claves de caché** - Controlada a través de la interfaz `CacheIssuer`
2. **Almacenamiento de caché** - Implementado a través de la interfaz `CacheStore`
3. **Lógica de omisión de caché** - Personalizable mediante el mecanismo `skipper`

Por defecto, Salvo solo almacena en caché solicitudes GET, lo que coincide con el comportamiento predeterminado de la mayoría de frameworks.

_**Código de ejemplo**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* 本行由工具自动生成,原文哈希值:df2bc60555363c109d61ba033738ce41 */}