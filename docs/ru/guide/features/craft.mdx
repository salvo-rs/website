---
title: Функция Craft
---

# Функция Craft

Craft позволяет разработчикам автоматически генерировать функции-обработчики и конечные точки с помощью простых аннотаций, одновременно обеспечивая бесшовную интеграцию с генерацией документации OpenAPI.

## Случаи применения

Функция Craft особенно полезна в следующих сценариях:

- Когда необходимо быстро создавать функции-обработчики маршрутов из методов структур
- Когда требуется сократить шаблонный код для ручного извлечения параметров и обработки ошибок
- Когда нужно автоматически генерировать документацию OpenAPI для вашего API
- Когда требуется отделить бизнес-логику от веб-фреймворка

## Базовое использование

Чтобы использовать функцию Craft, необходимо импортировать следующие модули:

```rust
use salvo::oapi::extract::*;
use salvo::prelude::*;
```

### Создание структуры сервиса

Аннотируйте блок реализации макросом `#[craft]`, чтобы преобразовать методы структуры в функции-обработчики или конечные точки.

```rust
#[derive(Clone)]
pub struct Opts {
    state: i64,
}

#[craft]
impl Opts {
    // Конструктор
    fn new(state: i64) -> Self {
        Self { state }
    }
    
    // Другие методы...
}
```

### Создание функций-обработчиков

Используйте `#[craft(handler)]`, чтобы преобразовать метод в функцию-обработчик:

```rust
#[craft(handler)]
fn add1(&self, left: QueryParam<i64>, right: QueryParam<i64>) -> String {
    (self.state + *left + *right).to_string()
}
```

Этот метод станет функцией-обработчиком, которая:
- Автоматически извлекает значения `left` и `right` из параметров запроса
- Получает доступ к `state` из структуры
- Возвращает результат вычисления в виде строкового ответа

### Создание конечных точек

Используйте `#[craft(endpoint)]`, чтобы преобразовать метод в конечную точку:

```rust
#[craft(endpoint)]
pub(crate) fn add2(
    self: ::std::sync::Arc<Self>,
    left: QueryParam<i64>,
    right: QueryParam<i64>,
) -> String {
    (self.state + *left + *right).to_string()
}
```

Конечные точки могут использовать `Arc` для совместного использования состояния, что особенно полезно при обработке конкурентных запросов.

### Статические конечные точки

Вы также можете создавать статические конечные точки, не зависящие от состояния экземпляра:

```rust
#[craft(endpoint(responses((status_code = 400, description = "Wrong request parameters."))))]
pub fn add3(left: QueryParam<i64>, right: QueryParam<i64>) -> String {
    (*left + *right).to_string()
}
```

В этом примере добавлено пользовательское описание ответа об ошибке, которое будет отражено в сгенерированной документации OpenAPI.

## Извлекатели параметров

Модуль `oapi::extract` Salvo предоставляет различные извлекатели параметров, наиболее распространенные из которых включают:

- `QueryParam<T>`: Извлекает параметры из строки запроса
- `PathParam<T>`: Извлекает параметры из пути URL
- `FormData<T>`: Извлекает параметры из данных формы
- `JsonBody<T>`: Извлекает параметры из тела запроса JSON

Эти извлекатели автоматически обрабатывают разбор параметров и преобразование типов, значительно упрощая написание функций-обработчиков.

## Интеграция с OpenAPI

Функция Craft может автоматически генерировать документацию API, соответствующую спецификации OpenAPI. В примере:

```rust
let router = Router::new()
    .push(Router::with_path("add1").get(opts.add1()))
    .push(Router::with_path("add2").get(opts.add2()))
    .push(Router::with_path("add3").get(Opts::add3()));

// Генерация документации OpenAPI
let doc = OpenApi::new("Example API", "0.0.1").merge_router(&router);

// Добавление маршрутов документации OpenAPI и Swagger UI
let router = router
    .push(doc.into_router("/api-doc/openapi.json"))
    .push(SwaggerUi::new("/api-doc/openapi.json").into_router("swagger-ui"));
```

При такой конфигурации документация API будет доступна по конечной точке `/api-doc/openapi.json`, а Swagger UI — по пути `/swagger-ui`.

## Полный пример

Ниже приведен полный пример, демонстрирующий использование функции Craft для создания трех различных типов конечных точек:

```rust
use salvo::oapi::extract::*;
use salvo::prelude::*;
use std::sync::Arc;

#[derive(Clone)]
pub struct Opts {
    state: i64,
}

#[craft]
impl Opts {
    fn new(state: i64) -> Self {
        Self { state }
    }

    #[craft(handler)]
    fn add1(&self, left: QueryParam<i64>, right: QueryParam<i64>) -> String {
        (self.state + *left + *right).to_string()
    }

    #[craft(endpoint)]
    pub(crate) fn add2(
        self: ::std::sync::Arc<Self>,
        left: QueryParam<i64>,
        right: QueryParam<i64>,
    ) -> String {
        (self.state + *left + *right).to_string()
    }

    #[craft(endpoint(responses((status_code = 400, description = "Wrong request parameters."))))]
    pub fn add3(left: QueryParam<i64>, right: QueryParam<i64>) -> String {
        (*left + *right).to_string()
    }
}

#[tokio::main]
async fn main() {
    // Создание общего состояния с начальным значением 1
    let opts = Arc::new(Opts::new(1));

    // Настройка маршрутов для трех конечных точек
    let router = Router::new()
        .push(Router::with_path("add1").get(opts.add1()))
        .push(Router::with_path("add2").get(opts.add2()))
        .push(Router::with_path("add3").get(Opts::add3()));

    // Генерация документации OpenAPI
    let doc = OpenApi::new("Example API", "0.0.1").merge_router(&router);
    
    // Добавление маршрутов документации OpenAPI и Swagger UI
    let router = router
        .push(doc.into_router("/api-doc/openapi.json"))
        .push(SwaggerUi::new("/api-doc/openapi.json").into_router("swagger-ui"));

    // Запуск сервера на localhost:5800
    let acceptor = TcpListener::new("127.0.0.1:5800").bind().await;
    Server::new(acceptor).serve(router).await;
}
```
{/* Auto generated, origin file hash:f2d903755c5dbbd89c656ef1599cc869 */}