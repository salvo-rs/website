# Encerramento Gracioso

O encerramento gracioso refere-se ao processo em que, quando um servidor está sendo desligado, ele não termina imediatamente todas as conexões. Em vez disso, primeiro interrompe a aceitação de novas solicitações, permitindo que as solicitações existentes tenham tempo suficiente para concluir seu processamento antes de fechar o serviço. Essa abordagem evita que as solicitações sejam interrompidas abruptamente, melhorando assim a experiência do usuário e a confiabilidade do sistema.

O Salvo fornece suporte para encerramento gracioso através do método `handle` do `Server`, que recupera o manipulador do servidor, seguido pela chamada do método `stop_graceful` para implementar o encerramento. Após invocar esse método, o servidor irá:

- Parar de aceitar novas solicitações de conexão
- Aguardar que as solicitações existentes concluam o processamento
- Fechar forçadamente quaisquer conexões restantes após um tempo limite especificado (se fornecido)

Aqui está um exemplo simples:

```rust
use salvo_core::prelude::*;

#[tokio::main]
async fn main() {
    let acceptor = TcpListener::new("127.0.0.1:8698").bind().await;
    let server = Server::new(acceptor);
    let handle = server.handle();

    // Encerrar o servidor graciosamente
    tokio::spawn(async move {
        tokio::time::sleep(std::time::Duration::from_secs(60)).await;
        handle.stop_graceful(None);
    });
    server.serve(Router::new()).await;
}
```

No exemplo acima:

- `server.handle()` recupera o manipulador do servidor, que pode ser usado para controlar o ciclo de vida do servidor
- `handle.stop_graceful(None)` inicia o processo de encerramento gracioso, onde `None` indica que nenhum tempo limite foi definido, significando que o servidor aguardará indefinidamente que todas as solicitações sejam concluídas
- Para definir um tempo limite, você pode passar `Some(Duration)`, após o qual quaisquer conexões restantes serão fechadas forçadamente

Essa abordagem é particularmente adequada para aplicativos implantados em ambientes de contêineres ou em plataformas de nuvem, bem como para cenários que exigem atualizações em tempo real para garantir que as solicitações não sejam interrompidas inesperadamente.
{/* Auto generated, origin file hash:046b3113209f454ef7a16224e721cfcb */}