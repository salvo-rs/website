# Depot

import { Tab, Tabs } from 'rspress/theme';
import MainCode from '../../../../codes_md/use-depot/src/main.mdx';
import CargoCode from '../../../../codes_md/use-depot/Cargo.mdx';

[Depot](https://docs.rs/salvo_core/latest/salvo_core/struct.Depot.html) — это структура для хранения временных данных, связанных с обработкой одного запроса. Промежуточное ПО может сохранять обработанные данные в Depot для последующего использования другими компонентами.

При получении запроса от клиентского браузера сервер создает экземпляр `Depot`. Этот экземпляр существует в течение всего времени обработки запроса промежуточным ПО и `Handler`, после чего уничтожается.

Например, в промежуточном ПО аутентификации можно установить `current_user`, а затем в последующих обработчиках или промежуточном ПО получить информацию о текущем пользователе.

## Быстрое понимание

`Depot` предназначен для хранения и обмена данными в процессе обработки запроса. Он реализует типобезопасный контейнер данных с двумя основными режимами работы:

1. **Хранилище ключ-значение**: методы `insert`/`get` для работы со значениями по строковым ключам
2. **Внедрение по типу**: методы `inject`/`obtain` для работы со значениями на основе их типа

Как показано в примерах, `Depot` особенно полезен для передачи данных между промежуточным ПО и обработчиками. Промежуточное ПО может сохранять значения (например, информацию о пользователе, статус аутентификации), которые затем могут быть получены последующими обработчиками без повторных вычислений или запросов. Дизайн `Depot` гарантирует согласованность и доступность данных на протяжении всей цепочки обработки запроса, что делает его ключевым инструментом для сложных веб-приложений.
<Tabs>
  <Tab label="main.rs">
    <MainCode/>
  </Tab>
  <Tab label="Cargo.toml">
    <CargoCode/>
  </Tab>
</Tabs>

## Установка и получение данных через `insert` и `get`

Как показано выше, вы можете вставить пару `key` и `value` в `Depot` с помощью `insert`. Для таких значений используется прямое получение через `get`.

```rust
depot.insert("a", "b");
assert_eq!(depot.get::<&str>("a").copied().unwrap(), "b")
```

Если ключ не существует или тип значения не соответствует ожидаемому, возвращается `None`.

## Установка и получение данных через `inject` и `obtain`

В некоторых случаях существуют значения, для которых не требуется конкретный ключ — когда для данного типа существует только один экземпляр. Для таких значений можно использовать `inject` для вставки и `obtain` для получения. Эти методы не требуют указания ключа.

```rust
depot.inject(Config::new());
depot.obtain::<Config>();
```

# Обзор методов структуры Depot

| Категория | Метод | Описание |
|------|------|------|
| **Создание/ёмкость** | `new()` | Создает пустой Depot |
| | `with_capacity(capacity)` | Создает Depot с указанной ёмкостью |
| | `capacity()` | Возвращает текущую ёмкость |
| | `inner()` | Возвращает ссылку на внутренний HashMap |
| **Внедрение/получение по типу** | `inject<V>(value)` | Внедряет значение по типу |
| | `obtain<T>()` | Получает ссылку на внедренное значение |
| | `obtain_mut<T>()` | Получает изменяемую ссылку на внедренное значение |
| | `contains<T>()` | Проверяет наличие значения типа |
| | `scrape<T>()` | Удаляет и возвращает внедренное значение |
| **Операции с ключами** | `insert(key, value)` | Вставляет пару ключ-значение |
| | `get<V>(key)` | Получает ссылку на значение по ключу |
| | `get_mut<V>(key)` | Получает изменяемую ссылку на значение по ключу |
| | `contains_key(key)` | Проверяет наличие ключа |
| | `remove<V>(key)` | Удаляет и возвращает значение по ключу |
| | `delete(key)` | Удаляет пару ключ-значение |
{/* 本行由工具自动生成,原文哈希值:0a5fdeaf8cc44da931db5a32298e6afe */}