# Prise en charge d'HTTP/3

Salvo offre une prise en charge d'HTTP/3, qui peut être activée via la fonctionnalité `quinn`. HTTP/3 est basé sur le protocole QUIC et offre une latence réduite ainsi que de meilleures performances par rapport aux protocoles HTTP/1.1 et HTTP/2 traditionnels, particulièrement dans des environnements réseau instables.

## Activation de la prise en charge d'HTTP/3

Pour activer la prise en charge d'HTTP/3 dans Salvo, vous devez activer la fonctionnalité `quinn` dans votre fichier `Cargo.toml` :

```toml
salvo = { workspace = true, features = ["quinn"] }
```

## Cas d'utilisation d'HTTP/3

HTTP/3 est particulièrement adapté aux scénarios suivants :

- Applications sur appareils mobiles et dans des environnements réseau instables
- Applications en temps réel nécessitant une faible latence
- Scénarios impliquant le téléchargement parallèle de nombreux petits fichiers
- Applications nécessitant une migration de connexion (par exemple, basculement transparent du WiFi vers les réseaux cellulaires sans interruption de connexion)

## Exemple de code

Voici un exemple simple de serveur HTTP/3 prenant en charge à la fois HTTP/3 (QUIC) et HTTPS (TCP) :

```rust
use salvo::conn::rustls::{Keycert, RustlsConfig};
use salvo::prelude::*;

// Fonction de gestion qui répond par "Hello World"
#[handler]
async fn hello() -> &'static str {
    "Hello World"
}

#[tokio::main]
async fn main() {
    // Initialisation du système de journalisation
    tracing_subscriber::fmt().init();

    // Chargement du certificat TLS et de la clé privée depuis des fichiers PEM intégrés
    let cert = include_bytes!("../certs/cert.pem").to_vec();
    let key = include_bytes!("../certs/key.pem").to_vec();

    // Création d'un routeur et ajout d'un point de terminaison
    let router = Router::new().get(hello);

    // Configuration des paramètres TLS avec Rustls
    let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

    // Création d'un écouteur TCP chiffré par TLS sur le port 8698
    let listener = TcpListener::new(("0.0.0.0", 8698)).rustls(config.clone());

    // Création d'un écouteur QUIC et combinaison avec l'écouteur TCP
    let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 8698))
        .join(listener)
        .bind()
        .await;

    // Démarrage du serveur prenant en charge HTTP/3 (QUIC) et HTTPS (TCP)
    Server::new(acceptor).serve(router).await;
}
```

## Analyse du code clé

### Configuration TLS

```rust
// Configuration des paramètres TLS avec Rustls
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));
```

Étant donné qu'HTTP/3 est basé sur le protocole QUIC, qui nécessite TLS 1.3 pour le chiffrement, les certificats et clés TLS doivent être configurés. Dans Salvo, nous utilisons `RustlsConfig` pour configurer TLS.

### Combinaison des écouteurs

```rust
// Création d'un écouteur TCP chiffré par TLS
let listener = TcpListener::new(("0.0.0.0", 8698)).rustls(config.clone());

// Création d'un écouteur QUIC et combinaison avec l'écouteur TCP
let acceptor = QuinnListener::new(config.build_quinn_config().unwrap(), ("0.0.0.0", 8698))
    .join(listener)
    .bind()
    .await;
```

Ce code constitue la partie centrale de la gestion d'HTTP/3 dans Salvo. Il crée d'abord un écouteur TCP avec TLS activé (pour HTTP/1.1 et HTTP/2), puis un écouteur QUIC (pour HTTP/3). La méthode `join` combine ces deux écouteurs, permettant au serveur de traiter simultanément les requêtes de différents protocoles.

## Exécution de l'exemple

Pour exécuter cet exemple, vous avez besoin de certificats TLS et de clés privées valides. Dans un environnement de développement, des certificats auto-signés peuvent être utilisés. Le code complet de l'exemple est disponible dans le [dépôt GitHub de Salvo](https://github.com/salvo-rs/salvo/tree/main/examples/hello-h3).

Notez que de nombreux clients ne prennent pas encore entièrement en charge HTTP/3, il est donc essentiel que ce serveur prenne en charge à la fois HTTP/3 et HTTPS.

## Considérations

1. HTTP/3 nécessite une prise en charge de TLS 1.3, des certificats et clés valides doivent donc être configurés.
2. Les clients doivent prendre en charge le protocole HTTP/3 pour utiliser cette fonctionnalité ; sinon, ils basculeront vers HTTP/1.1 ou HTTP/2.
3. Dans les environnements de production, des certificats émis par une autorité de certification de confiance doivent être utilisés plutôt que des certificats auto-signés.
{/* Auto generated, origin file hash:f135699b9ae12daf6d88fc1e8c22a61e */}