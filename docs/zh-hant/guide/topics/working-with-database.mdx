# 使用資料庫

### [Diesel](https://diesel.rs/)

```rust
use diesel::prelude::*;
use diesel::r2d2::{ConnectionManager, Pool, PoolError, PooledConnection};
use once_cell::sync::OnceCell;
use salvo::prelude::*;

const DB_URL: &str = "postgres://benchmarkdbuser:benchmarkdbpass@tfb-database/hello_world";
type PgPool = Pool<ConnectionManager<PgConnection>>;

static DB_POOL: OnceCell<PgPool> = OnceCell::new();

fn connect() -> Result<PooledConnection<ConnectionManager<PgConnection>>, PoolError> {
    DB_POOL.get().unwrap().get()
}
fn build_pool(database_url: &str, size: u32) -> Result<PgPool, PoolError> {
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    diesel::r2d2::Pool::builder()
        .max_size(size)
        .min_idle(Some(size))
        .test_on_check_out(false)
        .idle_timeout(None)
        .max_lifetime(None)
        .build(manager)
}

fn main() {
    DB_POOL
        .set(build_pool(&DB_URL, 10).expect(&format!("Error connecting to {}", &DB_URL)))
        .ok();
}

#[handler]
async fn show_article(req: &mut Request, res: &mut Response) -> Result<(), Error> {
    let id: i64 = req.param::<i64>("id").unwrap_or_default();
    let conn = connect()?;
    let article = articles::table.find(id).first::<Article>(&conn)?;
    res.render(Json(row));
    Ok(())
}
```

### [Sqlx](https://github.com/launchbadge/sqlx)

```rust
use sqlx::{Pool, PgPool};
use once_cell::sync::OnceCell;

pub static DB_POOL: OnceCell<PgPool> = OnceCell::new();

pub fn db_pool() -> &PgPool {
    DB_POOL.get().unwrap()
}

pub async fn make_db_pool(db_url: &str) -> PgPool {
    Pool::connect(&db_url).await.unwrap()
}

#[tokio::main]
async fn main() {
    let pool = make_db_pool().await;
    DB_POOL.set(pool).unwrap();
}
```

### [rbatis](https://github.com/rbatis/rbatis)

```toml
[dependencies]
async-std = "1.11.0"
fast_log = "1.5.24"
log = "0.4.17"
once_cell = "1.12.0"
rbatis = "4.0.7"
rbdc = "0.1.2"
rbdc-mysql = "0.1.7"
rbs = "0.1.2"
salvo = { path = "../../salvo" }
serde = { version = "1.0.143", features = ["derive"] }
tokio = { version = "1.20.1", features = ["macros"] }
tracing = "0.1.36"
tracing-subscriber = "0.3.15"
serde_json = "1.0"
```

```rust
#[macro_use]
extern crate rbatis;
extern crate rbdc;

use once_cell::sync::Lazy;
use rbatis::Rbatis;
use salvo::prelude::*;
use serde::{Serialize, Deserialize};
use rbdc_mysql::driver::MysqlDriver;

pub static RB: Lazy<Rbatis> = Lazy::new(|| Rbatis::new());

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct User {
    pub id: i64,
    pub username: String,
    pub password: String,
}

impl_select!(User{select_by_id(id:String) -> Option => "`where id = #{id} limit 1`"});
#[handler]
pub async fn get_user(req: &mut Request, res: &mut Response) {
    let uid = req.query::<i64>("uid").unwrap();
    let data = User::select_by_id(&mut RB.clone(), uid.to_string()).await.unwrap();
    println!("{:?}", data);
    res.render(serde_json::to_string(&data).unwrap());
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt().init();

    // mysql 連線資訊
    let mysql_uri = "mysql://root:123456@localhost/test";
    RB.link(MysqlDriver {}, mysql_uri).await.unwrap();

    // 路由設定
    let router = Router::with_path("users").get(get_user);

    tracing::info!("Listening on http://127.0.0.1:5800");
    let acceptor = TcpListener::new("127.0.0.1:5800").bind().await; Server::new(acceptor).serve(router).await;
}
```

## [SeaORM](https://www.sea-ql.org/SeaORM/)

SeaORM 是一個非同步、動態的 ORM，提供強大的關聯式資料庫支援，包含實體關係、遷移系統和完善的型別安全查詢建構器。適合需要完整功能 ORM 的中大型專案。

## [Tokio ORM (Toasty)](https://github.com/tokio-rs/toasty)

Toasty 是 Tokio 團隊開發的 ORM，目前仍在積極開發中，專注於為 Tokio 生態系統提供緊密整合的 ORM 解決方案。可能適合依賴 Tokio 並願意採用新興技術的專案。

## [SurrealDB Rust SDK](https://surrealdb.com/docs/sdk/rust)

SurrealDB 的 Rust SDK 提供了與這個多模型資料庫的連接能力，適合需要處理圖資料、文件資料和關聯式資料的應用程式。對於需要靈活資料模型的專案是不錯的選擇。
{/* 本行由工具自动生成,原文哈希值:1e253924948cbedf4d240486568b09f4 */}