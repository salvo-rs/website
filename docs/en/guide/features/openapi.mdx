import { Tab, Tabs } from '@rspress/core/theme';

# OpenAPI Documentation Generation

OpenAPI is an open-source specification used to describe the interface design of RESTful APIs. It defines the structure, parameters, return types, error codes, and other details of API requests and responses in JSON or YAML format, making communication between clients and servers more explicit and standardized.

OpenAPI originally started as the open-source version of the Swagger specification and has now become an independent project, gaining support from many large enterprises and developers. Using the OpenAPI specification helps development teams collaborate better, reduce communication costs, and improve development efficiency. At the same time, OpenAPI provides developers with tools for automatically generating API documentation, mock data, and test cases, facilitating development and testing work.

Salvo provides OpenAPI integration (modified from [utoipa](https://github.com/juhaku/utoipa)). Leveraging its own characteristics, Salvo elegantly and automatically extracts relevant OpenAPI data type information from `Handler`s. Salvo also integrates several popular open-source OpenAPI interfaces such as SwaggerUI, scalar, rapidoc, and redoc.

To address the issue of Rust type names being long and not necessarily suitable for OpenAPI usage, `salvo-oapi` provides the `Namer` type, allowing customization of rules to modify type names in OpenAPI according to specific needs.

_**Example Code**_

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/oapi-hello/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/oapi-hello/Cargo.toml"
  ```
  </Tab>
</Tabs>

Enter `http://localhost:5800/swagger-ui` in your browser to see the Swagger UI page.

The OpenAPI integration in Salvo is quite elegant. For the example above, compared to a regular Salvo project, we only performed the following steps:

- Enable the `oapi` feature in `Cargo.toml`: `salvo = { workspace = true, features = ["oapi"] }`;

- Replace `#[handler]` with `#[endpoint]`;

- Use `name: QueryParam<String, false>` to retrieve the value of a query string. When you visit the URL `http://localhost/hello?name=chris`, this `name` query string will be parsed. The `false` in `QueryParam<String, false>` indicates that this parameter is optional; visiting `http://localhost/hello` will not cause an error. Conversely, `QueryParam<String, true>` means this parameter is required, and an error will be returned if it is not provided.

- Create `OpenAPI` and the corresponding `Router`. In `OpenApi::new("test api", "0.0.1").merge_router(&router)`, `merge_router` indicates that this `OpenAPI` obtains necessary documentation information by parsing a route and its descendant routes. Some routes' `Handler`s may not provide information for generating documentation; these routes will be ignored, such as `Handler`s defined using the `#[handler]` macro instead of the `#[endpoint]` macro. That is to say, in actual projects, for reasons like development progress, you can choose not to generate OpenAPI documentation or generate it partially. You can gradually increase the number of OpenAPI interfaces generated later, and all you need to do is change `#[handler]` to `#[endpoint]` and modify the function signature.

## Data Extractors

By using `use salvo::oapi::extract::*;`, you can import predefined common data extractors. Extractors provide some necessary information to Salvo so that Salvo can generate OpenAPI documentation.

- `QueryParam<T, const REQUIRED: bool>`: An extractor that retrieves data from query strings. `QueryParam<T, false>` indicates this parameter is optional and can be omitted. `QueryParam<T, true>` indicates this parameter is required and cannot be omitted; if not provided, an error is returned.

- `HeaderParam<T, const REQUIRED: bool>`: An extractor that retrieves data from request headers. `HeaderParam<T, false>` indicates this parameter is optional and can be omitted. `HeaderParam<T, true>` indicates this parameter is required and cannot be omitted; if not provided, an error is returned.

- `CookieParam<T, const REQUIRED: bool>`: An extractor that retrieves data from request cookies. `CookieParam<T, false>` indicates this parameter is optional and can be omitted. `CookieParam<T, true>` indicates this parameter is required and cannot be omitted; if not provided, an error is returned.

- `PathParam<T>`: An extractor that retrieves path parameters from the request `URL`. If this parameter does not exist, route matching will not succeed, so it cannot be omitted.

- `FormBody<T>`: Extracts information from submitted form data in requests.

- `JsonBody<T>`: Extracts information from JSON payloads submitted in requests.

## `#[endpoint]`

When generating OpenAPI documentation, you need to use the `#[endpoint]` macro instead of the regular `#[handler]` macro. It is essentially an enhanced version of the `#[handler]` macro.

- It can obtain necessary information for generating OpenAPI from the function signature.

- For information that cannot be conveniently provided via the signature, it can be supplied directly by adding attributes within the `#[endpoint]` macro. Information provided this way will be merged with that obtained from the function signature. If conflicts exist, the information from the macro attributes will override that from the function signature.

You can use Rust's built-in `#[deprecated]` attribute to mark a Handler as obsolete. Although the `#[deprecated]` attribute supports adding information such as deprecation reasons and versions, OpenAPI does not support these, so such information will be ignored when generating OpenAPI.

Documentation comments in the code are automatically extracted for OpenAPI generation. The first line is used for the _`summary`_, and the entire comment section is used for the _`description`_.

```rust
/// This is a summary of the operation
///
/// All lines of the doc comment will be included to operation description.
#[endpoint]
fn endpoint() {}
```

## ToSchema

You can define data structures using `#[derive(ToSchema)]`:

```rust
#[derive(ToSchema)]
struct Pet {
    id: u64,
    name: String,
}
```

You can define optional settings using `#[salvo(schema(...))]`:

- `example = ...` can be `json!(...)`. `json!(...)` will be parsed by `serde_json::json!` into `serde_json::Value`.

  ```rust
  #[derive(ToSchema)]
  #[salvo(schema(example = json!({"name": "bob the cat", "id": 0})))]
  struct Pet {
      id: u64,
      name: String,
  }
  ```

- `xml(...)` can be used to define Xml object attributes:

  ```rust
  #[derive(ToSchema)]
  struct Pet {
      id: u64,
      #[salvo(schema(xml(name = "pet_name", prefix = "u")))]
      name: String,
  }
  ```

## ToParameters

Generate [path parameters][path_parameters] from struct fields.

This is the `#[derive]` implementation of the [`ToParameters`][to_parameters] trait.

Typically, path parameters need to be defined in the [`#[salvo_oapi::endpoint(...parameters(...))]`][path_parameters] of an endpoint. However, when using a [`struct`][struct] to define parameters, this step can be omitted. Nonetheless, if descriptions need to be provided or default configurations changed, path parameters of [`primitive types`][primitive] and [`String`][std_string] or [tuple]-style path parameters still need to be defined within `parameters(...)`.

You can use Rust's built-in `#[deprecated]` attribute to mark a field as deprecated, which will be reflected in the generated OpenAPI specification.

The `#[deprecated]` attribute supports adding extra information such as deprecation reasons or the version from which it is deprecated, but OpenAPI does not support this. OpenAPI only supports a boolean value to determine deprecation. While it's perfectly fine to declare a deprecation with a reason, like `#[deprecated = "There is better way to do this"]`, this reason will not appear in the OpenAPI specification.

Documentation comments on struct fields will be used as parameter descriptions in the generated OpenAPI specification.

```rust
#[derive(salvo_oapi::ToParameters, serde::Deserialize)]
struct Query {
    /// Query todo items by name.
    name: String
}
```

### ToParameters Container Attributes for `#[salvo(parameters(...))]`

The following attributes can be used with the container attribute `#[salvo(parameters(…))]` on structs deriving `ToParameters`:

- `names(...)` defines a comma-separated list of names for the unnamed fields of a struct used as path parameters. Only supported on unnamed structs.
- `style = ...` can define the serialization style for all parameters, specified by [`ParameterStyle`][style]. The default is based on the _`parameter_in`_ attribute.
- `default_parameter_in = ...` defines the default location used for parameters of this field, the value coming from [`parameter::ParameterIn`][in_enum]. If this attribute is not provided, the default is `query`.
- `rename_all = ...` can serve as an alternative to `serde`'s `rename_all`. It essentially provides the same functionality.

Use `names` to define names for a single unnamed parameter.

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(names("id")))]
struct Id(u64);
```

Use `names` to define names for multiple unnamed parameters.

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(names("id", "name")))]
struct IdAndName(u64, String);
```

### ToParameters Field Attributes for `#[salvo(parameter(...))]`

The following attributes can be used on struct fields with `#[salvo(parameter(...))]`:

- `style = ...` defines how the parameter is serialized by [`ParameterStyle`][style]. The default is based on the _`parameter_in`_ attribute.

- `parameter_in = ...` defines where this field's parameter is located using a value from [`parameter::ParameterIn`][in_enum]. If this value is not provided, the default is `query`.

- `explode` defines whether to create new _`parameter=value`_ pairs for each parameter in an _`object`_ or _`array`_.

- `allow_reserved` defines whether reserved characters _`:/?#[]@!$&'()*+,;=`_ are allowed in the parameter value.

- `example = ...` can be a method reference or _`json!(...)`_. The given example will override any example from the underlying parameter type.

- `value_type = ...` can be used to override the default type used for the field in the OpenAPI specification. Useful when the default type does not correspond to the actual type, such as when using third-party types not defined in [`ToSchema`][to_schema] or [`primitive` types][primitive]. The value can be any Rust type that can normally be serialized to JSON or a custom type like _`Object`_. _`Object`_ will be rendered as a generic OpenAPI object.

- `inline` if enabled, the definition of this field's type must come from [`ToSchema`][to_schema], and this definition will be inlined.

- `default = ...` can be a method reference or _`json!(...)`_.

- `format = ...` can be a variant of the [`KnownFormat`][known_format] enum or an open value as a string. By default, the format is derived from the property's type according to the OpenAPI specification.

- `write_only` defines that the property is only used for **write** operations _POST, PUT, PATCH_ and not _GET_.

- `read_only` defines that the property is only used for **read** operations _GET_ and not _POST, PUT, PATCH_.

- `nullable` defines whether the property can be `null` (note this is different from not being required).

- `required = ...` is used to enforce that the parameter is required. [See rules](https://docs.rs/salvo-oapi/latest/salvo_oapi/derive.ToParameters.html#field-nullability-and-required-rules).

- `rename = ...` can serve as an alternative to `serde`'s `rename`. It essentially provides the same functionality.

- `multiple_of = ...` is used to define a multiple of the value. A parameter value is considered valid only if dividing it by the value of this keyword results in an integer. The multiple value must be strictly greater than _`0`_.

- `maximum = ...` is used to define the upper limit of the value, inclusive.

- `minimum = ...` is used to define the lower limit of the value, inclusive.

- `exclusive_maximum = ...` is used to define the upper limit of the value, exclusive.

- `exclusive_minimum = ...` is used to define the lower limit of the value, exclusive.

- `max_length = ...` is used to define the maximum length for `string` type values.

- `min_length = ...` is used to define the minimum length for `string` type values.

- `pattern = ...` is used to define a valid regular expression that the field value must match. The regular expression follows the _ECMA-262_ version.

- `max_items = ...` can be used to define the maximum number of items allowed for an `array` type field. The value must be a non-negative integer.

- `min_items = ...` can be used to define the minimum number of items allowed for an `array` type field. The value must be a non-negative integer.

- `with_schema = ...` uses a function reference to create a _`schema`_ instead of the default _`schema`_. The function must satisfy `fn() -> Into<RefOr<Schema>>`. It takes no arguments and must return any value that can be converted to `RefOr<Schema>`.

- `additional_properties = ...` is used to define a free-form type for `map`s, such as [`HashMap`](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html) and [`BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html). Free-form types allow arbitrary types in map values. Supported formats are _`additional_properties`_ and _`additional_properties = true`_.

#### Field nullability and required rules

Some rules for field nullability and required attributes applied to _`ToParameters`_ also apply to _`ToSchema`_ field attributes. [See rules](https://docs.rs/salvo-oapi/latest/salvo_oapi/derive.ToSchema.html#field-nullability-and-required-rules).

### Partial `#[serde(...)]` attributes support

The ToParameters derive currently supports partial [serde attributes][serde attributes]. These supported attributes will be reflected in the generated OpenAPI documentation. The following are currently supported:

- `rename_all = "..."` is supported at the container level.
- `rename = "..."` is supported **only** at the field level.
- `default` is supported at both container and field levels according to [serde attributes][serde attributes].
- `skip_serializing_if = "..."` is supported **only** at the field level.
- `with = ...` is supported **only** at the field level.
- `skip_serializing = "..."` is supported **only** at the field or variant level.
- `skip_deserializing = "..."` is supported **only** at the field or variant level.
- `skip = "..."` is supported **only** at the field level.

Other _`serde`_ attributes will affect serialization but will not be reflected in the generated OpenAPI documentation.

### Examples

_**Demonstrates the use of the `#[salvo(parameters(...))]` container attribute combined with [`ToParameters`][to_parameters] for path parameters, inlining a query field:**_

```rust
use serde::Deserialize;
use salvo_core::prelude::*;
use salvo_oapi::{ToParameters, ToSchema};

#[derive(Deserialize, ToSchema)]
#[serde(rename_all = "snake_case")]
enum PetKind {
    Dog,
    Cat,
}

#[derive(Deserialize, ToParameters)]
struct PetQuery {
    /// Name of pet
    name: Option<String>,
    /// Age of pet
    age: Option<i32>,
    /// Kind of pet
    #[salvo(parameter(inline))]
    kind: PetKind
}

#[salvo_oapi::endpoint(
    parameters(PetQuery),
    responses(
        (status_code = 200, description = "success response")
    )
)]
async fn get_pet(query: PetQuery) {
    // ...
}
```

_**Using `value_type` to override a `String` type with `i64`.**_

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(default_parameter_in = Query))]
struct Filter {
    #[salvo(parameter(value_type = i64))]
    id: String,
}
```

_**Using `value_type` to override a `String` type with `Object`. In the OpenAPI specification, `Object` will appear as `type:object`.**_

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(default_parameter_in = Query))]
struct Filter {
    #[salvo(parameter(value_type = Object))]
    id: String,
}
```

_**You can also override the default type of a field with a generic.**_

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(default_parameter_in = Query))]
struct Filter {
    #[salvo(parameter(value_type = Option<String>))]
    id: String
}
```

_**You can even override one [`Vec`] with another [`Vec`].**_

```rust
# use salvo_oapi::ToParameters;

#[derive(ToParameters, serde::Deserialize)]
#[salvo(parameters(default_parameter_in = Query))]
struct Filter {
    #[salvo(parameter(value_type = Vec<i32>))]
    id: Vec<String>
}
```

_**We can override a field type with another [`ToSchema`][to_schema].**_

```rust
# use
{/* 本行由工具自动生成,原文哈希值:0cd338da7f2e4cf2b5d77a3752808958 */}