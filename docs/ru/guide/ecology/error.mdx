---
title: Библиотеки обработки ошибок в Rust
---

# Библиотеки обработки ошибок в Rust

import { LinkCard } from '@theme';

<LinkCard
  href="https://docs.rs/thiserror/latest/thiserror/"
  title="thiserror"
  description="Удобный производный макрос для пользовательских типов ошибок"
/>

<LinkCard
  href="https://docs.rs/snafu/latest/snafu/"
  title="snafu"
  description="Фреймворк для обработки и отчёта об ошибках с контекстом"
/>

<LinkCard
  href="https://docs.rs/anyhow/latest/anyhow/"
  title="anyhow"
  description="Гибкая библиотека для обработки и отчёта об ошибках"
/>

## thiserror vs snafu

### thiserror

thiserror — это лёгкая библиотека, предоставляющая производный макрос для упрощения определения ошибок.

Особенности:
- Лаконичный синтаксис с минимальным boilerplate
- Идеально подходит для создания библиотек типов ошибок и API
- Чаще используется при создании библиотек для других разработчиков

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DataError {
    #[error("Ошибка базы данных: {0}")]
    DatabaseError(#[from] sqlx::Error),
    
    #[error("Ошибка валидации: {0}")]
    ValidationError(String),
    
    #[error("Запись не найдена")]
    NotFound,
}
```

### snafu

snafu предлагает более комплексный фреймворк обработки ошибок с акцентом на контекст и цепочки ошибок.

Особенности:
- Поощряет точное добавление контекста через паттерн "селекторов контекста"
- Рекомендует подход "одно перечисление ошибок на модуль"
- Поддерживает варианты ошибок в виде структур и кортежей
- Встроенная поддержка трассировки стека

```rust
use snafu::{Snafu, ResultExt, Backtrace};

#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("Не удалось прочитать конфигурационный файл {filename:?}"))]
    ReadConfig {
        filename: String,
        source: std::io::Error,
        backtrace: Backtrace,
    },
    
    // Также поддерживается стиль кортежей
    #[snafu(display("Ошибка ввода-вывода"))]
    Io(#[snafu(source)] std::io::Error, #[snafu(backtrace)] Backtrace),
}

// Пример использования селектора контекста
fn read_config(path: &str) -> Result<Config, Error> {
    std::fs::read_to_string(path).context(ReadConfigSnafu { filename: path })?;
    // ...
}
```

### Сравнение

| Характеристика | thiserror | snafu |
|---------------|-----------|-------|
| Лаконичность синтаксиса | Более лаконичный | Более многословный |
| Контекст ошибок | Базовая поддержка | Богатые механизмы контекста |
| Масштабируемость | Небольшие и средние проекты | Средние и крупные проекты |
| Строк кода | ~2 строки на ошибку | ~5 строк на ошибку |
| Организация ошибок | Обычно единое перечисление | Поощряет перечисления на уровне модуля |
| Поддержка трассировки | Нет встроенной поддержки | Встроенная поддержка |

**Рекомендации по выбору**:
- **Выбирайте thiserror**, если нужны простые и понятные типы ошибок, особенно в библиотеках
- **Выбирайте snafu**, если требуется более структурированная обработка ошибок, особенно в крупных приложениях

## anyhow

anyhow принципиально отличается от предыдущих библиотек, фокусируясь на приложениях, а не библиотеках.

Особенности:
- Разработан для обработки ошибок в приложениях, а не библиотеках
- Предоставляет динамический тип `anyhow::Error`, который может содержать любую ошибку, реализующую трейт `Error`
- Упрощает обработку ошибок разных типов
- Не требует определения пользовательских типов ошибок

```rust
use anyhow::{Context, Result};

fn main() -> Result<()> {
    let config = std::fs::read_to_string("config.json")
        .context("Не удалось прочитать конфигурационный файл")?;
        
    let app_config: AppConfig = serde_json::from_str(&config)
        .context("Недопустимый формат конфигурации")?;
        
    // Используем Result<T> как псевдоним для Result<T, anyhow::Error>
    Ok(())
}
```

**anyhow vs thiserror/snafu**:
- anyhow ориентирован на быструю разработку приложений
- thiserror/snafu фокусируются на создании точных иерархий типов ошибок
- anyhow обычно используется в коде приложений
- thiserror/snafu обычно применяются в библиотеках

На практике anyhow и thiserror часто используются вместе: библиотеки определяют точные типы ошибок через thiserror, а приложения обрабатывают разнородные ошибки через anyhow.
{/* 本行由工具自动生成,原文哈希值:ac682487abf5cc66b7b4ee2508c7386d */}