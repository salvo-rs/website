# Fehlerbehandlung

## Gängige Fehlerbehandlungsmethoden in Rust-Anwendungen

Die Fehlerbehandlung in Rust unterscheidet sich von Sprachen wie Java. Es gibt kein `try...catch`. Üblicherweise wird auf Anwendungsebene ein globaler Fehlertyp definiert:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("io: `{0}`")]
    Io(#[from] io::Error),
    #[error("utf8: `{0}`")]
    FromUtf8(#[from] FromUtf8Error),
    #[error("diesel: `{0}`")]
    Diesel(#[from] diesel::result::Error),
    ...
}

pub type AppResult<T> = Result<T, AppError>;
```

Hier wird die Crate `thiserror` verwendet, die das Definieren eigener benutzerdefinierter Fehlertypen erleichtert und Code vereinfacht. Zur besseren Lesbarkeit wird zusätzlich ein `AppResult` definiert.

### thiserror vs. anyhow

Im Ökosystem der Rust-Fehlerbehandlung sind zwei häufig verwendete Crates `thiserror` und `anyhow`:

-   **thiserror**: Geeignet für Bibliotheksentwickler, um klare Fehlertypen zu definieren. Es hilft durch ein derive-Makro bei der Implementierung des `std::error::Error`-Traits für benutzerdefinierte Fehlertypen und erlaubt die Definition der Fehlerdarstellung. `thiserror` ist die bessere Wahl, wenn Sie eine Bibliothek erstellen oder Benutzern klare Fehlertypen bereitstellen müssen.

-   **anyhow**: Geeignet für Anwendungsentwickler, stellt einen universellen Fehlertyp `anyhow::Error` bereit, der jeden Fehler enthalten kann, der den `std::error::Error`-Trait implementiert. Der Fokus liegt mehr auf der Fehlerweitergabe als auf der Definition, besonders geeignet für Code auf Anwendungsebene. Sie können schnell verschiedene Fehler in `anyhow::Error` umwandeln und so den Bedarf an Boilerplate-Code reduzieren.

In manchen Szenarien können beide Crates gleichzeitig verwendet werden: `thiserror` zur Definition von Fehlertypen in der Bibliothek und `anyhow` zur Behandlung und Weitergabe dieser Fehler in der Anwendung.

## Fehlerbehandlung in Handlern

In Salvo stoßen `Handler` ebenfalls häufig auf verschiedene Fehler, z.B.: Datenbankverbindungsfehler, Dateizugriffsfehler, Netzwerkverbindungsfehler usw. Für diese Art von Fehlern kann die oben beschriebene Fehlerbehandlungsmethode angewendet werden:

```rust
#[handler]
async fn home()-> AppResult<()> {

}
```

Hier gibt `home` direkt ein `AppResult<()>` zurück. Aber wie soll dieser Fehler angezeigt werden? Wir müssen für den benutzerdefinierten Fehlertyp `AppResult` den `Writer`-Trait implementieren. In dieser Implementierung können wir entscheiden, wie der Fehler angezeigt wird:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        res.render(Text::Plain("I'm a error, hahaha!"));
    }
}
```

Handler in Salvo können `Result` zurückgeben, vorausgesetzt, die Typen `Ok` und `Err` in `Result` implementieren beide den `Writer`-Trait.

### Fehlerbehandlung mit anyhow

Da anyhow weit verbreitet ist, bietet Salvo eingebaute Unterstützung für `anyhow::Error`. Wenn das `anyhow`-Feature aktiviert ist, implementiert `anyhow::Error` den `Writer`-Trait und wird auf `InternalServerError` gemappt:

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Um das anyhow-Feature zu verwenden, muss in der Cargo.toml das `anyhow`-Feature von Salvo aktiviert werden:

```toml
[dependencies]
salvo = { version = "*", features = ["anyhow"] }
anyhow = "1.0"
```

Dadurch können Ihre Handler-Funktionen direkt `anyhow::Result<T>` zurückgeben:

```rust
#[handler]
async fn home() -> anyhow::Result<impl Writer> {
    let data = fetch_data().context("Failed to fetch data")?;
    Ok(Text::Plain(data))
}
```

Fehler enthalten oft sensible Informationen, die normalerweise nicht für normale Benutzer sichtbar sein sollten – das wäre zu unsicher und böte keinerlei Privatsphäre. Wenn Sie jedoch Entwickler oder Website-Administrator sind, sehen Sie das vielleicht anders: Sie möchten, dass der Fehler alle Details preisgibt, damit Sie die tatsächliche Fehlermeldung sehen können.

Wie man sieht, können wir in der `write`-Methode Referenzen auf `Request` und `Depot` erhalten, was die Umsetzung der obigen Anforderung sehr einfach macht:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let user = depot.obtain::<User>();
        if user.is_admin {
            res.render(Text::Plain(e.to_string()));
        } else {
            res.render(Text::Plain("I'm a error, hahaha!"));
        }
    }
}
```

## Anzeige von Fehlerseiten

Die in Salvo mitgelieferten Fehlerseiten erfüllen in den meisten Fällen die Anforderungen. Sie können je nach angeforderter Datentyp HTML-, Json- oder Xml-Seiten anzeigen. In manchen Fällen möchten wir jedoch weiterhin die Anzeige der Fehlerseite anpassen.

Dies kann durch eine benutzerdefinierte `Catcher`-Implementierung erreicht werden. Eine detaillierte Erläuterung finden Sie im Abschnitt [`Catcher`](../concepts/catcher.html).
{/* Auto generated, origin file hash:ccc3ad5dca846f6b6415dbe84e0c5166 */}