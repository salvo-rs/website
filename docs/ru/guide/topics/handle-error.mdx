# Обработка ошибок

## Обычные способы обработки ошибок в приложениях на Rust

Обработка ошибок в Rust отличается от таких языков, как Java, здесь нет конструкции `try...catch`. Обычно на уровне приложения определяется глобальный тип для обработки ошибок:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("io: `{0}`")]
    Io(#[from] io::Error),
    #[error("utf8: `{0}`")]
    FromUtf8(#[from] FromUtf8Error),
    #[error("diesel: `{0}`")]
    Diesel(#[from] diesel::result::Error),
    ...
}

pub type AppResult<T> = Result<T, AppError>;
```

Здесь используется библиотека `thiserror`, которая позволяет удобно определять собственные типы ошибок и упрощает код. Для краткости записи также определяется `AppResult`.

### thiserror и anyhow

В экосистеме обработки ошибок Rust две часто используемые библиотеки — это `thiserror` и `anyhow`:

- **thiserror**: Подходит для разработчиков библиотек, используется для определения чётких типов ошибок. С помощью производного макроса она помогает реализовать трейт `std::error::Error` для пользовательских типов ошибок, позволяя при этом определять способ отображения ошибок. Когда вы создаёте библиотеку или вам нужно предоставить пользователям чёткие типы ошибок, `thiserror` — лучший выбор.

- **anyhow**: Подходит для разработчиков приложений, предоставляет универсальный тип ошибки `anyhow::Error`, который может содержать любую ошибку, реализующую трейт `std::error::Error`. Она больше ориентирована на распространение ошибок, а не на их определение, и особенно подходит для кода на уровне приложения. Вы можете быстро преобразовывать различные ошибки в `anyhow::Error`, уменьшая необходимость написания шаблонного кода.

В некоторых сценариях вы можете использовать обе библиотеки одновременно: определять типы ошибок с помощью `thiserror` в библиотеке, а обрабатывать и распространять эти ошибки с помощью `anyhow` в приложении.

## Обработка ошибок в Handler

В Salvo `Handler` также часто сталкивается с различными ошибками, такими как: ошибки подключения к базе данных, ошибки доступа к файлам, ошибки сетевого подключения и т.д. Для ошибок такого типа можно использовать описанный выше подход к обработке:

```rust
#[handler]
async fn home()-> AppResult<()> {

}
```

Здесь `home` напрямую возвращает `AppResult<()>`. Но как отобразить эту ошибку? Нам нужно реализовать `Writer` для пользовательского типа ошибки `AppResult`, и в этой реализации мы можем решить, как отображать ошибку:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        res.render(Text::Plain("I'm a error, hahaha!"));
    }
}
```

`Handler` в Salvo может возвращать `Result`, при условии, что типы `Ok` и `Err` в `Result` реализуют трейт `Writer`.

### Использование anyhow для обработки ошибок

Учитывая широкое использование anyhow, Salvo предоставляет встроенную поддержку для `anyhow::Error`. После включения функции `anyhow`, `anyhow::Error` реализует трейт `Writer` и будет отображаться как `InternalServerError`:

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Чтобы использовать функцию anyhow, необходимо включить feature `anyhow` в Cargo.toml для Salvo:

```toml
[dependencies]
salvo = { version = "*", features = ["anyhow"] }
anyhow = "1.0"
```

Таким образом, ваши функции-обработчики могут напрямую возвращать `anyhow::Result<T>`:

```rust
#[handler]
async fn home() -> anyhow::Result<impl Writer> {
    let data = fetch_data().context("Failed to fetch data")?;
    Ok(Text::Plain(data))
}
```

Ошибки часто содержат конфиденциальную информацию, и обычно её не хотят показывать обычным пользователям — это небезопасно и лишает приватности. Однако, если вы разработчик или администратор сайта, ваше мнение может отличаться: вы хотите, чтобы ошибка была полностью раскрыта, показывая самую точную информацию.

Как видно, в методе `write` мы фактически можем получить ссылки на `Request` и `Depot`, что позволяет удобно реализовать описанный выше подход:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let user = depot.obtain::<User>();
        if user.is_admin {
            res.render(Text::Plain(e.to_string()));
        } else {
            res.render(Text::Plain("I'm a error, hahaha!"));
        }
    }
}
```

## Отображение страниц ошибок

Встроенные страницы ошибок в Salvo удовлетворяют потребности в большинстве случаев, они могут отображать страницы в формате Html, Json или Xml в зависимости от типа запрашиваемых данных. Однако в некоторых ситуациях мы всё же хотим настроить отображение страниц ошибок.

Это можно реализовать с помощью пользовательского `Catcher`. Подробное описание можно найти в разделе [`Catcher`](../concepts/catcher.html).
{/* Auto generated, origin file hash:ccc3ad5dca846f6b6415dbe84e0c5166 */}