---  
title: Библиотека для работы с датой и временем в Rust  
---  

# Chrono: Библиотека для работы с датой и временем в Rust  

import { LinkCard } from '@theme';  

<LinkCard  
  href="https://docs.rs/chrono/latest/chrono/"  
  title="chrono"  
  description="chrono"  
/>  

Chrono предоставляет все необходимые функции для корректной работы с датами и временем по григорианскому календарю:  

- Тип `DateTime` по умолчанию учитывает часовые пояса, но также доступны типы без привязки к часовому поясу.  
- Операции, которые могут привести к недопустимым или неоднозначным датам и времени, возвращают `Option` или `MappedLocalTime`.  
- Гибкий парсинг и форматирование с синтаксисом, вдохновлённым strftime.  
- Локальный часовой пояс (`Local`) работает с текущим часовым поясом операционной системы.  
- Типы и операции реализованы с учётом эффективности.  
- Для уменьшения размера бинарного файла Chrono по умолчанию не включает данные о часовых поясах. Используйте крейты `Chrono-TZ` или `tzfile` для полной поддержки.  

## Возможности  

Chrono поддерживает различные среды выполнения и операционные системы, предлагая несколько опциональных функций.  

### Функции по умолчанию:  

- `alloc`: включает функции, требующие выделения памяти (в основном форматирование строк).  
- `std`: включает функции, зависящие от стандартной библиотеки. Это надмножество `alloc`, добавляющее взаимодействие с типами и трейтами стандартной библиотеки.  
- `clock`: включает чтение локального часового пояса (`Local`). Это надмножество `now`.  
- `now`: включает чтение системного времени (`now`).  
- `wasmbind`: предоставляет интерфейс к JS Date API для целевой платформы wasm32.  

### Опциональные функции:  

- `serde`: включает сериализацию/десериализацию через serde.  
- `rkyv`: устарело, используйте `rkyv-*`.  
- `rkyv-16`, `rkyv-32`, `rkyv-64`: включает сериализацию/десериализацию через rkyv с 16-, 32- или 64-битными целыми числами.  
- `rkyv-validation`: включает поддержку валидации rkyv через bytecheck.  
- `arbitrary`: позволяет создавать произвольные экземпляры типов с помощью крейта Arbitrary.  
- `unstable-locales`: включает локализацию. Добавляет методы с суффиксом `_localized`.  

## Обзор  

### Разница во времени / Длительность  

Chrono предоставляет тип `TimeDelta` для представления временного интервала. Это "точная" длительность в секундах и наносекундах, без учёта "номинальных" компонентов, таких как дни или месяцы.  

Ранее `TimeDelta` назывался `Duration` (доступен как псевдоним типа). Ключевое отличие от `core::time::Duration` — поддержка отрицательных значений.  

### Дата и время  

Chrono предоставляет тип `DateTime` для представления даты и времени с учётом часового пояса.  

`DateTime` учитывает часовой пояс и должен создаваться из объекта `TimeZone`, который определяет преобразование между локальным временем и UTC. Доступны три основные реализации `TimeZone`:  

- `Utc`: UTC. Наиболее эффективен.  
- `Local`: локальный часовой пояс системы.  
- `FixedOffset`: произвольный фиксированный часовой пояс (например, UTC+09:00 или UTC-10:30).  

`DateTime` с разными `TimeZone` несовместимы, но могут быть преобразованы через `DateTime::with_timezone`.  

Текущую дату и время можно получить в UTC (`Utc::now()`) или локальном поясе (`Local::now()`):  

```rust  
use chrono::prelude::*;  

let utc: DateTime<Utc> = Utc::now(); // Например, `2014-11-28T12:45:59.324310806Z`  
let local: DateTime<Local> = Local::now(); // Например, `2014-11-28T21:45:59.324310806+09:00`  
```  

Также можно создавать собственные даты и время:  

```rust  
use chrono::offset::MappedLocalTime;  
use chrono::prelude::*;  

let dt = Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap(); // `2014-07-08T09:10:11Z`  
```  

### Форматирование и парсинг  

Форматирование выполняется методом `format` с синтаксисом, аналогичным strftime.  

Метод `to_string` и спецификатор `{:?}` также предоставляют удобное представление. Chrono поддерживает `to_rfc2822` и `to_rfc3339` для стандартных форматов.  

Chrono также поддерживает локализованное форматирование (требует `unstable-locales`):  

```rust  
use chrono::prelude::*;  

let dt = Utc.with_ymd_and_hms(2014, 11, 28, 12, 0, 9).unwrap();  
assert_eq!(dt.format("%Y-%m-%d %H:%M:%S").to_string(), "2014-11-28 12:00:09");  
assert_eq!(dt.format_localized("%A %e %B %Y, %T", Locale::fr_BE).to_string(),   
           "vendredi 28 novembre 2014, 12:00:09");  
```  

Парсинг возможен двумя способами:  

1. Через `FromStr` (и метод `parse`) для `DateTime<FixedOffset>`, `DateTime<Utc>` и `DateTime<Local>`.  
2. Через `DateTime::parse_from_str` для строк с указанием смещения.  

```rust  
use chrono::prelude::*;  

let dt = "2014-11-28T12:00:09Z".parse::<DateTime<Utc>>().unwrap();  
let fixed_dt = DateTime::parse_from_str("2014-11-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z").unwrap();  
```  

### Преобразование в UNIX-время  

Используйте `DateTime::from_timestamp(seconds, nanoseconds)` для создания `DateTime<Utc>` из UNIX-времени.  

Методы `DateTime.timestamp` и `DateTime.timestamp_subsec_nanos` возвращают секунды и наносекунды соответственно.  

```rust  
use chrono::{DateTime, Utc};  

// Создание из UNIX-времени:  
let dt: DateTime<Utc> = DateTime::from_timestamp(1_500_000_000, 0).unwrap();  
assert_eq!(dt.to_rfc2822(), "Fri, 14 Jul 2017 02:40:00 +0000");  

// Получение UNIX-времени:  
let dt = DateTime::parse_from_rfc2822("Fri, 14 Jul 2017 02:40:00 +0000").unwrap();  
assert_eq!(dt.timestamp(), 1_500_000_000);  
```  

## Ограничения  

- Поддерживается только григорианский календарь (с расширением для более ранних дат).  
- Диапазон дат ограничен примерно ±262 000 лет от нашей эры.  
- Точность времени ограничена наносекундами.  
- Високосные секунды поддерживаются частично.
{/* 本行由工具自动生成,原文哈希值:8f29ad63efca7d455f7ca1249d2f7dfd */}