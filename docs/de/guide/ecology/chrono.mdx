---
title: Rust Datums- und Zeitbibliothek
---

# Chrono: Rust Datums- und Zeitbibliothek

[Chrono](https://docs.rs/chrono/latest/chrono/) zielt darauf ab, alle Funktionen bereitzustellen, die für korrekte Operationen mit Datums- und Zeitangaben im proleptischen gregorianischen Kalender benötigt werden:

- Der `DateTime`-Typ ist standardmäßig zeitzonenbewusst, mit separaten zeitzonenunabhängigen Typen.
- Operationen, die ein ungültiges oder mehrdeutiges Datum und Uhrzeit erzeugen könnten, geben `Option` oder `MappedLocalTime` zurück.
- Konfigurierbares Parsen und Formatieren mit einer von strftime inspirierten Datums- und Zeitformatierungssyntax.
- Die `Local`-Zeitzone funktioniert mit der aktuellen lokalen Zeitzone des Betriebssystems.
- Typen und Operationen sind implementiert, um angemessen effizient zu sein.
- Um die Binärgröße nicht zu erhöhen, liefert Chrono standardmäßig keine Zeitzonendaten mit. Verwenden Sie die Begleit-Crates `Chrono-TZ` oder `tzfile` für vollständige Zeitzonenunterstützung.

## Funktionen

[Chrono](https://docs.rs/chrono/latest/chrono/) unterstützt verschiedene Laufzeitumgebungen und Betriebssysteme mit mehreren Funktionen, die aktiviert oder deaktiviert werden können.

### Standardfunktionen:

- `alloc`: Aktiviert Funktionen, die von Allokation abhängen (hauptsächlich Zeichenkettenformatierung).
- `std`: Aktiviert Funktionen, die von der Standardbibliothek abhängen. Dies ist eine Obermenge von `alloc` und fügt Interoperabilität mit Standardbibliothekstypen und -traits hinzu.
- `clock`: Aktiviert das Lesen der lokalen Zeitzone (`Local`). Dies ist eine Obermenge von `now`.
- `now`: Aktiviert das Lesen der Systemzeit (`now`).
- `wasmbind`: Bietet eine Schnittstelle zur JS Date API für das wasm32-Ziel.

### Optionale Funktionen:

- `serde`: Aktiviert Serialisierung/Deserialisierung via serde.
- `rkyv`: Veraltet, verwenden Sie die `rkyv-*`-Funktionen.
- `rkyv-16`, `rkyv-32`, `rkyv-64`: Aktiviert Serialisierung/Deserialisierung via rkyv unter Verwendung von 16-Bit-, 32-Bit- bzw. 64-Bit-Ganzzahlen.
- `rkyv-validation`: Aktiviert rkyv-Validierungsunterstützung mit bytecheck.
- `arbitrary`: Konstruiert beliebige Instanzen von Typen mit der Arbitrary-Crate.
- `unstable-locales`: Aktiviert Lokalisierung. Dies fügt verschiedene Methoden mit dem Suffix `_localized` hinzu.

## Überblick

### Zeitdifferenz/Dauer

Chrono stellt den `TimeDelta`-Typ bereit, um die Größe eines Zeitintervalls darzustellen. Dies ist eine "exakte" Dauer, dargestellt in Sekunden und Nanosekunden, und repräsentiert keine "nominalen" Komponenten wie Tage oder Monate.

Der `TimeDelta`-Typ wurde früher `Duration` genannt (noch als Typalias verfügbar). Ein bemerkenswerter Unterschied zur ähnlichen `core::time::Duration` ist, dass es sich um einen vorzeichenbehafteten Wert handelt.

### Datum und Uhrzeit

Chrono stellt den `DateTime`-Typ bereit, um ein Datum und eine Uhrzeit in einer Zeitzone darzustellen.

`DateTime` ist zeitzonenbewusst und muss aus einem `TimeZone`-Objekt konstruiert werden, das definiert, wie das lokale Datum zu und von UTC konvertiert wird. Es gibt drei bekannte `TimeZone`-Implementierungen:

- `Utc` gibt die UTC-Zeitzone an. Sie ist am effizientesten.
- `Local` gibt die lokale Systemzeitzone an.
- `FixedOffset` gibt eine beliebige feste Offset-Zeitzone an, z.B. UTC+09:00 oder UTC-10:30.

`DateTime`-Werte mit verschiedenen `TimeZone`-Typen sind unterschiedlich und können nicht gemischt werden, können aber mithilfe der Methode `DateTime::with_timezone` ineinander umgewandelt werden.

Sie können das aktuelle Datum und die Uhrzeit in der UTC-Zeitzone (`Utc::now()`) oder in der lokalen Zeitzone (`Local::now()`) abrufen.

```rust
use chrono::prelude::*;

let utc: DateTime<Utc> = Utc::now(); // z.B. `2014-11-28T12:45:59.324310806Z`
let local: DateTime<Local> = Local::now(); // z.B. `2014-11-28T21:45:59.324310806+09:00`
```

Zusätzlich können Sie eigene Datums- und Zeitangaben erstellen:

```rust
use chrono::offset::MappedLocalTime;
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap(); // `2014-07-08T09:10:11Z`
```

### Formatierung und Parsing

Die Formatierung erfolgt über die `format`-Methode, deren Format dem bekannten strftime-Format entspricht.

Die standardmäßige `to_string`-Methode und der `{:?}`-Spezifizierer liefern ebenfalls eine angemessene Darstellung. Chrono bietet auch `to_rfc2822`- und `to_rfc3339`-Methoden für gängige Formate.

Chrono bietet jetzt auch Datumsformatierung in fast jeder Sprache ohne zusätzliche C-Bibliotheken. Diese Funktion ist unter der `unstable-locales`-Funktion verfügbar:

```rust
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 11, 28, 12, 0, 9).unwrap();
assert_eq!(dt.format("%Y-%m-%d %H:%M:%S").to_string(), "2014-11-28 12:00:09");
assert_eq!(dt.format_localized("%A %e %B %Y, %T", Locale::fr_BE).to_string(), 
           "vendredi 28 novembre 2014, 12:00:09");
```

Das Parsing kann auf zwei Arten erfolgen:

1. Das standardmäßige `FromStr`-Trait (und die `parse`-Methode auf Zeichenketten) kann verwendet werden, um `DateTime<FixedOffset>`, `DateTime<Utc>` und `DateTime<Local>`-Werte zu parsen.
2. `DateTime::parse_from_str` parst ein Datum und eine Uhrzeit mit einem Offset und gibt `DateTime<FixedOffset>` zurück.

```rust
use chrono::prelude::*;

let dt = "2014-11-28T12:00:09Z".parse::<DateTime<Utc>>().unwrap();
let fixed_dt = DateTime::parse_from_str("2014-11-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z").unwrap();
```

### Konvertierung zu/von Epochen-Timestamps

Konstruieren Sie `DateTime<Utc>` aus einem UNIX-Timestamp mit `DateTime::from_timestamp(seconds, nanoseconds)`.

Holen Sie sich den Timestamp (in Sekunden) von einem `DateTime` mit `DateTime.timestamp`. Zusätzlich können Sie die zusätzliche Anzahl von Nanosekunden mit `DateTime.timestamp_subsec_nanos` erhalten.

```rust
use chrono::{DateTime, Utc};

// Datetime aus Epoche konstruieren:
let dt: DateTime<Utc> = DateTime::from_timestamp(1_500_000_000, 0).unwrap();
assert_eq!(dt.to_rfc2822(), "Fri, 14 Jul 2017 02:40:00 +0000");

// Epochenwert aus Datetime holen:
let dt = DateTime::parse_from_rfc2822("Fri, 14 Jul 2017 02:40:00 +0000").unwrap();
assert_eq!(dt.timestamp(), 1_500_000_000);
```

## Einschränkungen

- Nur der proleptische gregorianische Kalender wird unterstützt (d.h., erweitert zur Unterstützung von Daten vor der Ära).
- Datumstypen sind auf ungefähr +/- 262.000 Jahre von der gemeinsamen Ära beschränkt.
- Zeittypen sind auf Nanosekundengenauigkeit beschränkt.
- Schaltsekunden können dargestellt werden, aber Chrono unterstützt sie nicht vollständig.
{/* Auto generated, origin file hash:10bcf1127b3b63767462c43c36ecf9da */}