# Cache

Middleware que fornece funcionalidade de cache.

O middleware Cache pode armazenar em cache o `StatusCode`, `Headers` e `Body` de uma `Response`. Para conteúdos já armazenados em cache, o middleware Cache enviará diretamente o conteúdo em cache da memória para o cliente ao processar solicitações subsequentes.

Nota: Este plugin não armazena em cache objetos `Response` cujo `Body` seja `ResBody::Stream`. Se aplicado a tal `Response`, o Cache não processará essas solicitações e nenhum erro ocorrerá.

## Principais Funcionalidades

- `CacheIssuer` fornece uma abstração para gerar chaves de cache. `RequestIssuer` é uma de suas implementações, permitindo definir quais partes da URL da solicitação e do `Method` da solicitação devem ser usadas para gerar a chave de cache. Você também pode definir sua própria lógica de geração de chaves de cache. A chave de cache não precisa necessariamente ser uma string; qualquer tipo que satisfaça as restrições `Hash + Eq + Send + Sync + 'static` pode ser usado como chave.

- `CacheStore` fornece operações para armazenar e recuperar dados. `MokaStore` é uma implementação de cache baseada em memória integrada, baseada em `moka`. Você também pode definir sua própria implementação.

- `Cache` é uma estrutura que implementa `Handler`. Ela também contém um campo interno `skipper`, que pode ser usado para especificar solicitações que devem ignorar o cache. Por padrão, usa `MethodSkipper` para ignorar todas as solicitações, exceto aquelas com `Method::GET`.

  Exemplo de código de implementação interna:

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Migração Rápida de Outros Frameworks

Se você já usou mecanismos de cache em outros frameworks, os seguintes mapeamentos conceituais ajudarão você a se adaptar mais rapidamente à implementação de cache do Salvo:

### Guia de Migração do Framework Rust

- **Migrando do Actix-web**: Plugins como `actix-web-cache` no Actix-web normalmente precisam ser introduzidos separadamente, enquanto o cache no Salvo faz parte da biblioteca principal.

  ```rust
  // Exemplo de cache no Actix-web
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Implementação correspondente no Salvo
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Guia de Migração para Frameworks em Outras Linguagens

- **Migrando do Go/Gin**: O Gin usa um padrão de middleware, que o Salvo também adota de maneira semelhante:

  ```go
  // Exemplo de cache no Gin
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Implementação correspondente no Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Migrando do Spring Boot**: O cache declarativo do Spring Boot precisa ser convertido para a configuração explícita de middleware do Salvo:

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Implementação correspondente no Salvo - aplicando cache no nível da rota
  let custom_issuer = YourCustomIssuer::new(); // Implemente a interface CacheIssuer
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Migrando do Express.js**: O middleware de cache do Express.js é conceitualmente semelhante ao do Salvo, mas a sintaxe difere:

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Implementação correspondente no Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

Ao migrar de outros frameworks, preste atenção a vários conceitos-chave do cache do Salvo:

1. **Geração de Chave de Cache** - Controlada pela interface `CacheIssuer`.
2. **Armazenamento de Cache** - Implementado pela interface `CacheStore`.
3. **Lógica de Ignorar Cache** - Personalizada pelo mecanismo `skipper`.

Por padrão, o Salvo armazena em cache apenas solicitações GET, o que está alinhado com o comportamento padrão da maioria dos frameworks.

_**Código de Exemplo**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* Auto generated, origin file hash:6ae106316ebd0ee4b0ba1fabf6fe7a3f */}