# WebTransport

WebTransport è un protocollo di trasporto di rete basato su HTTP/3, che fornisce capacità di comunicazione bidirezionale tra client e server garantendo bassa latenza, alta velocità di trasferimento e sicurezza.

## Casi d'Uso

WebTransport è particolarmente adatto per i seguenti scenari:

- **Applicazioni in Tempo Reale**: Giochi online, strumenti di collaborazione in tempo reale, videoconferenze e altre applicazioni che richiedono comunicazione a bassa latenza.
- **Trasferimento di File di Grandi Dimensioni**: Supporta la trasmissione dati ad alta velocità, ideale per lo streaming multimediale e il caricamento/scaricamento di file di grandi dimensioni.
- **Comunicazione Multiplexata**: Consente l'instaurazione simultanea di più flussi di dati bidirezionali e unidirezionali.
- **Comunicazione tramite Datagrammi**: Supporta la comunicazione tramite datagrammi senza garanzia di ordine o affidabilità, adatta a scenari con requisiti di tempo reale estremamente elevati.

Rispetto a WebSocket, WebTransport offre una latenza inferiore e modalità di comunicazione più flessibili, performando particolarmente meglio in ambienti di rete instabili.

## Implementazione in Salvo

Il framework Salvo fornisce supporto integrato per WebTransport, consentendo agli sviluppatori di costruire facilmente applicazioni basate su WebTransport. Le caratteristiche principali includono:

- Supporto per l'instaurazione di sessioni WebTransport
- Supporto per la comunicazione tramite flussi bidirezionali
- Supporto per la comunicazione tramite flussi unidirezionali
- Supporto per la trasmissione di datagrammi
- Flussi di comunicazione avviati dal server

### Esempio Semplice

Di seguito un esempio semplificato di implementazione di un server WebTransport utilizzando Salvo:

```rust
#[handler]
async fn connect(req: &mut Request) -> Result<(), salvo::Error> {
    let session = req.web_transport_mut().await.unwrap();
    
    // Gestione dei datagrammi
    if let Ok(Some((_, datagram))) = session.accept_datagram().await {
        // Elaborazione del datagramma ricevuto
        let mut resp = BytesMut::from(&b"Risposta: "[..]);
        resp.put(datagram);
        session.send_datagram(resp.freeze())?;
    }
    
    // Gestione dei flussi bidirezionali
    if let Ok(Some(webtransport::server::AcceptedBi::BidiStream(_, stream))) = session.accept_bi().await {
        let (send, recv) = salvo::proto::quic::BidiStream::split(stream);
        // Elaborazione dei dati del flusso bidirezionale
    }
    
    Ok(())
}
```

### Configurazione e Avvio

L'avvio di un'applicazione Salvo con supporto WebTransport richiede la configurazione di certificati TLS e di un listener QUIC:

```rust
let cert = include_bytes!("../certs/cert.pem").to_vec();
let key = include_bytes!("../certs/key.pem").to_vec();

// Configurazione del routing
let router = Router::new().push(Router::with_path("counter").goal(connect));

// Configurazione TLS
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

// Configurazione dei listener
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());
let acceptor = QuinnListener::new(config, ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;

// Avvio del server
Server::new(acceptor).serve(router).await;
```

## Esempio Completo

Per saperne di più sull'utilizzo di WebTransport in Salvo, consulta l'esempio completo su GitHub:
[https://github.com/salvo-rs/salvo/blob/main/examples/webtransport](https://github.com/salvo-rs/salvo/blob/main/examples/webtransport)

Questo esempio include implementazioni complete sia per il server che per il client, dimostrando come gestire vari tipi di comunicazione WebTransport.
{/* Auto generated, origin file hash:d98d4da0351033ac716bd9facbe3fa45 */}