# Cache 

Middleware fournissant des fonctionnalités de mise en cache.

Le middleware Cache peut mettre en cache le `StatusCode`, les `Headers` et le `Body` d'une `Response`. Pour le contenu déjà mis en cache, lors du traitement d'une requête ultérieure, le middleware Cache enverra directement le contenu stocké en mémoire au client.

Note : Ce plugin ne met pas en cache les `Response` dont le `Body` est de type `ResBody::Stream`. S'il est appliqué à ce type de `Response`, Cache ne traitera pas ces requêtes et ne générera pas d'erreur.

## Fonctionnalités principales

- `CacheIssuer` fournit une abstraction pour la génération des clés de cache. `RequestIssuer` est une de ses implémentations, permettant de définir quelles parties de l'URL de la requête ainsi que la `Method` sont utilisées pour générer la clé de cache. Vous pouvez également définir votre propre logique de génération de clés. La clé de cache n'est pas nécessairement une chaîne de caractères ; tout type satisfaisant les contraintes `Hash + Eq + Send + Sync + 'static` peut servir de clé.

- `CacheStore` fournit les opérations de stockage et de récupération des données. `MokaStore` est une implémentation de cache en mémoire intégrée, basée sur `moka`. Vous pouvez également définir votre propre implémentation.

- `Cache` est une structure implémentant `Handler`, contenant également un champ `skipper` permettant de spécifier les requêtes à exclure de la mise en cache. Par défaut, `MethodSkipper` est utilisé pour exclure toutes les requêtes sauf celles de type `Method::GET`.

  Exemple de code d'implémentation interne :

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Migration rapide depuis d'autres frameworks

Si vous avez déjà utilisé des mécanismes de cache dans d'autres frameworks, la correspondance conceptuelle suivante vous aidera à vous adapter plus rapidement à l'implémentation du cache de Salvo :

### Guide de migration depuis les frameworks Rust

- **Migration depuis Actix-web** : Les plugins comme `actix-web-cache` dans Actix-web nécessitent généralement une importation séparée, tandis que le cache de Salvo fait partie de la bibliothèque principale.

  ```rust
  // Exemple de cache Actix-web
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Implémentation correspondante dans Salvo
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Guide de migration depuis d'autres langages

- **Migration depuis Go/Gin** : Gin utilise un modèle de middleware, similaire à celui adopté par Salvo :

  ```go
  // Exemple de cache Gin
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Implémentation correspondante dans Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Migration depuis Spring Boot** : Le cache déclaratif de Spring Boot doit être converti en configuration explicite de middleware dans Salvo :

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Implémentation correspondante dans Salvo - Application du cache au niveau de la route
  let custom_issuer = YourCustomIssuer::new(); // Implémente l'interface CacheIssuer
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Migration depuis Express.js** : Le middleware de cache d'Express est conceptuellement similaire à celui de Salvo, mais la syntaxe diffère :

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Implémentation correspondante dans Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

Lors de la migration depuis d'autres frameworks, il est important de noter les concepts clés du cache Salvo :

1. **Génération des clés de cache** - Contrôlée via l'interface `CacheIssuer`.
2. **Stockage du cache** - Implémenté via l'interface `CacheStore`.
3. **Logique d'exclusion du cache** - Personnalisable via le mécanisme `skipper`.

Par défaut, Salvo ne met en cache que les requêtes GET, ce qui est cohérent avec le comportement par défaut de la plupart des frameworks.

_**Exemple de code**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* Auto generated, origin file hash:df2bc60555363c109d61ba033738ce41 */}