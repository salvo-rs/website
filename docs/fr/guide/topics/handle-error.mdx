# Gestion des erreurs

## Méthodes courantes de gestion des erreurs dans les applications Rust

La gestion des erreurs en Rust diffère de celle de langages comme Java, car elle n'utilise pas de blocs `try...catch`. L'approche habituelle consiste à définir un type d'erreur global au niveau de l'application :

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("io : `{0}`")]
    Io(#[from] io::Error),
    #[error("utf8 : `{0}`")]
    FromUtf8(#[from] FromUtf8Error),
    #[error("diesel : `{0}`")]
    Diesel(#[from] diesel::result::Error),
    ...
}

pub type AppResult<T> = Result<T, AppError>;
```

Ici, nous utilisons la bibliothèque `thiserror`, qui permet de définir facilement vos propres types d'erreurs personnalisés et de simplifier le code. Pour une écriture plus concise, nous définissons également un `AppResult`.

### thiserror et anyhow

Dans l'écosystème de gestion des erreurs en Rust, deux bibliothèques sont couramment utilisées : `thiserror` et `anyhow` :

- **thiserror** : Convient aux développeurs de bibliothèques pour définir des types d'erreurs clairs. Grâce à une macro dérivée, elle vous aide à implémenter le trait `std::error::Error` pour vos types d'erreurs personnalisés, tout en vous permettant de définir la représentation des erreurs. Lorsque vous construisez une bibliothèque ou avez besoin de fournir des types d'erreurs explicites aux utilisateurs, `thiserror` est le meilleur choix.

- **anyhow** : Convient aux développeurs d'applications, en fournissant un type d'erreur générique `anyhow::Error` capable de contenir toute erreur implémentant le trait `std::error::Error`. Elle se concentre davantage sur la propagation des erreurs que sur leur définition, ce qui la rend particulièrement adaptée au code de la couche application. Vous pouvez rapidement convertir diverses erreurs en `anyhow::Error`, réduisant ainsi le besoin d'écrire du code répétitif.

Dans certains scénarios, vous pourriez utiliser ces deux bibliothèques simultanément : utiliser `thiserror` pour définir les types d'erreurs dans une bibliothèque, et `anyhow` pour gérer et propager ces erreurs dans l'application.

## Gestion des erreurs dans les Handlers

Dans Salvo, les `Handler` rencontrent fréquemment diverses erreurs, telles que des erreurs de connexion à la base de données, des erreurs d'accès aux fichiers, des erreurs de connexion réseau, etc. Pour ce type d'erreurs, vous pouvez adopter l'approche de gestion des erreurs décrite ci-dessus :

```rust
#[handler]
async fn home() -> AppResult<()> {

}
```

Ici, `home` retourne directement un `AppResult<()>`. Mais comment cette erreur doit-elle être affichée ? Nous devons implémenter le trait `Writer` pour le type d'erreur personnalisé `AppResult`. Dans cette implémentation, nous pouvons décider comment afficher l'erreur :

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        res.render(Text::Plain("Je suis une erreur, hahaha !"));
    }
}
```

Les `Handler` de Salvo peuvent retourner un `Result`, à condition que les types `Ok` et `Err` dans le `Result` implémentent tous deux le trait `Writer`.

### Utilisation de anyhow pour la gestion des erreurs

Étant donné qu'`anyhow` est largement utilisé, Salvo offre une prise en charge intégrée de `anyhow::Error`. Lorsque la fonctionnalité `anyhow` est activée, `anyhow::Error` implémente le trait `Writer` et est mappé sur `InternalServerError` :

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Pour utiliser la fonctionnalité `anyhow`, vous devez activer la feature `anyhow` de Salvo dans Cargo.toml :

```toml
[dependencies]
salvo = { version = "*", features = ["anyhow"] }
anyhow = "1.0"
```

Ainsi, vos fonctions de traitement peuvent directement retourner un `anyhow::Result<T>` :

```rust
#[handler]
async fn home() -> anyhow::Result<impl Writer> {
    let data = fetch_data().context("Échec de la récupération des données")?;
    Ok(Text::Plain(data))
}
```

Les `Error` contiennent souvent des informations sensibles. En général, vous ne souhaitez pas qu'elles soient visibles par les utilisateurs ordinaires, car cela serait peu sécurisé et manquerait de confidentialité. Cependant, si vous êtes un développeur ou un administrateur du site, votre perspective pourrait être différente : vous pourriez souhaiter que les erreurs soient exposées de manière transparente, révélant les informations d'erreur les plus précises.

Comme vous pouvez le voir, dans la méthode `write`, nous avons accès aux références de `Request` et `Depot`, ce qui permet de mettre en œuvre facilement l'approche décrite ci-dessus :

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let user = depot.obtain::<User>();
        if user.is_admin {
            res.render(Text::Plain(e.to_string()));
        } else {
            res.render(Text::Plain("Je suis une erreur, hahaha !"));
        }
    }
}
```

## Affichage des pages d'erreur

Les pages d'erreur intégrées à Salvo répondent à la plupart des besoins, car elles peuvent afficher des pages Html, Json ou Xml en fonction du type de données de la requête. Cependant, dans certains cas, vous pourriez souhaiter personnaliser l'affichage des pages d'erreur.

Cela peut être réalisé en implémentant un `Catcher` personnalisé. Pour une explication détaillée, veuillez consulter la section [`Catcher`](../concepts/catcher.html).
{/* Auto generated, origin file hash:ccc3ad5dca846f6b6415dbe84e0c5166 */}