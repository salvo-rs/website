# Роутер

## Что такое маршрутизация

[`Router`](https://docs.rs/salvo_core/latest/salvo_core/routing/struct.Router.html) определяет, какой промежуточный слой (middleware) и обработчик (`Handler`) будут обрабатывать HTTP-запрос. Это самая фундаментальная и основная функциональность в Salvo.

Внутренне `Router` по сути состоит из серии фильтров. Когда приходит запрос, роутер и его потомки проверяются по порядку, сверху вниз, чтобы определить, могут ли они соответствовать запросу. Если соответствие успешно, промежуточные слои всей цепочки, образованной роутером и его дочерними роутерами, выполняются последовательно. Если в процессе обработки статус `Response` устанавливается на ошибку (4XX, 5XX) или перенаправление (3XX), последующие промежуточные слои и `Handler` будут пропущены. Вы также можете вручную вызвать `ctrl.skip_rest()`, чтобы пропустить оставшиеся промежуточные слои и `Handler`.

В процессе сопоставления существует объект информации о пути URL, который можно рассматривать как объект, который должен быть полностью "потреблён" фильтрами во время сопоставления. Если все фильтры в определённом Router успешно совпадают, и эта информация о пути URL была полностью потреблена, это считается "успешным совпадением".

Например:

```rust
Router::with_path("articles").get(list_articles).post(create_article);
```

Фактически эквивалентно:

```rust
Router::new()
    // PathFilter может фильтровать пути запросов. Он успешно совпадает, только если путь запроса содержит сегмент "articles".
    // В противном случае совпадение не удаётся. Например: /articles/123 совпадает успешно, а /articles_list/123
    // содержит "articles", но не совпадает из-за суффикса "_list".
    .filter(PathFilter::new("articles"))

    // Если корневой роутер совпадает успешно и метод запроса GET, внутренний дочерний роутер может совпасть успешно,
    // и запрос обрабатывается list_articles.
    .push(Router::new().filter(filters::get()).handle(list_articles))

    // Если корневой роутер совпадает успешно и метод запроса POST, внутренний дочерний роутер может совпасть успешно,
    // и запрос обрабатывается create_article.
    .push(Router::new().filter(filters::post()).handle(create_article));
```

При доступе `GET /articles/` это считается успешным совпадением, и выполняется `list_articles`. Однако при доступе `GET /articles/123` совпадение маршрута не удаётся и возвращается ошибка 404, потому что `Router::with_path("articles")` потребляет только часть `/articles` информации о пути URL, оставляя часть `/123` не потреблённой, поэтому совпадение считается неудачным. Чтобы добиться успешного совпадения, маршрут можно изменить на:

```rust
Router::with_path("articles/{**}").get(list_articles).post(create_article);
```

Здесь `{**}` соответствует любому оставшемуся пути, поэтому он может совпасть с `GET /articles/123` и выполнить `list_articles`.

## Плоское определение

Мы можем определять маршруты в плоском стиле:

```rust
Router::with_path("writers").get(list_writers).post(create_writer);
Router::with_path("writers/{id}").get(show_writer).patch(edit_writer).delete(delete_writer);
Router::with_path("writers/{id}/articles").get(list_writer_articles);
```

## Древовидное определение

Мы также можем определять маршруты в древовидной структуре, что является рекомендуемым подходом:

```rust
Router::with_path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```

Такая форма определения делает определения Router иерархическими, понятными и простыми для сложных проектов.

Многие методы в `Router` возвращают `Self` после вызова, что облегчает написание цепочечного кода. Иногда вам нужно решить, как маршрутизировать на основе определённых условий. Система маршрутизации также предоставляет функцию `then`, которую легко использовать:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::with_path("{id}").get(show_article))
            .then(|router|{
                if admin_mode() {
                    router.post(create_article).push(
                        Router::with_path("{id}").patch(update_article).delete(delete_writer)
                    )
                } else {
                    router
                }
            }),
    );
```

Этот пример означает, что маршруты для создания, редактирования и удаления статей добавляются только тогда, когда сервер находится в режиме `admin_mode`.

## Получение параметров из маршрутов

В приведённом выше коде `{id}` определяет параметр. Мы можем получить его значение через экземпляр `Request`:

```rust
#[handler]
async fn show_writer(req: &mut Request) {
    let id = req.param::<i64>("id").unwrap();
}
```

`{id}` соответствует сегменту в пути. Обычно `id` статьи — это просто число. В этом случае мы можем использовать регулярное выражение, чтобы ограничить правило соответствия для `id`, например `r"{id|\d+}"`.

Для числовых типов есть ещё более простой метод с использованием `<id:num>`. Конкретные обозначения:
- `{id:num}` соответствует любому количеству цифровых символов.
- `{id:num[10]}` соответствует точно определённому количеству цифровых символов; здесь 10 означает, что он соответствует ровно 10 цифрам.
- `{id:num(..10)}` соответствует от 1 до 9 цифровых символов.
- `{id:num(3..10)}` соответствует от 3 до 9 цифровых символов.
- `{id:num(..=10)}` соответствует от 1 до 10 цифровых символов.
- `{id:num(3..=10)}` соответствует от 3 до 10 цифровых символов.
- `{id:num(10..)}` соответствует как минимум 10 цифровым символам.

Вы также можете сопоставить все оставшиеся сегменты пути, используя `{**}`, `{*+}` или `{*?}`. Для лучшей читаемости кода вы можете добавить соответствующие имена, чтобы сделать семантику пути более ясной, например `{**file_path}`.

- `{**}`: представляет подстановочное соответствие, где соответствующая часть может быть пустой строкой. Например, путь `/files/{**rest_path}` соответствует `/files`, `/files/abc.txt`, `/files/dir/abc.txt`.
- `{*+}`: представляет подстановочное соответствие, где соответствующая часть должна существовать и не может быть пустой строкой. Например, путь `/files/{*+rest_path}` НЕ соответствует `/files`, но соответствует `/files/abc.txt`, `/files/dir/abc.txt`.
- `{*?}`: представляет подстановочное соответствие, где соответствующая часть может быть пустой строкой, но может содержать только один сегмент пути. Например, путь `/files/{*？rest_path}` НЕ соответствует `/files/dir/abc.txt`, но соответствует `/files`, `/files/abc.txt`.

Несколько выражений можно комбинировать для соответствия одному и тому же сегменту пути, например `/articles/article_{id:num}/`, `/images/{name}.{ext}`.

## Добавление промежуточного слоя

Промежуточный слой можно добавить через функцию `hoop` на роутере:

```rust
Router::new()
    .hoop(check_authed)
    .path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```

В этом примере корневой роутер использует `check_authed` для проверки, вошёл ли текущий пользователь в систему. На все дочерние роутеры влияет этот промежуточный слой.

Если пользователи только просматривают информацию о `writer` и статьи, мы можем предпочесть, чтобы они могли просматривать без входа в систему. Мы можем определить маршруты следующим образом:

```rust
Router::new()
    .push(
        Router::new()
            .hoop(check_authed)
            .path("writers")
            .post(create_writer)
            .push(Router::with_path("{id}").patch(edit_writer).delete(delete_writer)),
    )
    .push(
        Router::with_path("writers").get(list_writers).push(
            Router::with_path("{id}")
                .get(show_writer)
                .push(Router::with_path("articles").get(list_writer_articles)),
        ),
    );
```

Несмотря на то, что два роутера имеют одинаковое определение пути `path("articles")`, они всё равно могут быть добавлены к одному и тому же родительскому роутеру.

## Фильтры

`Router` внутренне использует фильтры, чтобы определить, соответствует ли маршрут. Фильтры поддерживают базовые логические операции с использованием `or` или `and`. Роутер может содержать несколько фильтров; когда все фильтры успешно совпадают, маршрут успешно совпадает.

Информация о пути веб-сайта представляет собой древовидную структуру, но эта древовидная структура не эквивалентна древовидной структуре организации роутеров. Путь веб-сайта может соответствовать нескольким узлам роутера. Например, некоторый контент по пути `articles/` может требовать входа для просмотра, а другой — нет. Мы можем организовать подпути, требующие проверки входа, под роутером, содержащим промежуточный слой проверки входа, а те, которые не требуют проверки, — под другим роутером без него:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::with_path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

Роутеры используют фильтры для фильтрации запросов и отправки их в соответствующий промежуточный слой и `Handler` для обработки.

`path` и `method` — два наиболее часто используемых фильтра. `path` используется для сопоставления информации о пути; `method` используется для сопоставления метода запроса, например GET, POST, PATCH и т.д.

Мы можем соединять фильтры роутера с помощью `and`, `or`:

```rust
Router::with_filter(filters::path("hello").and(filters::get()));
```

### Фильтр пути

Фильтры на основе путей запросов используются чаще всего. Фильтры пути могут определять параметры, например:

```rust
Router::with_path("articles/{id}").get(show_article);
Router::with_path("files/{**rest_path}").get(serve_file)
```

В `Handler` их можно получить через функцию `get_param` объекта `Request`:

```rust
#[handler]
pub async fn show_article(req: &mut Request) {
    let article_id = req.param::<i64>("id");
}

#[handler]
pub async fn serve_file(req: &mut Request) {
    let rest_path = req.param::<i64>("rest_path");
}
```

### Фильтр метода

Фильтрует запросы на основе `Method` HTTP-запроса, например:

```rust
Router::new().get(show_article).patch(update_article).delete(delete_article);
```

Здесь `get`, `patch`, `delete` — все это фильтры Method. Это фактически эквивалентно:

```rust
use salvo::routing::filter;

let mut root_router = Router::new();
let show_router = Router::with_filter(filters::get()).handle(show_article);
let update_router = Router::with_filter(filters::patch()).handle(update_article);
let delete_router = Router::with_filter(filters::get()).handle(delete_article);
Router::new().push(show_router).push(update_router).push(delete_router);
```

## Пользовательский Wisp

Для определённых часто встречающихся выражений соответствия мы можем назначить короткое имя через `PathFilter::register_wisp_regex` или `PathFilter::register_wisp_builder`. Например, формат GUID часто встречается в путях. Обычный способ — писать это так каждый раз, когда требуется соответствие:

```rust
Router::with_path("/articles/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
Router::with_path("/users/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
```

Писать это сложное регулярное выражение каждый раз чревато ошибками и делает код менее читаемым. Вместо этого вы можете сделать следующее:

```rust
use salvo::routing::filter::PathFilter;

#[tokio::main]
async fn main() {
    let guid = regex::Regex::new("[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}").unwrap();
    PathFilter::register_wisp_regex("guid", guid);
    Router::new()
        .push(Router::with_path("/articles/{id:guid}").get(show_article))
        .push(Router::with_path("/users/{id:guid}").get(show_user));
}
```

Вам нужно зарегистрировать его только один раз. После этого вы можете напрямую использовать простую нотацию, такую как `{id:guid}`, для сопоставления GUID, упрощая написание кода.

## Переходя с веб-фреймворка на основе контроллеров, как понять Router?

Основные различия между веб-фреймворками, спроектированными на основе маршрутизации (такими как Salvo), и традиционными MVC или фреймворками, спроектированными на основе контроллеров, заключаются в следующем:

- **Гибкость**: Дизайн маршрутизации позволяет более гибко определять потоки обработки запросов, обеспечивая точный контроль над логикой для каждого пути. Например, в Salvo вы можете напрямую определять функции-обработчики для конкретных путей:
  ```rust
  Router::with_path("articles").get(list_articles).post(create_article);
  ```
  В дизайне на основе контроллеров вам обычно нужно сначала определить класс контроллера, а затем определить несколько методов внутри класса для обработки различных запросов:
  ```java
  @Controller
  public class ArticleController {
      @GetMapping("/articles")
      public List<Article> listArticles() { /* ... */ }
      
      @PostMapping("/articles")
      public Article createArticle(@RequestBody Article article) { /* ... */ }
  }
  ```

- **Интеграция промежуточного слоя**: Фреймворки маршрутизации обычно предоставляют более лаконичный способ интеграции промежуточного слоя, позволяя применять промежуточный слой к определённым маршрутам. Промежуточный слой Salvo может быть точно применён к конкретным маршрутам:
  ```rust
  Router::new()
      .push(
          Router::with_path("admin/articles")
              .hoop(admin_auth_middleware)  // Применить промежуточный слой аутентификации только к маршрутам администратора
              .get(list_all_articles)
              .post(create_article),
      )
      .push(
          Router::with_path("articles")  // Публичные маршруты не требуют аутентификации
              .get(list_public_articles),
      );
  ```

- **Организация кода**: Дизайн маршрутизации стремится организовывать код на основе функциональности или конечных точек API, а не на основе разделения Model-View-Controller в MVC.
  Дизайн маршрутизации поощряет организацию кода в соответствии с функциональностью конечной точки API:
  ```rust
  // user_routes.rs — маршруты и логика обработки, связанные с пользователями
  pub fn user_routes() -> Router {
      Router::with_path("users")
          .get(list_users)
          .post(create_user)
          .push(Router::with_path("{id}").
{/* Auto generated, origin file hash:cff6ff452b87f5758f518db1f13a198e */}