# WebTransport

WebTransport est un protocole de transport réseau basé sur HTTP/3, offrant des capacités de communication bidirectionnelle entre clients et serveurs tout en garantissant une faible latence, un débit élevé et la sécurité.

## Cas d'utilisation

WebTransport est particulièrement adapté aux scénarios suivants :

- **Applications en temps réel** : Jeux en ligne, outils de collaboration en temps réel, visioconférence et autres applications nécessitant une communication à faible latence.
- **Transferts de fichiers volumineux** : Prend en charge la transmission de données à haut débit, idéale pour le streaming multimédia et le téléchargement/upload de fichiers volumineux.
- **Communication multiplexée** : Permet d'établir simultanément plusieurs flux de données bidirectionnels et unidirectionnels.
- **Communication par datagrammes** : Prend en charge la communication par datagrammes sans garantie d'ordre ou de fiabilité, adaptée aux scénarios nécessitant des exigences de temps réel extrêmement élevées.

Comparé à WebSocket, WebTransport offre une latence plus faible et des modes de communication plus flexibles, avec des performances particulièrement meilleures dans des environnements réseau instables.

## Implémentation dans Salvo

Le framework Salvo fournit une prise en charge intégrée de WebTransport, permettant aux développeurs de créer facilement des applications basées sur WebTransport. Les fonctionnalités clés incluent :

- Prise en charge de l'établissement de sessions WebTransport
- Prise en charge de la communication par flux bidirectionnels
- Prise en charge de la communication par flux unidirectionnels
- Prise en charge de la transmission par datagrammes
- Flux de communication initiés par le serveur

### Exemple simplifié

Voici un exemple simplifié d'implémentation d'un serveur WebTransport avec Salvo :

```rust
#[handler]
async fn connect(req: &mut Request) -> Result<(), salvo::Error> {
    let session = req.web_transport_mut().await.unwrap();
    
    // Traitement des datagrammes
    if let Ok(Some((_, datagram))) = session.accept_datagram().await {
        // Traitement du datagramme reçu
        let mut resp = BytesMut::from(&b"Response: "[..]);
        resp.put(datagram);
        session.send_datagram(resp.freeze())?;
    }
    
    // Traitement des flux bidirectionnels
    if let Ok(Some(webtransport::server::AcceptedBi::BidiStream(_, stream))) = session.accept_bi().await {
        let (send, recv) = salvo::proto::quic::BidiStream::split(stream);
        // Traitement des données du flux bidirectionnel
    }
    
    Ok(())
}
```

### Configuration et démarrage

Le démarrage d'une application Salvo avec prise en charge WebTransport nécessite la configuration de certificats TLS et d'un écouteur QUIC :

```rust
let cert = include_bytes!("../certs/cert.pem").to_vec();
let key = include_bytes!("../certs/key.pem").to_vec();

// Configuration du routage
let router = Router::new().push(Router::with_path("counter").goal(connect));

// Configuration TLS
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

// Configuration des écouteurs
let listener = TcpListener::new(("0.0.0.0", 8698)).rustls(config.clone());
let acceptor = QuinnListener::new(config, ("0.0.0.0", 8698))
    .join(listener)
    .bind()
    .await;

// Démarrage du serveur
Server::new(acceptor).serve(router).await;
```

## Exemple complet

Pour en savoir plus sur l'utilisation de WebTransport dans Salvo, consultez l'exemple complet sur GitHub :
[https://github.com/salvo-rs/salvo/blob/main/examples/webtransport](https://github.com/salvo-rs/salvo/blob/main/examples/webtransport)

Cet exemple inclut des implémentations complètes pour le serveur et le client, démontrant comment gérer différents types de communication WebTransport.
{/* Auto generated, origin file hash:d98d4da0351033ac716bd9facbe3fa45 */}