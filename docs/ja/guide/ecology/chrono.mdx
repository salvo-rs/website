---
title: Rust 日付・時刻ライブラリ
---

# Chrono: Rust 日付・時刻ライブラリ

[Chrono](https://docs.rs/chrono/latest/chrono/) は、グレゴリオ暦における正確な日付・時刻操作に必要な全機能を提供することを目指しています：

- `DateTime`型はデフォルトでタイムゾーンを認識し、同時にタイムゾーン非依存の独立型も提供します。
- 無効または曖昧な日付・時刻を生成する可能性のある操作は`Option`または`MappedLocalTime`を返します。
- strftimeにインスパイアされた日付・時刻フォーマット構文による設定可能な解析・フォーマット機能。
- `Local`タイムゾーンはオペレーティングシステムの現在のタイムゾーンで動作します。
- 型と操作の実装は合理的な効率性を考慮しています。
- バイナリサイズを制限するため、Chronoはデフォルトでタイムゾーンデータを含みません。完全なタイムゾーンサポートには付属クレート`Chrono-TZ`または`tzfile`を使用してください。

## 機能特性

[Chrono](https://docs.rs/chrono/latest/chrono/) は様々なランタイム環境とオペレーティングシステムをサポートし、いくつかの有効化・無効化可能な機能を持っています。

### デフォルト機能：

- `alloc`：メモリ割り当てに依存する機能（主に文字列フォーマット）を有効化。
- `std`：標準ライブラリに依存する機能を有効化。これは`alloc`の上位セットで、標準ライブラリの型とトレイトとの相互運用性を追加します。
- `clock`：ローカルタイムゾーン（`Local`）の読み取り機能を有効化。これは`now`の上位セットです。
- `now`：システム時刻（`now`）の読み取り機能を有効化。
- `wasmbind`：wasm32ターゲット向けにJS Date APIとのインターフェースを提供。

### オプション機能：

- `serde`：serdeによるシリアライズ/デシリアライズを有効化。
- `rkyv`：非推奨、`rkyv-*`機能を使用してください。
- `rkyv-16`、`rkyv-32`、`rkyv-64`：rkyvによるシリアライズ/デシリアライズを有効化（それぞれ16ビット、32ビット、64ビット整数を使用）。
- `rkyv-validation`：bytecheckによるrkyv検証サポートを有効化。
- `arbitrary`：Arbitraryクレートを使用して型の任意のインスタンスを構築。
- `unstable-locales`：ローカライゼーションを有効化。これにより`_localized`サフィックス付きの様々なメソッドが追加されます。

## 概要

### 時間差/期間

Chronoは時間スパンの大きさを表す`TimeDelta`型を提供します。これは秒とナノ秒で表される「正確な」期間であり、日や月などの「名目上の」構成要素は表しません。

`TimeDelta`型は以前`Duration`という名前でした（型エイリアスとして引き続き利用可能）。類似の`core::time::Duration`との顕著な違いは、符号付き値であることです。

### 日付と時刻

Chronoはタイムゾーン内の日付と時刻を表す`DateTime`型を提供します。

`DateTime`はタイムゾーンを認識し、ローカル日付をUTC日付に変換する方法とその逆を定義する`TimeZone`オブジェクトから構築する必要があります。よく知られた`TimeZone`実装は3つあります：

- `Utc`はUTCタイムゾーンを指定します。最も効率的です。
- `Local`はシステムのローカルタイムゾーンを指定します。
- `FixedOffset`はUTC+09:00やUTC-10:30などの任意の固定タイムゾーンを指定します。

異なる`TimeZone`型の`DateTime`は別個の型であり混在できませんが、`DateTime::with_timezone`メソッドを使用して相互変換できます。

現在の日付と時刻はUTCタイムゾーン（`Utc::now()`）またはローカルタイムゾーン（`Local::now()`）で取得できます。

```rust
use chrono::prelude::*;

let utc: DateTime<Utc> = Utc::now(); // 例：`2014-11-28T12:45:59.324310806Z`
let local: DateTime<Local> = Local::now(); // 例：`2014-11-28T21:45:59.324310806+09:00`
```

さらに、独自の日付と時刻を作成することもできます：

```rust
use chrono::offset::MappedLocalTime;
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap(); // `2014-07-08T09:10:11Z`
```

### フォーマットと解析

フォーマットは`format`メソッドで行われ、そのフォーマットは馴染みのあるstrftimeフォーマットと同等です。

デフォルトの`to_string`メソッドと`{:?}`指定子も合理的な表現を提供します。Chronoは一般的なフォーマット用に`to_rfc2822`と`to_rfc3339`メソッドも提供します。

Chronoは現在、追加のCライブラリなしでほぼすべての言語での日付フォーマット機能を提供します。この機能は`unstable-locales`特性で利用可能です：

```rust
use chrono::prelude::*;

let dt = Utc.with_ymd_and_hms(2014, 11, 28, 12, 0, 9).unwrap();
assert_eq!(dt.format("%Y-%m-%d %H:%M:%S").to_string(), "2014-11-28 12:00:09");
assert_eq!(dt.format_localized("%A %e %B %Y, %T", Locale::fr_BE).to_string(), 
           "vendredi 28 novembre 2014, 12:00:09");
```

解析は2つの方法で行えます：

1. 標準の`FromStr`トレイト（および文字列の`parse`メソッド）は`DateTime<FixedOffset>`、`DateTime<Utc>`、`DateTime<Local>`値の解析に使用できます。
2. `DateTime::parse_from_str`はオフセット付きの日付と時刻を解析し、`DateTime<FixedOffset>`を返します。

```rust
use chrono::prelude::*;

let dt = "2014-11-28T12:00:09Z".parse::<DateTime<Utc>>().unwrap();
let fixed_dt = DateTime::parse_from_str("2014-11-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z").unwrap();
```

### EPOCHタイムスタンプとの変換

UNIXタイムスタンプから`DateTime<Utc>`を構築するには`DateTime::from_timestamp(seconds, nanoseconds)`を使用します。

`DateTime`からタイムスタンプ（秒単位）を取得するには`DateTime.timestamp`を使用します。さらに、追加のナノ秒数を取得するには`DateTime.timestamp_subsec_nanos`を使用できます。

```rust
use chrono::{DateTime, Utc};

// epochからdatetimeを構築：
let dt: DateTime<Utc> = DateTime::from_timestamp(1_500_000_000, 0).unwrap();
assert_eq!(dt.to_rfc2822(), "Fri, 14 Jul 2017 02:40:00 +0000");

// datetimeからepoch値を取得：
let dt = DateTime::parse_from_rfc2822("Fri, 14 Jul 2017 02:40:00 +0000").unwrap();
assert_eq!(dt.timestamp(), 1_500_000_000);
```

## 制限事項

- 順方向のグレゴリオ暦のみをサポート（より早い日付をサポートするように拡張）。
- 日付型は紀元前後約262,000年までに制限。
- 時刻型はナノ秒精度に制限。
- 閏秒を表現可能だが、Chronoは完全にはサポートしていない。
{/* 本行由工具自动生成,原文哈希值:67733bfd2ba618b44f19c1449b096c42 */}