---
title: Rust-Fehlerbehandlungsbibliotheken
---

# Rust-Fehlerbehandlungsbibliotheken

- (thiserror)[https://docs.rs/thiserror/latest/thiserror/] bietet bequeme Ableitungsmakros für benutzerdefinierte Fehlertypen.

- (snafu)[https://docs.rs/snafu/latest/snafu/] ist ein Framework für kontextbezogene Fehlerbehandlung und -berichterstattung.

- (anyhow)[https://docs.rs/anyhow/latest/anyhow/] ist eine flexible Bibliothek für Fehlerbehandlung und -berichterstattung.

## thiserror vs snafu

### thiserror

thiserror ist eine leichtgewichtige Bibliothek, die Ableitungsmakros zur einfachen Fehlerdefinition bereitstellt.

Merkmale:
- Prägnante Syntax mit geringem Boilerplate-Aufwand
- Geeignet für die Erstellung von Fehlertyp-Bibliotheken und APIs
- Wird typischerweise für Bibliotheken verwendet, die von anderen genutzt werden

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DataError {
    #[error("Datenbankfehler: {0}")]
    DatabaseError(#[from] sqlx::Error),
    
    #[error("Validierungsfehler: {0}")]
    ValidationError(String),
    
    #[error("Datensatz nicht gefunden")]
    NotFound,
}
```

### snafu

snafu bietet ein umfassenderes Framework für Fehlerbehandlung mit Fokus auf Fehlerkontext und Fehlerketten.

Merkmale:
- Ermutigt präzisere Fehlerkontext-Ergänzung durch "Kontext-Selektor"-Muster
- Empfiehlt das Muster "Ein Fehler-Enum pro Modul"
- Unterstützt strukturierte und Tupel-basierte Fehlervarianten
- Eingebaute Backtrace-Unterstützung

```rust
use snafu::{Snafu, ResultExt, Backtrace};

#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("Konfigurationsdatei {filename:?} konnte nicht gelesen werden"))]
    ReadConfig {
        filename: String,
        source: std::io::Error,
        backtrace: Backtrace,
    },
    
    // Tupel-Stil ist ebenfalls möglich
    #[snafu(display("IO-Fehler aufgetreten"))]
    Io(#[snafu(source)] std::io::Error, #[snafu(backtrace)] Backtrace),
}

// Beispiel für Kontext-Selektor
fn read_config(path: &str) -> Result<Config, Error> {
    std::fs::read_to_string(path).context(ReadConfigSnafu { filename: path })?;
    // ...
}
```

### Vergleich

| Merkmal | thiserror | snafu |
|---------|-----------|-------|
| Syntax-Prägnanz | Prägnanter | Ausführlicher |
| Fehlerkontext | Grundlegende Unterstützung | Umfangreiche Kontextmechanismen |
| Projekteignung | Kleine bis mittlere Projekte | Mittlere bis große Projekte |
| Codezeilen pro Fehler | Ca. 2 Zeilen | Ca. 5 Zeilen |
| Fehlerorganisation | Typischerweise einzelnes Fehler-Enum | Ermutigt modulare Fehler-Enums |
| Backtrace-Unterstützung | Keine eingebaute Unterstützung | Eingebaute Unterstützung |

**Empfehlung**:
- **Wählen Sie thiserror**, wenn Sie einfache, klare Fehlertypen benötigen, insbesondere in Bibliotheken
- **Wählen Sie snafu**, wenn Sie strukturiertere Fehlerbehandlung benötigen, besonders in großen Anwendungen

## anyhow

anyhow ist eine Fehlerbehandlungsbibliothek mit anderem Ansatz, die sich auf Anwendungen statt Bibliotheken konzentriert.

Merkmale:
- Entwickelt für Fehlerbehandlung in Anwendungen, nicht in Bibliotheken
- Bietet dynamischen `anyhow::Error`-Typ, der jeden Fehler enthalten kann, der das `Error`-Trait implementiert
- Vereinfacht die Handhabung über mehrere Fehlertypen hinweg
- Erfordert keine Definition benutzerdefinierter Fehlertypen

```rust
use anyhow::{Context, Result};

fn main() -> Result<()> {
    let config = std::fs::read_to_string("config.json")
        .context("Konfigurationsdatei konnte nicht gelesen werden")?;
        
    let app_config: AppConfig = serde_json::from_str(&config)
        .context("Ungültiges Konfigurationsformat")?;
        
    // Verwendung von Result<T> als Typalias für Result<T, anyhow::Error>
    Ok(())
}
```

**anyhow vs thiserror/snafu**:
- anyhow konzentriert sich auf Fehlerbehandlung bei schneller Anwendungsentwicklung
- thiserror/snafu konzentrieren sich auf präzise Fehlertyp-Hierarchien
- anyhow wird typischerweise in Anwendungscode verwendet
- thiserror/snafu werden typischerweise in Bibliothekscode verwendet

In der Praxis werden anyhow und thiserror oft gemeinsam verwendet: Bibliotheken definieren präzise Fehlertypen mit thiserror, während Anwendungen anyhow zur Behandlung verschiedener Fehlerquellen nutzen.
{/* 本行由工具自动生成,原文哈希值:e786d782f2c0d052350def02a332c83f */}