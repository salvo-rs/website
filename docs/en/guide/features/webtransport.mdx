# WebTransport

WebTransport is a network transport protocol based on HTTP/3, providing bidirectional communication capabilities between clients and servers while ensuring low latency, high throughput, and security.

## Use Cases

WebTransport is particularly suitable for the following scenarios:

- **Real-time Applications**: Online gaming, real-time collaboration tools, video conferencing, and other applications requiring low-latency communication.
- **Large File Transfers**: Supports high-throughput data transmission, ideal for media streaming and large file uploads/downloads.
- **Multiplexed Communication**: Allows simultaneous establishment of multiple bidirectional and unidirectional data streams.
- **Datagram Communication**: Supports datagram communication without guaranteed order or reliability, suitable for scenarios with extremely high real-time requirements.

Compared to WebSocket, WebTransport offers lower latency and more flexible communication patterns, especially performing better in unstable network environments.

## Salvo Implementation

The Salvo framework provides built-in support for WebTransport, allowing developers to easily build WebTransport-based applications. Key features include:

- Support for establishing WebTransport sessions
- Support for bidirectional stream communication
- Support for unidirectional stream communication
- Support for datagram transmission
- Server-initiated communication streams

### Simple Example

Below is a simplified example of implementing a WebTransport server using Salvo:

```rust
#[handler]
async fn connect(req: &mut Request) -> Result<(), salvo::Error> {
    let session = req.web_transport_mut().await.unwrap();
    
    // Handle datagrams
    if let Ok(Some((_, datagram))) = session.accept_datagram().await {
        // Process received datagram
        let mut resp = BytesMut::from(&b"Response: "[..]);
        resp.put(datagram);
        session.send_datagram(resp.freeze())?;
    }
    
    // Handle bidirectional streams
    if let Ok(Some(webtransport::server::AcceptedBi::BidiStream(_, stream))) = session.accept_bi().await {
        let (send, recv) = salvo::proto::quic::BidiStream::split(stream);
        // Process bidirectional stream data
    }
    
    Ok(())
}
```

### Configuration and Startup

Starting a Salvo application with WebTransport support requires configuring TLS certificates and a QUIC listener:

```rust
let cert = include_bytes!("../certs/cert.pem").to_vec();
let key = include_bytes!("../certs/key.pem").to_vec();

// Configure routing
let router = Router::new().push(Router::with_path("counter").goal(connect));

// Configure TLS
let config = RustlsConfig::new(Keycert::new().cert(cert.as_slice()).key(key.as_slice()));

// Set up listeners
let listener = TcpListener::new(("0.0.0.0", 5800)).rustls(config.clone());
let acceptor = QuinnListener::new(config, ("0.0.0.0", 5800))
    .join(listener)
    .bind()
    .await;

// Start server
Server::new(acceptor).serve(router).await;
```

## Complete Example

To learn more about using WebTransport in Salvo, check out the complete example on GitHub:
[https://github.com/salvo-rs/salvo/blob/main/examples/webtransport](https://github.com/salvo-rs/salvo/blob/main/examples/webtransport)

This example includes complete implementations for both server and client, demonstrating how to handle various types of WebTransport communication.