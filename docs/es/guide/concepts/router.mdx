# Router

## ¿Qué es el enrutamiento?

[`Router`](https://docs.rs/salvo_core/latest/salvo_core/routing/struct.Router.html) define qué middleware y `Handler` procesarán una solicitud HTTP. Esta es la funcionalidad más básica y central en Salvo.

Internamente, un `Router` está compuesto por una serie de filtros (Filter). Cuando llega una solicitud, el enrutador prueba secuencialmente, de arriba hacia abajo, si él mismo y sus descendientes pueden coincidir con la solicitud. Si la coincidencia es exitosa, ejecuta secuencialmente los middleware de toda la cadena formada por el enrutador y sus descendientes. Si durante el procesamiento el estado de la `Response` se establece como error (4XX, 5XX) o redirección (3XX), se omitirán los middleware y `Handler` posteriores. También puedes llamar manualmente a `ctrl.skip_rest()` para omitir los middleware y `Handler` posteriores.

Durante el proceso de coincidencia, existe una información de ruta URL, que puede considerarse como un objeto que debe ser completamente consumido por los filtros durante la coincidencia. Si todos los filtros en un Router coinciden con éxito y esta información de ruta URL ha sido completamente consumida, se considerará una "coincidencia exitosa".

Por ejemplo:

```rust
Router::with_path("articles").get(list_articles).post(create_article);
```

Es funcionalmente equivalente a:

```rust
Router::new()
    // PathFilter puede filtrar la ruta de la solicitud. Solo coincidirá si el segmento de la ruta contiene 'articles'.
    // De lo contrario, la coincidencia fallará. Ej: /articles/123 coincide, mientras que /articles_list/123
    // contiene 'articles' pero no coincide debido al '_list' posterior.
    .filter(PathFilter::new("articles"))

    // Si la raíz coincide y el método de la solicitud es GET, la subruta interna coincidirá
    // y la solicitud será manejada por list_articles.
    .push(Router::new().filter(filters::get()).handle(list_articles))

    // Si la raíz coincide y el método de la solicitud es POST, la subruta interna coincidirá
    // y la solicitud será manejada por create_article.
    .push(Router::new().filter(filters::post()).handle(create_article));
```

Si se accede a `GET /articles/`, se considera una coincidencia exitosa y se ejecuta `list_articles`. Sin embargo, si se accede a `GET /articles/123`, la coincidencia falla y se devuelve un error 404, porque `Router::with_path("articles")` solo consumió `/articles` de la información de ruta URL, dejando `/123` sin consumir, por lo que se considera un fallo. Para que coincida, la ruta puede modificarse así:

```rust
Router::with_path("articles/{**}").get(list_articles).post(create_article);
```

Aquí, `{**}` coincidirá con cualquier ruta sobrante, permitiendo que `GET /articles/123` ejecute `list_articles`.

## Definición plana

Podemos definir rutas en un estilo plano:

```rust
Router::with_path("writers").get(list_writers).post(create_writer);
Router::with_path("writers/{id}").get(show_writer).patch(edit_writer).delete(delete_writer);
Router::with_path("writers/{id}/articles").get(list_writer_articles);
```

## Definición en árbol

También podemos definir rutas en forma de árbol, que es el método recomendado:

```rust
Router::with_path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```

Esta forma de definición hace que la estructura del Router sea clara y sencilla, especialmente para proyectos complejos.

Muchos métodos en `Router` devuelven `Self` para permitir encadenamiento. A veces, necesitas decidir el enrutamiento basado en ciertas condiciones. El sistema también proporciona la función `then`, fácil de usar:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::with_path("{id}").get(show_article))
            .then(|router|{
                if admin_mode() {
                    router.post(create_article).push(
                        Router::with_path("{id}").patch(update_article).delete(delete_writer)
                    )
                } else {
                    router
                }
            }),
    );
```

Este ejemplo agrega rutas para crear, editar y eliminar artículos solo cuando el servidor está en `admin_mode`.

## Obtención de parámetros desde la ruta

En el código anterior, `{id}` define un parámetro. Podemos obtener su valor a través de la instancia `Request`:

```rust
#[handler]
async fn show_writer(req: &mut Request) {
    let id = req.param::<i64>("id").unwrap();
}
```

`{id}` coincide con un segmento de la ruta. Normalmente, el `id` de un artículo es solo un número. Podemos usar expresiones regulares para restringir la coincidencia, como `r"{id|\d+}"`.

Para tipos numéricos, hay un método más simple usando `<id:num>`, con las siguientes variantes:
- `{id:num}`: coincide con cualquier cantidad de dígitos.
- `{id:num[10]}`: coincide exactamente con 10 dígitos.
- `{id:num(..10)}`: coincide con 1 a 9 dígitos.
- `{id:num(3..10)}`: coincide con 3 a 9 dígitos.
- `{id:num(..=10)}`: coincide con 1 a 10 dígitos.
- `{id:num(3..=10)}`: coincide con 3 a 10 dígitos.
- `{id:num(10..)}`: coincide con al menos 10 dígitos.

También se puede usar `{**}`, `{*+}` o `{*?}` para coincidir con todos los segmentos restantes de la ruta. Para mejorar la legibilidad, se puede agregar un nombre, como `{**file_path}`.

- `{**}`: Coincide con una cadena vacía o cualquier segmento. Ej: `/files/{**rest_path}` coincide con `/files`, `/files/abc.txt`, `/files/dir/abc.txt`.
- `{*+}`: Coincide con al menos un segmento (no cadena vacía). Ej: `/files/{*+rest_path}` no coincide con `/files`, pero sí con `/files/abc.txt`, `/files/dir/abc.txt`.
- `{*?}`: Coincide con cero o un segmento. Ej: `/files/{*?rest_path}` no coincide con `/files/dir/abc.txt`, pero sí con `/files` y `/files/abc.txt`.

Se pueden combinar múltiples expresiones para un mismo segmento, como `/articles/article_{id:num}/` o `/images/{name}.{ext}`.

## Agregar middleware

Se puede agregar middleware usando la función `hoop` en el enrutador:

```rust
Router::new()
    .hoop(check_authed)
    .path("writers")
    .get(list_writers)
    .post(create_writer)
    .push(
        Router::with_path("{id}")
            .get(show_writer)
            .patch(edit_writer)
            .delete(delete_writer)
            .push(Router::with_path("articles").get(list_writer_articles)),
    );
```

En este ejemplo, la ruta raíz usa `check_authed` para verificar si el usuario ha iniciado sesión. Todas las subrutas se ven afectadas por este middleware.

Si los usuarios solo desean ver información de `writer` y artículos, podríamos permitir el acceso sin autenticación. Podemos definir las rutas así:

```rust
Router::new()
    .push(
        Router::new()
            .hoop(check_authed)
            .path("writers")
            .post(create_writer)
            .push(Router::with_path("{id}").patch(edit_writer).delete(delete_writer)),
    )
    .push(
        Router::with_path("writers").get(list_writers).push(
            Router::with_path("{id}")
                .get(show_writer)
                .push(Router::with_path("articles").get(list_writer_articles)),
        ),
    );
```

Aunque dos rutas tienen la misma definición `path("articles")`, aún pueden agregarse al mismo enrutador padre.

## Filtros

Un `Router` determina la coincidencia a través de filtros internos. Los filtros admiten operaciones lógicas básicas como `or` y `and`. Un enrutador puede contener múltiples filtros; coincide cuando todos los filtros coinciden con éxito.

La estructura de rutas de un sitio web es jerárquica, pero no necesariamente idéntica a la estructura del enrutador. Una ruta del sitio puede corresponder a múltiples nodos de enrutamiento. Por ejemplo, algunos contenidos bajo `articles/` pueden requerir autenticación, mientras que otros no. Podemos organizar las subrutas que requieren autenticación bajo un enrutador con middleware de verificación, y las que no, bajo otro sin él:

```rust
Router::new()
    .push(
        Router::with_path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::with_path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

El enrutamiento utiliza filtros para dirigir solicitudes a los middleware y `Handler` correspondientes.

`path` y `method` son dos de los filtros más comunes. `path` coincide con la ruta; `method` coincide con el método HTTP (GET, POST, PATCH, etc.).

Podemos conectar filtros usando `and` y `or`:

```rust
Router::with_filter(filters::path("hello").and(filters::get()));
```

### Filtros de ruta

Los filtros basados en la ruta de solicitud son los más utilizados. Pueden definir parámetros:

```rust
Router::with_path("articles/{id}").get(show_article);
Router::with_path("files/{**rest_path}").get(serve_file)
```

En el `Handler`, se pueden obtener a través de la función `get_param` del objeto `Request`:

```rust
#[handler]
pub async fn show_article(req: &mut Request) {
    let article_id = req.param::<i64>("id");
}

#[handler]
pub async fn serve_file(req: &mut Request) {
    let rest_path = req.param::<i64>("rest_path");
}
```

### Filtros de método

Filtran solicitudes según el método HTTP:

```rust
Router::new().get(show_article).patch(update_article).delete(delete_article);
```

Aquí, `get`, `patch` y `delete` son filtros de método. Es equivalente a:

```rust
use salvo::routing::filter;

let mut root_router = Router::new();
let show_router = Router::with_filter(filters::get()).handle(show_article);
let update_router = Router::with_filter(filters::patch()).handle(update_article);
let delete_router = Router::with_filter(filters::get()).handle(delete_article);
Router::new().push(show_router).push(update_router).push(delete_router);
```

## Wisp personalizado

Para expresiones de coincidencia frecuentes, podemos asignar un nombre breve usando `PathFilter::register_wisp_regex` o `PathFilter::register_wisp_builder`. Por ejemplo, el formato GUID aparece a menudo en rutas. Normalmente, se escribiría así cada vez:

```rust
Router::with_path("/articles/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
Router::with_path("/users/<id:/[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}/>");
```

Escribir esta expresión regular compleja cada vez es propenso a errores y antiestético. En su lugar, podemos hacer:

```rust
use salvo::routing::filter::PathFilter;

#[tokio::main]
async fn main() {
    let guid = regex::Regex::new("[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}").unwrap();
    PathFilter::register_wisp_regex("guid", guid);
    Router::new()
        .push(Router::with_path("/articles/{id:guid}").get(show_article))
        .push(Router::with_path("/users/{id:guid}").get(show_user));
}
```

Solo necesitas registrarlo una vez; luego, puedes usar `{id:guid}` para coincidir con GUID, simplificando el código.

## ¿Cómo entender Router si vienes de un framework web basado en Controller?

Las principales diferencias entre un framework web basado en enrutamiento (como Salvo) y los diseños tradicionales MVC o basados en Controller son:

- **Flexibilidad**: El diseño basado en enrutamiento permite definir el flujo de procesamiento de solicitudes de manera más flexible, controlando con precisión la lógica para cada ruta. Por ejemplo, en Salvo puedes definir directamente funciones para rutas específicas:
  ```rust
  Router::with_path("articles").get(list_articles).post(create_article);
  ```
  En un diseño Controller, normalmente necesitas definir una clase controladora y luego métodos dentro de ella:
  ```java
  @Controller
  public class ArticleController {
      @GetMapping("/articles")
      public List<Article> listArticles() { /* ... */ }
      
      @PostMapping("/articles")
      public Article createArticle(@RequestBody Article article) { /* ... */ }
  }
  ```

- **Integración de middleware**: Los frameworks de enrutamiento suelen ofrecer una integración más concisa de middleware, aplicable a rutas específicas. En Salvo, el middleware se puede aplicar con precisión:
  ```rust
  Router::new()
      .push(
          Router::with_path("admin/articles")
              .hoop(admin_auth_middleware)  // Middleware de autenticación solo para rutas de admin
              .get(list_all_articles)
              .post(create_article),
      )
      .push(
          Router::with_path("articles")  // Rutas públicas sin autenticación
              .get(list_public_articles),
      );
  ```

- **Organización del código**: El diseño basado en enrutamiento tiende a organizar el código por funcionalidad o endpoint de API, en lugar de por capas MVC (modelo-vista-controlador).
  Fomenta la organización por funcionalidad de endpoints:
  ```rust
  // user_routes.rs - Rutas y lógica relacionada con usuarios
  pub fn user_routes() -> Router {
      Router::with_path("users")
          .get(list_users)
          .post(create_user)
          .push(Router::with_path("{id}").get(get_user).delete(delete_user))
  }
  
  // article_routes.rs - Rutas y lógica relacionada con artículos
  pub fn article_routes() -> Router {
      Router::with_path("articles")
          .get(list_articles)
          .post(create_article)
  }
  
  // Combinar rutas en la aplicación principal
  let router = Router::new()
      .push(user_routes())
      .push(article_routes());
  ```

- **Ligereza**: Generalmente, el diseño basado en enrutamiento es más ligero, reduciendo conceptos y restricciones impuestos por el framework. Puedes incluir solo los componentes necesarios sin seguir una estructura estricta.

El diseño basado en enrutamiento hace que el desarrollo de APIs sea más intuitivo, especialmente adecuado para microservicios modernos y APIs RESTful. En frameworks como Salvo, el enrutamiento es un concepto central que refleja directamente la estructura y comportamiento de la API, haciendo el código más fácil de entender y mantener. En contraste, los diseños Controller tradicionales a menudo requieren más configuración y convenciones para lograr la misma funcionalidad.

# Resumen de métodos de la estructura Router

| Categoría | Método | Descripción |
|-----------|--------|-------------|
| **Creación/Acceso** | `new()` | Crea un nuevo enrutador |
| | `routers()/routers_mut()` | Obtiene referencia/referencia mutable a subenrutadores |
| | `hoops()/hoops_mut()` | Obtiene referencia/referencia mutable a middleware |
| | `filters()/filters_mut()` | Obtiene referencia/referencia mutable a filtros |
| **Organización de rutas** | `unshift()` | Inserta subenrutador al principio |
| | `insert()` | Inserta subenrutador en posición específica |
| | `push()` | Agrega subenrutador |
| | `append()` | Agrega múltiples subenrutadores |
| | `then()` | Configuración personalizada de cadena de enrutadores |
| **Middleware** | `with_hoop()/hoop()` | Crea/agrega middleware |
| | `with_hoop_when()/hoop_when()` | Crea/agrega middleware cond
{/* Auto generated, origin file hash:ba0a1eadc077c274134c7a533d887f99 */}