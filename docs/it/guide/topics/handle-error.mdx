# Gestione degli Errori

## Approccio Convenzionale alla Gestione degli Errori nelle Applicazioni Rust

La gestione degli errori in Rust differisce da linguaggi come Java; non esiste un costrutto `try...catch`. La pratica comune consiste nel definire un tipo di errore globale a livello dell'applicazione:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("io: `{0}`")]
    Io(#[from] io::Error),
    #[error("utf8: `{0}`")]
    FromUtf8(#[from] FromUtf8Error),
    #[error("diesel: `{0}`")]
    Diesel(#[from] diesel::result::Error),
    ...
}

pub type AppResult<T> = Result<T, AppError>;
```

Qui viene utilizzata la libreria `thiserror`, che permette di definire comodamente i propri tipi di errore personalizzati, semplificando il codice. Per una scrittura più concisa, definiamo anche un `AppResult`.

### thiserror vs anyhow

Nell'ecosistema della gestione degli errori in Rust, due librerie comunemente utilizzate sono `thiserror` e `anyhow`:

- **thiserror**: Ideale per gli sviluppatori di librerie, serve a definire tipi di errore chiari. Attraverso una macro derivata, aiuta a implementare il tratto `std::error::Error` per i tipi di errore personalizzati, consentendo allo stesso tempo di definirne la rappresentazione. Quando si costruisce una libreria o si ha bisogno di fornire tipi di errore chiari agli utenti, `thiserror` è la scelta migliore.

- **anyhow**: Rivolta agli sviluppatori di applicazioni, fornisce un tipo di errore generico `anyhow::Error`, in grado di contenere qualsiasi errore che implementi il tratto `std::error::Error`. Si concentra più sulla propagazione degli errori che sulla loro definizione, ed è particolarmente adatta per il codice a livello applicativo. Permette di convertire rapidamente vari errori in `anyhow::Error`, riducendo la necessità di scrivere codice boilerplate.

In alcuni scenari, potreste utilizzare entrambe le librerie: `thiserror` per definire i tipi di errore nella libreria, e `anyhow` per gestirli e propagarli nell'applicazione.

## Gestione degli Errori negli Handler

In Salvo, anche gli `Handler` incontrano frequentemente vari tipi di errori, come: errori di connessione al database, errori di accesso ai file, errori di connessione di rete, ecc. Per questo tipo di errori, si può adottare l'approccio di gestione sopra descritto:

```rust
#[handler]
async fn home()-> AppResult<()> {

}
```

Qui, `home` restituisce direttamente un `AppResult<()>`. Ma come dovrebbe essere visualizzato questo errore? Dobbiamo implementare `Writer` per il tipo di errore personalizzato `AppResult`, e in questa implementazione possiamo decidere come visualizzare l'errore:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        res.render(Text::Plain("Sono un errore, ahahah!"));
    }
}
```

Gli `Handler` in Salvo possono restituire `Result`, purché i tipi `Ok` e `Err` all'interno del `Result` implementino entrambi il tratto `Writer`.

### Utilizzo di anyhow per la Gestione degli Errori

Considerando l'ampio utilizzo di anyhow, Salvo fornisce supporto integrato per `anyhow::Error`. Dopo aver abilitato la funzionalità `anyhow`, `anyhow::Error` implementerà il tratto `Writer` e verrà mappato su `InternalServerError`:

```rust
#[cfg(feature = "anyhow")]
#[async_trait]
impl Writer for ::anyhow::Error {
    async fn write(mut self, _req: &mut Request, _depot: &mut Depot, res: &mut Response) {
        res.render(StatusError::internal_server_error());
    }
}
```

Per utilizzare la funzionalità anyhow, è necessario abilitare la feature `anyhow` di Salvo in Cargo.toml:

```toml
[dependencies]
salvo = { version = "*", features = ["anyhow"] }
anyhow = "1.0"
```

In questo modo, le vostre funzioni handler possono restituire direttamente `anyhow::Result<T>`:

```rust
#[handler]
async fn home() -> anyhow::Result<impl Writer> {
    let data = fetch_data().context("Impossibile recuperare i dati")?;
    Ok(Text::Plain(data))
}
```

Gli `Error` spesso contengono informazioni sensibili che, in genere, non si desidera siano visibili agli utenti comuni, per motivi di sicurezza e privacy. Tuttavia, se siete sviluppatori o amministratori del sito, la prospettiva potrebbe cambiare: potreste voler vedere l'errore "nudo e crudo", con le informazioni più dettagliate possibili.

Come si può vedere, nel metodo `write` abbiamo accesso ai riferimenti a `Request` e `Depot`, il che permette di implementare facilmente l'operazione sopra descritta:

```rust
#[async_trait]
impl Writer for AppError {
    async fn write(mut self, _req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let user = depot.obtain::<User>();
        if user.is_admin {
            res.render(Text::Plain(e.to_string()));
        } else {
            res.render(Text::Plain("Sono un errore, ahahah!"));
        }
    }
}
```

## Visualizzazione delle Pagine di Errore

La pagina di errore integrata in Salvo soddisfa le esigenze nella maggior parte dei casi, poiché può visualizzare pagine Html, Json o Xml in base al tipo di dati della richiesta. Tuttavia, in alcune situazioni, potremmo comunque voler personalizzare la visualizzazione della pagina di errore.

Questo può essere realizzato implementando un `Catcher` personalizzato. Per una spiegazione dettagliata, consultate la sezione [`Catcher`](../concepts/catcher.html).
{/* 本行由工具自动生成,原文哈希值:ccc3ad5dca846f6b6415dbe84e0c5166 */}