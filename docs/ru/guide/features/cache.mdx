# Кэширование

Промежуточное ПО, предоставляющее функциональность кэширования.

Промежуточное ПО Cache может кэшировать `StatusCode`, `Headers` и `Body` `Response`. Для контента, который уже был закэширован, промежуточное ПО Cache будет напрямую отправлять закэшированное содержимое из памяти клиенту при обработке последующих запросов.

Примечание: Этот плагин не кэширует объекты `Response`, чей `Body` имеет тип `ResBody::Stream`. Если применить его к такому `Response`, Cache не будет обрабатывать эти запросы, и ошибка не возникнет.

## Основные возможности

- `CacheIssuer` предоставляет абстракцию для генерации ключей кэша. `RequestIssuer` является одной из его реализаций, позволяя вам определять, какие части URL запроса и `Method` запроса должны использоваться для генерации ключа кэша. Вы также можете определить свою собственную логику генерации ключей кэша. Ключ кэша не обязательно должен быть строкой; любой тип, удовлетворяющий ограничениям `Hash + Eq + Send + Sync + 'static`, может использоваться в качестве ключа.

- `CacheStore` предоставляет операции для хранения и извлечения данных. `MokaStore` — это встроенная реализация кэша в памяти на основе `moka`. Вы также можете определить свою собственную реализацию.

- `Cache` — это структура, реализующая `Handler`. Она также содержит внутреннее поле `skipper`, которое можно использовать для указания запросов, которые должны пропускать кэширование. По умолчанию используется `MethodSkipper`, чтобы пропускать все запросы, кроме тех, которые используют `Method::GET`.

  Пример внутреннего кода реализации:

  ```rust
  impl<S, I> Cache<S, I> {
    pub fn new(store: S, issuer: I) -> Self {
        let skipper = MethodSkipper::new().skip_all().skip_get(false);
        Cache {
            store,
            issuer,
            skipper: Box::new(skipper),
        }
    }
  }
  ```

## Быстрая миграция с других фреймворков

Если вы использовали механизмы кэширования в других фреймворках, следующие концептуальные соответствия помогут вам быстрее адаптироваться к реализации кэширования в Salvo:

### Руководство по миграции с Rust-фреймворков

- **Миграция с Actix-web**: Плагины, такие как `actix-web-cache` в Actix-web, обычно требуют отдельного подключения, тогда как кэширование в Salvo является частью основной библиотеки.

  ```rust
  // Пример кэширования в Actix-web
  use actix_web_cache::Cache;
  App::new().wrap(Cache::new().ttl(30))

  // Соответствующая реализация в Salvo
  use salvo::prelude::*;
  Router::new().hoop(Cache::new(MokaStore::new(100), RequestIssuer::new()))
  ```

### Руководство по миграции с фреймворков на других языках

- **Миграция с Go/Gin**: Gin использует паттерн промежуточного ПО, который Salvo также применяет аналогичным образом:

  ```go
  // Пример кэширования в Gin
  store := persist.NewMemoryStore(time.Second * 60)
  router.Use(cache.CachePage(store, time.Second * 30))
  ```

  ```rust
  // Соответствующая реализация в Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(30));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

- **Миграция с Spring Boot**: Декларативное кэширование Spring Boot необходимо преобразовать в явную конфигурацию промежуточного ПО в Salvo:

  ```java
  // Spring Boot
  @Cacheable(value = "books", key = "#isbn")
  public Book findBook(ISBN isbn) { ... }
  ```
  ```rust
  // Соответствующая реализация в Salvo - применение кэша на уровне маршрута
  let custom_issuer = YourCustomIssuer::new(); // Реализуйте интерфейс CacheIssuer
  Router::with_path("books").hoop(Cache::new(MokaStore::new(100), custom_issuer))
  ```

- **Миграция с Express.js**: Промежуточное ПО кэширования в Express концептуально похоже на таковое в Salvo, но синтаксис отличается:

  ```javascript
  // Express.js
  const apicache = require('apicache');
  app.use(apicache.middleware('5 minutes'));

  // Соответствующая реализация в Salvo
  let store = MokaStore::new(100).with_ttl(Duration::from_secs(300));
  router.hoop(Cache::new(store, RequestIssuer::new()))
  ```

При миграции с других фреймворков обратите внимание на несколько ключевых концепций кэширования в Salvo:

1. **Генерация ключа кэша** — Управляется через интерфейс `CacheIssuer`.
2. **Хранилище кэша** — Реализуется через интерфейс `CacheStore`.
3. **Логика пропуска кэша** — Настраивается через механизм `skipper`.

По умолчанию Salvo кэширует только GET-запросы, что соответствует поведению по умолчанию в большинстве фреймворков.

_**Пример кода**_

import { Tab, Tabs } from '@rspress/core/theme';

<Tabs>
  <Tab label="main.rs">
  ```rust file="<root>/codes/cache-simple/src/main.rs"
  ```
  </Tab>
  <Tab label="Cargo.toml">
  ```toml file="<root>/codes/cache-simple/Cargo.toml"
  ```
  </Tab>
</Tabs>
{/* Auto generated, origin file hash:6ae106316ebd0ee4b0ba1fabf6fe7a3f */}