# Para Dominar Esta Arte

## Por que Escrever Este Framework

Na época, como iniciante, percebi que era muito lento e não conseguia aprender a usar frameworks existentes como actix-web e Rocket. Quando quis reescrever meus serviços web em Go usando Rust, à primeira vista, cada framework parecia mais complexo do que os existentes em Go. Já que a curva de aprendizado do Rust é bastante íngreme, por que tornar o framework web ainda mais complicado?

Quando o Tokio lançou o framework Axum, fiquei feliz pensando que não precisaria mais manter meu próprio framework web. No entanto, a realidade é que o Axum, apesar de parecer simples, envolve muita ginástica de tipos e definições genéricas durante o uso. É necessário um profundo conhecimento de Rust e a paciência para escrever grandes quantidades de código de template obscuro apenas para implementar um middleware simples.

Por isso, decidi continuar mantendo meu framework web, que é bastante peculiar (prático, rico em recursos e adequado para iniciantes).

## O Salvo é Adequado para Você?

Embora o Salvo seja simples, ele é abrangente e poderoso o suficiente, podendo ser considerado basicamente o mais forte no ecossistema Rust. No entanto, mesmo sendo um sistema tão poderoso, aprender e usá-lo é realmente simples. Definitivamente, não causará a dor de ter que "cortar fora partes de si mesmo".

- É adequado para iniciantes que estão aprendendo Rust. CRUD é uma funcionalidade extremamente comum e frequentemente usada. Se você usar o Salvo para tarefas semelhantes, descobrirá que ele é tão simples quanto os frameworks web de outras linguagens que você já usou (por exemplo: Express, Koa, Gin, Flask...), sendo até mais abstrato e conciso em alguns aspectos;

- É adequado para quem deseja usar Rust em ambientes de produção, fornecendo servidores robustos e rápidos. Embora o Salvo não tenha lançado a versão 1.0, suas funcionalidades principais passaram por anos de iteração, são suficientemente estáveis e os problemas são corrigidos rapidamente;

- É adequado para você, cujos cabelos já não são mais tão densos, mas continuam caindo todos os dias.

## Como Alcançar a Simplicidade Suficiente

Muitas implementações de baixo nível já foram realizadas pelo Hyper, então, para necessidades gerais, basear-se no Hyper não está errado. O Salvo segue a mesma linha. Suas funcionalidades principais são um sistema de roteamento poderoso e flexível, além de muitos recursos comuns, como Acme, OpenAPI, autenticação JWT, etc.

No Salvo, Handler e Middleware são unificados. Middleware é Handler. Eles são adicionados ao Router através do hoop do roteador. Em essência, tanto Middleware quanto Handler processam requisições Request e podem escrever dados no Response. O Handler recebe três parâmetros: Request, Depot e Response, onde o Depot é usado para armazenar dados temporários durante o processamento da requisição.

Para facilitar a escrita, é possível omitir certos parâmetros quando não são necessários, e a ordem dos parâmetros pode ser ignorada.

```rust
use salvo::prelude::*;

#[handler]
async fn hello_world(_req: &mut Request, _depot: &mut Depot, res: &mut Response) {
    res.render("Hello world");
}
#[handler]
async fn hello_world(res: &mut Response) {
    res.render("Hello world");
}
```

Além disso, a API fornecida pelo sistema de roteamento é extremamente simples, mas poderosa. Para necessidades de uso normais, basicamente, você só precisa se preocupar com o tipo Router.
Além disso, se uma estrutura implementar os traits relevantes, o Salvo pode gerar automaticamente a documentação OpenAPI, extrair parâmetros, lidar automaticamente com diferentes erros e retornar mensagens amigáveis. Isso torna a escrita de handlers tão simples e intuitiva quanto escrever funções comuns. Nos tutoriais seguintes, explicaremos essas funcionalidades em detalhes passo a passo. Aqui está um exemplo:

```rust

#[endpoint(tags("registros de mensagens"))]
pub async fn create_message_log_handler(
    input: JsonBody<CreateOrUpdateMessageLog>,
    depot: &mut Depot,
) -> APPResult<Json<MessageLog>> {
    let db = utils::get_db(depot)?;
    let log = create_message_log(&input, db).await?;
    Ok(Json(log))
}
```

Neste exemplo, `JsonBody<CreateOrUpdateMessageLog>` analisará automaticamente os dados JSON do corpo da requisição e os converterá para o tipo `CreateOrUpdateMessageLog` (também suporta múltiplas fontes de dados e tipos aninhados). Ao mesmo tempo, a macro `#[endpoint]` gerará automaticamente a documentação OpenAPI para esta interface, simplificando o código de extração de parâmetros e tratamento de erros.

## Sistema de Roteamento

Sinto que o sistema de roteamento é diferente de outros frameworks. O Router pode ser escrito de forma plana ou em forma de árvore. Aqui, distinguimos entre a árvore de lógica de negócios e a árvore de diretórios de acesso. A árvore de lógica de negócios divide a estrutura do router de acordo com as necessidades da lógica de negócios, formando uma árvore de routers, que não necessariamente coincide com a árvore de diretórios de acesso.

Normalmente, escrevemos as rotas assim:

```rust
Router::new().path("articles").get(list_articles).post(create_article);
Router::new()
    .path("articles/{id}")
    .get(show_article)
    .patch(edit_article)
    .delete(delete_article);
```

Geralmente, visualizar artigos e listar artigos não requer login do usuário, mas criar, editar e excluir artigos exigem autenticação e permissões de login. O sistema de roteamento aninhado do Salvo pode atender bem a essa necessidade. Podemos agrupar as rotas que não requerem login:

```rust
Router::new()
    .path("articles")
    .get(list_articles)
    .push(Router::new().path("{id}").get(show_article));
```

Em seguida, agrupamos as rotas que requerem login e usamos o middleware correspondente para verificar se o usuário está logado:
```rust
Router::new()
    .path("articles")
    .hoop(auth_check)
    .post(list_articles)
    .push(Router::new().path("{id}").patch(edit_article).delete(delete_article));
```

Embora ambas as rotas tenham o mesmo `path("articles")`, elas ainda podem ser adicionadas ao mesmo router pai. Portanto, o router final fica assim:

```rust
Router::new()
    .push(
        Router::new()
            .path("articles")
            .get(list_articles)
            .push(Router::new().path("{id}").get(show_article)),
    )
    .push(
        Router::new()
            .path("articles")
            .hoop(auth_check)
            .post(list_articles)
            .push(Router::new().path("{id}").patch(edit_article).delete(delete_article)),
    );
```

`{id}` corresponde a um segmento do caminho. Normalmente, o `id` de um artigo é apenas um número. Nesse caso, podemos usar expressões regulares para restringir as regras de correspondência do `id`, como `r"{id:/\d+/}"`.
{/* 本行由工具自动生成,原文哈希值:bd1fc4c816e814fa9f1d5c39301ad59a */}